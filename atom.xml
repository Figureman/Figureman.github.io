<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>故乡渊</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-02T17:53:00.023Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jww</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Anchor-based and Anchor-free 概念理解</title>
    <link href="http://example.com/2023/05/02/CV%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2023/05/02/CV%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</id>
    <published>2023-05-01T16:00:00.000Z</published>
    <updated>2023-05-02T17:53:00.023Z</updated>
    
    <content type="html"><![CDATA[<h2>一、FPN</h2>FPN是特征金字塔网络（Feature Pyramid Network）的缩写，是一种用于目标检测的深度学习模型。相较于传统的卷积神经网络（CNN），FPN的最大特点在于它可以生成不同尺度的特征金字塔，为检测不同大小物体提供支持。FPN模型在目标检测中的核心思想是提出一种新的特征提取方法，该方法可以产生具有不同尺度信息的特征金字塔，其中较低层级的金字塔主要用于检测较小的目标，而较高层级的金字塔主要用于检测较大的目标。FPN模型将金字塔中的特征图沿着空间维度上采样，并和低层级的特征图进行融合，从而产生具有不同尺度信息的特征金字塔。FPN模型不仅可以提高目标检测的准确率，而且可以提高模型的速度和效率。在目标检测任务中，FPN模型经常被用来检测不同大小的目标，并且在许多比赛和实际应用中表现优异，如COCO2017比赛、物体检测、图像分割等领域。<h2>二、Focal Loss</h2><p>Focal Loss是一种用于解决类别不平衡问题的损失函数，在2017年提出并广泛应用于目标检测和图像分割等领域。它是由Ross Girshick等人提出的一篇论文”Focal Loss for Dense Object Detection”中提出的。</p><p>在目标检测和图像分割等任务中，常常会遇到类别不平衡的情况，即某些类别的样本数量远多于其他类别的样本数量。这种情况下，传统的交叉熵损失函数会将大量的权重分配给数量较多的类别，导致少量的类别被忽视，从而影响模型的性能。</p><p>Focal Loss通过引入一个平衡因子，来缓解类别不平衡问题，该平衡因子主要通过减小易分类样本的权重来实现，同时增加难分类样本的权重。具体来说，Focal Loss对于易分类的样本，降低了它们的权重，从而减少了其对损失函数的贡献；对于难分类的样本，增加了它们的权重，从而增加了其对损失函数的贡献。这种方法可以使模型更加关注难分类样本，提高模型的性能。</p><p>在目标检测和图像分割等领域，Focal Loss已经被广泛应用于各种深度学习模型中，并取得了显著的性能提升。</p><h2>三、FPN模型和Focal Loss 对 anchor-free的影响</h2><p>PN模型和Focal Loss对anchor-free目标检测的影响如下：</p><ol><li>FPN模型：FPN模型可以生成不同尺度的特征金字塔，其中较低层级的金字塔主要用于检测较小的目标，而较高层级的金字塔主要用于检测较大的目标。对于anchor-free目标检测，FPN模型可以提供多尺度的特征金字塔，有利于检测不同大小的目标。因此，FPN模型在anchor-free目标检测中也被广泛应用。</li><li>Focal Loss：Focal Loss对于易分类的样本，降低了它们的权重，从而减少了其对损失函数的贡献；对于难分类的样本，增加了它们的权重，从而增加了其对损失函数的贡献。在anchor-free目标检测中，Focal Loss可以使模型更加关注难以分类的目标，提高模型的性能。</li></ol><p>综上所述，FPN模型和Focal Loss都可以对anchor-free目标检测产生积极的影响。在实际应用中，它们经常被同时应用于anchor-free目标检测中，以提高检测的准确率和效率。</p><h2>四、为什么有了FPN模型和Focal Loss ， anchor-free越来越受欢迎</h2><p>有了FPN模型和Focal Loss，anchor-free目标检测越来越受欢迎，主要有以下原因：</p><ol><li>更加灵活：相比于传统的anchor-based目标检测方法，anchor-free方法不需要提前定义一组锚点，因此更加灵活。这意味着anchor-free方法可以应用于各种不同的目标检测场景，例如目标大小和形状不确定的情况。</li><li>更高效：在anchor-based方法中，每个锚点都需要进行预测，因此会产生大量的冗余计算。而anchor-free方法则没有这个问题，因为它只需要对特征图中的像素进行分类和回归。这使得anchor-free方法在计算效率方面更有优势。</li><li>更加准确：FPN模型可以生成多尺度的特征金字塔，有利于检测不同大小的目标。Focal Loss可以使模型更加关注难以分类的目标，提高模型的性能。这些技术的应用使得anchor-free方法在准确率方面越来越接近传统的anchor-based方法，甚至超过了一些基于锚点的方法。</li></ol><p>综上所述，FPN模型和Focal Loss的出现，使得anchor-free方法在目标检测领域受到了越来越多的关注和应用。同时，随着深度学习技术的不断发展和优化，相信anchor-free方法将会在未来的目标检测领域中发挥越来越重要的作用。</p><h2>五、anchor-based目标检测方法可以分为one-stage和two-stage方法，请分别详细描述这两种方法，讨论他们的优点和缺点</h2><p>目标检测是计算机视觉领域的一个重要研究方向，其中anchor-based方法是常用的目标检测方法之一。它可以分为one-stage和two-stage方法，下面分别对这两种方法进行详细描述，并讨论它们的优缺点。</p><h3>1、One-stage方法</h3><p>One-stage方法是指在单个网络中完成目标检测的方法，最典型的代表是YOLO（You Only Look Once）和SSD（Single Shot MultiBox Detector）等。</p><h3>YOLO</h3><p>YOLO使用一个单独的卷积神经网络，直接对整张图片进行目标检测，具体流程如下：</p><ol><li>将输入图像划分为SxS个网格，每个网格负责预测B个边界框和C个类别概率。</li><li>对于每个边界框，预测其包含目标的置信度，以及其相对于该网格的坐标和大小。</li><li>最后根据置信度和类别概率筛选出目标并进行定位。</li></ol><h3>SSD</h3><p>SSD也是一种单阶段的目标检测方法，其主要思想是使用多尺度的卷积特征图进行检测。具体流程如下：</p><ol><li>对输入图像使用多尺度的卷积网络提取特征，得到多个不同大小的特征图。</li><li>对每个特征图，通过卷积层和预测层进行目标检测，得到每个位置的类别概率和边界框偏移量。</li><li>将所有特征图的预测结果合并，并通过非极大值抑制（NMS）筛选出目标。</li></ol><h4>One-stage方法的优点</h4><ol><li>实时性高：由于One-stage方法只需要对图像进行一次前向计算，因此它们的处理速度比Two-stage方法更快，适用于实时的目标检测场景。</li><li>目标检测精度高：One-stage方法可以通过增加网络深度、调整网络结构和损失函数等手段来提高检测精度，已经可以达到很高的性能。</li></ol><h4>One-stage方法的缺点</h4><ol><li>对小目标的检测不够准确：One-stage方法在检测小目标时，由于缺少多尺度特征金字塔和先验框等信息，容易出现误检或漏检的问题。</li><li>目标定位精度低：One-stage方法对于目标的定位精度不如Two-stage方法，因为它们缺乏ROI池化层或者其他明确的目标定位策略。</li></ol><h3>2、Two-stage方法</h3><p>Two-stage方法是指目标检测分为两个阶段进行，第一个阶段是在图像中提取一些候选区域，第二个阶段是对这些候选区域进行分类和定位，最典型的代表是Faster R-CNN和Mask R-CNN等。</p><h4>Faster R-CNN</h4><p>Faster R-CNN主要包含两个模块：Region Proposal Network（RPN）和Fast R-CNN。</p><ol><li>RPN：对输入图像进行卷积特征提取，并在每个特征点处产生多个不同尺寸和长宽比的锚点框（anchor box）。</li><li>Fast R-CNN：将RPN提取的锚点框作为候选区域，通过ROI pooling层将每个候选区域映射到固定大小的特征图上，再通过全连接层进行分类和回归。</li><li>最后通过非极大值抑制筛选出最终的目标框。</li></ol><h4>Mask R-CNN</h4><p>Mask R-CNN是在Faster R-CNN的基础上增加了一个Mask预测分支，可以同时进行目标检测和语义分割。</p><ol><li>RPN：同Faster R-CNN。</li><li>RoIAlign：对候选区域进行更精确的特征映射，得到每个候选区域的固定大小特征图。</li><li>分类和回归：同Faster R-CNN。</li><li>Mask分支：在每个RoI区域上进行预测，生成每个像素的目标掩码。</li></ol><h4>Two-stage方法的优点</h4><ol><li>对小目标检测更准确：Two-stage方法通过金字塔特征提取、RPN等策略可以生成不同尺度的候选区域，能够更准确地检测小目标。</li><li>目标定位精度更高：Two-stage方法在RoI pooling层等环节对目标进行定位，可以精确地定位目标的位置。</li></ol><h4>Two-stage方法的缺点</h4><ol><li>实时性较低：Two-stage方法需要对图像进行两次前向计算，速度较慢，适用于对实时性要求不高的场景。</li><li>设计和调参难度较大：Two-stage方法需要进行目标检测和提取候选区域两个任务的优化，需要在设计和调参上付出更多的努力。</li></ol><p>总的来说，One-stage方法适用于实时性要求高，目标检测精度要求适中的场景，Two-stage方法适用于对目标检测精度要求高，实时性要求适中的场景。</p><h2>六、Anchor-free detectors directly find objects without preset anchors in two different ways.</h2><p>Anchor-free目标检测器直接在图像中寻找物体而不需要预设锚点，可以分为两种不同的方式：</p><ol><li>CenterNet</li></ol><p>CenterNet直接在图像中寻找物体中心点，并以此为基础进行目标检测。具体来说，CenterNet使用高斯热力图来表示目标中心点，然后通过回归网络来输出目标框的位置和尺寸，并进行目标分类。在预测过程中，CenterNet将每个像素点都视为候选中心点，通过筛选出具有高响应值的中心点来实现目标检测。</p><ol><li>FCOS</li></ol><p>FCOS（Fully Convolutional One-Stage）是一种全卷积的、基于中心点的单阶段目标检测器。FCOS通过预测每个像素点对于物体中心点的距离和偏移量，来确定目标的位置和尺寸。同时，FCOS还引入了一个特征金字塔网络来处理不同尺度的特征图，并通过分类和回归来预测目标类别和边界框。与CenterNet不同，FCOS使用密集采样来获得足够多的正负样本，并且在训练过程中使用了一种新的损失函数来平衡不同大小的目标之间的重要性。</p><p>总的来说，CenterNet和FCOS都是基于中心点的Anchor-free目标检测器，它们不需要预设的锚点，具有更好的可解释性和泛化能力，但由于需要对每个像素点进行处理，因而在速度上可能有所欠缺。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;一、FPN&lt;/h2&gt;
FPN是特征金字塔网络（Feature Pyramid Network）的缩写，是一种用于目标检测的深度学习模型。相较于传统的卷积神经网络（CNN），FPN的最大特点在于它可以生成不同尺度的特征金字塔，为检测不同大小物体提供支持。

FPN模型在目标</summary>
      
    
    
    
    <category term="计算机视觉" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="目标检测" scheme="http://example.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    <category term="计算机视觉" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/04/%E7%AE%97%E6%B3%953/"/>
    <id>http://example.com/2023/03/04/%E7%AE%97%E6%B3%953/</id>
    <published>2023-03-03T16:22:03.298Z</published>
    <updated>2023-03-03T16:30:10.764Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数二分算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数二分算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度加法</span></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度乘低精度</span></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度除以低精度</span></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维前缀和</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维差分</span></span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维差分</span></span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位运算</span></span><br><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针算法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/277/">https://www.acwing.com/blog/content/277/</a><br>来源：AcWing</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Attention学习机制数学推导</title>
    <link href="http://example.com/2023/03/02/Attention%E5%AD%A6%E4%B9%A0%E6%9C%BA%E5%88%B6%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
    <id>http://example.com/2023/03/02/Attention%E5%AD%A6%E4%B9%A0%E6%9C%BA%E5%88%B6%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</id>
    <published>2023-03-01T16:16:41.922Z</published>
    <updated>2023-05-02T17:48:06.731Z</updated>
    
    <content type="html"><![CDATA[<p>注意力机制是一种在深度学习中常用的机制，可以在处理变长输入序列时，让模型更加关注与当前任务相关的信息。下面是注意力机制的数学证明。</p><p>假设我们有一个输入序列$x = (x_1, x_2, …, x_T)$，其中每个$x_t$都是一个向量，$y$是输出序列。我们需要在每个时间步$t$选择适当的$x_t$来计算$y_t$。注意力机制的思想是，对于每个时间步$t$，我们计算出$x_t$和所有$x_i$之间的相似度得分，然后根据这些得分来给每个$x_i$分配一个权重，最终使用加权平均的方法来计算$y_t$。</p><p>具体来说，我们可以使用一个查询向量$q_t$来度量$x_t$和所有$x_i$之间的相似度。一种常用的计算方式是点积计算：</p><script type="math/tex; mode=display">\text{score}(q_t, x_i) = q_t^Tx_i</script><p>接着，我们可以将得分进行归一化，得到一个权重向量$\alpha<em>t$，其中$\alpha</em>{t,i}$表示在计算$y_t$时应该分配给$x_i$的权重：</p><script type="math/tex; mode=display">\alpha_{t,i} = \frac{\exp(\text{score}(q_t, x_i))}{\sum_{j=1}^{T}\exp(\text{score}(q_t, x_j))}</script><p>最后，我们可以使用加权平均的方法来计算$y_t$：</p><script type="math/tex; mode=display">y_t = \sum_{i=1}^{T}\alpha_{t,i}x_i</script><p>注意力机制的数学证明主要是通过反向传播算法来训练模型。假设$L$是损失函数，我们需要计算$L$对$q_t$和$x_i$的梯度。根据链式法则，我们可以将$L$对$x_i$的梯度表示为：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial x_i} = \sum_{t=1}^{T}\frac{\partial L}{\partial y_t}\alpha_{t,i}</script><p>这意味着，对于每个$x_i$，我们可以通过对所有$y_t$进行加权求和，来计算$L$对$x_i$的梯度。类似地，我们可以将$L$对$q_t$的梯度表示为：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial q_t} = \sum_{i=1}^{T}\frac{\partial L}{\partial y_t}\frac{\partial y_t}{\partial \alpha_{t,i}}\frac{\partial \alpha_{t,i}}{\partial q_t}</script><p>其中，$\frac{\partial y<em>t}{\partial \alpha</em>{t,i}}$表示$y<em>t$对$\alpha</em>{t,i}$的梯度，可以通过链式法则计算得出：</p><script type="math/tex; mode=display">\frac{\partial y_t}{\partial \alpha_{t,i}} = x_i</script><p>$\frac{\partial \alpha_{t,i}}{\partial q_t}$表示$\</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意力机制是一种在深度学习中常用的机制，可以在处理变长输入序列时，让模型更加关注与当前任务相关的信息。下面是注意力机制的数学证明。&lt;/p&gt;
&lt;p&gt;假设我们有一个输入序列$x = (x_1, x_2, …, x_T)$，其中每个$x_t$都是一个向量，$y$是输出序列。我们需</summary>
      
    
    
    
    <category term="RNN  VS  Transformer" scheme="http://example.com/categories/RNN-VS-Transformer/"/>
    
    
    <category term="Paper" scheme="http://example.com/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>基础算法之排序</title>
    <link href="http://example.com/2023/01/17/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/01/17/%E7%AE%97%E6%B3%95/</id>
    <published>2023-01-17T12:10:00.000Z</published>
    <updated>2023-01-17T12:23:46.415Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>,x=q[i+j&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(x&gt;q[i]);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(x&lt;q[j]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">int</span> tmp[];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;= mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=r)tmp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)q[i]=tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快排" scheme="http://example.com/tags/%E5%BF%AB%E6%8E%92/"/>
    
    <category term="归并" scheme="http://example.com/tags/%E5%BD%92%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>基础算法之二分</title>
    <link href="http://example.com/2023/01/17/%E7%AE%97%E6%B3%951/"/>
    <id>http://example.com/2023/01/17/%E7%AE%97%E6%B3%951/</id>
    <published>2023-01-17T12:10:00.000Z</published>
    <updated>2023-01-17T14:10:37.314Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两种整数二分方法</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数二分</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="整数二分" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
    <category term="浮点数二分" scheme="http://example.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>基础算法之高精度加减乘除法</title>
    <link href="http://example.com/2023/01/17/%E7%AE%97%E6%B3%952/"/>
    <id>http://example.com/2023/01/17/%E7%AE%97%E6%B3%952/</id>
    <published>2023-01-17T12:10:00.000Z</published>
    <updated>2023-01-18T15:17:40.266Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">高精度加法</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a , b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">高精度减法</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A&gt;=B ?</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">sub</span>(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=A[i]-t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>())t=t-B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()!=<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b))&#123;</span><br><span class="line">        <span class="keyword">auto</span> C=<span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> C=<span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高精度运算" scheme="http://example.com/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Kullback-Leibler(KL)散度</title>
    <link href="http://example.com/2022/12/30/KL%E6%95%A3%E5%BA%A6/"/>
    <id>http://example.com/2022/12/30/KL%E6%95%A3%E5%BA%A6/</id>
    <published>2022-12-29T16:00:00.000Z</published>
    <updated>2023-02-23T11:11:35.070Z</updated>
    
    <content type="html"><![CDATA[<h1><font face='楷体'>1.概要</font></h1><h3><font face='楷体'>在这篇文章中，将探讨一种比较两个概率分布的方法，称为Kullback-Leibler散度(通常简称为KL散度)。通常在概率和统计中，我们会用更简单的近似分布来代替观察到的数据或复杂的分布。KL散度帮助我们衡量在选择近似值时损失了多少信息。</font></h3><h1><font face='楷体'>2.公式</font></h1><h3><font face='楷体'>KL散度起源于信息论。信息论的主要目标是量化数据中有多少信息。信息论中最重要的指标称为熵，通常表示为H。概率分布的熵的定义是：</font></h3>$$H=-\sum_{i=0}^nlogp(x_i)$$<h3><font face='楷体'>如果在我们的计算中我们使用log2，我们可以把熵解释为“我们编码信息所需要的最小比特数”。在这种情况下，根据我们的经验分布，信息将是每个牙齿计数的观察结果。根据我们观察到的数据，我们的概率分布的熵为3.12比特。比特的数目告诉我们，在单一情况下，我们平均需要多少比特来编码我们将观察到的牙齿数目。</font></h3><h3><font face='楷体'>熵没有告诉我们可以实现这种压缩的最佳编码方案。信息的最佳编码是一个非常有趣的主题，但对于理解KL散度而言不是必需的。熵的关键在于，只要知道所需位数的理论下限，我们就可以准确地量化数据中有多少信息。现在我们可以对此进行量化，当我们将观察到的分布替换为参数化的近似值时，我们丢失了多少信息。</font></h3><h1><font face='楷体'>使用KL散度测量丢失的信息</font></h1><h3><font face='楷体'>Kullback-Leibler散度只是对我们的熵公式的略微修改。不仅仅是有我们的概率分布p，还有上近似分布q。然后，我们查看每个log值的差异：</font></h3><script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{i=1}^Np(x_i)(log\frac{p(x_i)}{q(x_i)})</script><h3><font face='楷体'>本质上，我们用KL散度看的是对原始分布中的数据概率与近似分布之间的对数差的期望。再说一次，如果我们考虑log2，我们可以将其解释为“我们预计有多少比特位的信息丢失”。我们可以根据期望重写公式：</font></h3><script type="math/tex; mode=display">D_{KL}(p||q)=E[log\frac{p(x_i)}{q(x_i)}]</script><h3><font face='楷体'>利用KL散度，我们可以精确地计算出当我们近似一个分布与另一个分布时损失了多少信息。</font></h3><h1><font face='楷体'>3.注意:KL散度不是距离</font></h1><h3><font face='楷体'>将KL散度视为距离度量可能很诱人，但是我们不能使用KL散度来测量两个分布之间的距离。这是因为KL散度不是对称的。</font></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;font face=&#39;楷体&#39;&gt;1.概要&lt;/font&gt;&lt;/h1&gt;
&lt;h3&gt;&lt;font face=&#39;楷体&#39;&gt;在这篇文章中，将探讨一种比较两个概率分布的方法，称为Kullback-Leibler散度(通常简称为KL散度)。通常在概率和统计中，我们会用更简单的近似分布来代替观察</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RNN数学推导</title>
    <link href="http://example.com/2022/12/10/RNN%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
    <id>http://example.com/2022/12/10/RNN%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</id>
    <published>2022-12-10T13:20:30.000Z</published>
    <updated>2023-05-02T17:48:27.435Z</updated>
    
    <content type="html"><![CDATA[<p>循环神经网络（RNN）是一种特殊类型的神经网络，它在输入之间保持一种状态，并使用该状态来处理序列数据。下面是RNN的数学推导。</p><p>假设我们有一个输入序列$x = (x_1, x_2, …, x_T)$，其中每个$x_t$都是一个向量，$y$是输出序列，$h_t$是RNN在处理$x_t$时的隐藏状态。RNN的隐藏状态$h_t$通过以下递归方式计算：</p><script type="math/tex; mode=display">h_t = f(Ux_t + Wh_{t-1})</script><p>其中，$U$和$W$是权重矩阵，$f$是激活函数，通常是tanh或ReLU。$h_0$通常被初始化为全零向量。</p><p>在计算完所有隐藏状态后，我们可以通过一个输出层来预测输出序列$y$，该输出层可以是全连接层，也可以是softmax层，具体取决于任务的要求。例如，在情感分类任务中，我们可能只需要一个全连接层来预测情感标签。</p><p>输出层的计算方式如下：</p><script type="math/tex; mode=display">y_t = g(Vh_t)</script><p>其中，$V$是权重矩阵，$g$是激活函数。在分类任务中，$g$通常是softmax函数。</p><p>现在我们可以通过反向传播算法来训练RNN，其中损失函数$L$定义为预测输出$y$与实际输出$\hat{y}$之间的交叉熵：</p><script type="math/tex; mode=display">L = -\sum_{t=1}^{T}\hat{y}_t\log(y_t)</script><p>在反向传播过程中，我们需要计算损失函数对权重矩阵$U$、$W$和$V$的梯度。假设$\delta_t$表示损失函数对$h_t$的梯度，则：</p><script type="math/tex; mode=display">\delta_T = \frac{\partial L}{\partial y_T} \odot g'(Vh_T)</script><script type="math/tex; mode=display">\delta_t = \left(\frac{\partial L}{\partial y_t} + \frac{\partial L}{\partial h_{t+1}}\frac{\partial h_{t+1}}{\partial h_t}\right) \odot f'(Ux_t + Wh_{t-1})</script><p>其中，$\odot$表示向量点积，$g’$和$f’$分别是$g$和$f$的导数。我们可以使用这些梯度来更新权重矩阵，例如：</p><script type="math/tex; mode=display">V \leftarrow V - \eta\sum_{t=1}^{T}\delta_t h_t^T</script><script type="math/tex; mode=display">U \leftarrow U - \eta\sum_{t=1}^{T}\delta_t x_t^T</script><script type="math/tex; mode=display">W \leftarrow W - \eta\sum_{t=1}^{T}\delta_t h_{t-1}^T</script><p>其中，$\eta$是学习率。这些更新将使网络逐步调整权重，以最小化损失函数并提高预测精度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;循环神经网络（RNN）是一种特殊类型的神经网络，它在输入之间保持一种状态，并使用该状态来处理序列数据。下面是RNN的数学推导。&lt;/p&gt;
&lt;p&gt;假设我们有一个输入序列$x = (x_1, x_2, …, x_T)$，其中每个$x_t$都是一个向量，$y$是输出序列，$h_t$</summary>
      
    
    
    
    <category term="RNN  VS  Transformer" scheme="http://example.com/categories/RNN-VS-Transformer/"/>
    
    
    <category term="Paper" scheme="http://example.com/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>刷题</title>
    <link href="http://example.com/2022/12/10/%E5%88%B7%E9%A2%98/"/>
    <id>http://example.com/2022/12/10/%E5%88%B7%E9%A2%98/</id>
    <published>2022-12-10T10:27:53.000Z</published>
    <updated>2022-12-09T17:24:24.582Z</updated>
    
    <content type="html"><![CDATA[<p><img src="D:\text\BlogGit\image\1.jpg" alt=""></p><p><img src="D:\text\BlogGit\image\1.1.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace  std;</span><br><span class="line"><span class="built_in">int</span> <span class="type">List</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">int</span> w[<span class="number">1005</span>];//价值</span><br><span class="line"><span class="built_in">int</span> v[<span class="number">1005</span>];//体积</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    <span class="built_in">int</span> N,V;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    w[<span class="number">0</span>]=v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;V+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v[i]&gt;j)&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]=<span class="type">List</span>[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]=<span class="built_in">max</span>(<span class="type">List</span>[i-<span class="number">1</span>][j],<span class="type">List</span>[i-<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="type">List</span>[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\text\BlogGit\image\1.2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> N,V;</span><br><span class="line"><span class="built_in">int</span> v[<span class="number">1010</span>],val[<span class="number">1010</span>];</span><br><span class="line"><span class="built_in">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;=V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];//继承上一个背包</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">            &#123;  //完全背包状态转移方程</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-v[i]]+val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(<span class="string">&quot;%d&quot;</span>,dp[N][V]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\text\BlogGit\image\1.3.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace  std;</span><br><span class="line"><span class="built_in">int</span> <span class="type">List</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">int</span> w[<span class="number">1005</span>];//价值</span><br><span class="line"><span class="built_in">int</span> v[<span class="number">1005</span>];//体积</span><br><span class="line"><span class="built_in">int</span> s[<span class="number">1005</span>];//件数</span><br><span class="line"><span class="built_in">int</span> N,V;</span><br><span class="line"><span class="built_in">int</span> k;</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    w[<span class="number">0</span>]=v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v[i],&amp;w[i],&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(<span class="type">List</span>,<span class="number">0</span>,sizeof(<span class="type">List</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;V+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(s[i],j/v[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> t=<span class="number">0</span>;t&lt;=k;t++)&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]= <span class="built_in">max</span>(<span class="type">List</span>[i][j],<span class="type">List</span>[i-<span class="number">1</span>][j-t*v[i]]+t*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="type">List</span>[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;D:\text\BlogGit\image\1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;D:\text\BlogGit\image\1.1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight pytho</summary>
      
    
    
    
    <category term="算法刷题" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="背包问题" scheme="http://example.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（一）</title>
    <link href="http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-11-16T16:00:00.000Z</published>
    <updated>2023-03-27T07:06:27.049Z</updated>
    
    <content type="html"><![CDATA[<h3>    综述</h3><p> 链接：<a href="https://pan.baidu.com/s/10DHtZbPnH2SsuaPaZcIuLQ">https://pan.baidu.com/s/10DHtZbPnH2SsuaPaZcIuLQ</a><br>提取码：tf9p</p><p> 目前，大数据越来越多的和人工智能关联起来。而人工智能发展迅猛，在多个领域取得了巨大的成就，比如自然语言处理，图像处理，数据挖掘等。而本文正是诞生在如此环境下。首先本文基于Scrapy框架爬取豆瓣短评数据并进行清洗，然后通过hadoop+spark+mongodb完全分布式部署框架来进行数据的分类与采集，最终我们得到了比例为8:1:1的训练集、测试集和验证集。并在此基础上，我们调用了TextCNN、TextRCNN、TextRNN_Att、FastText、Transformer五大文本分类模型训练豆瓣Top250的短评，最后训练出五个可以通过短评来判断电影种类的模型，我们分别计算这五个模型的各个参数，最终选择一个较好的模型——TextRCNN模型来作为我们的后端模型。我们使用Fastapi来进行前后端分离的web应用。同时，我们在此基础上，为了能够让使用者能够仔细观察一个电影的具体情况，找到自己喜欢的电影，我们建立了基于余弦相似度的搜索模型，达到了模糊搜索的功能，并将其与前端相连，形成我们整个完整的项目。</p><h3>  研究背景</h3><p>目前，大数据越来越多的和人工智能关联起来。而人工智能发展迅猛，在多个领域取得了巨大的成就，比如自然语言处理，图像处理，数据挖掘等。文本挖掘是其中的一个研究方向。根据维基百科的定义，文本挖掘也叫文本数据挖掘，或是文本分析，是从文本中获取高质量信息的过程，典型的任务有文本分类、自动问答、情感分析、机器翻译等。文本分类是将数据分成预先定义好的类别，一般流程为：1. 预处理，比如分词，去掉停用词；2. 文本表示及特征选择；3. 分类器构造；4. 分类器根据文本的特征进行分类；5. 分类结果的评价。&lt;/br&gt;<br>由于近年来人工智能的快速发展，文本分类技术已经可以很好的确定一个未知文档的类别，而且准确度也很好。借助文本分类，可以方便进行海量信息处理，节约大量的信息处理费用。广泛应用于过滤信息，组织与管理信息，数字图书馆、垃圾邮件过滤等社会生活的各个领域。&lt;/br&gt;</p><p>同时，随着网络的发展，电影事业的发展越来越繁荣，其的种类也越来越繁多。目前电影主要可以分为动作、喜剧、犯罪、爱情、科幻、战争等多种类型。而不同类型的电影，读者关于它们的评论却大相径庭。在基于hadoop+spark完全分布式平台的本次项目，我们主要针对于犯罪、喜剧、科幻和战争四种类型差异较大的电影，采用爬虫爬取到的不同类型的电影的影评作为数据集，运用TextCNN、TextRCNN、TextRNN_Att、FastText、Transformer五种文本分类模型来进行训练，最后选取一个预测结果结果最好的模型加载作为我们的fastapi+webUI实现的后端。最后因为电影在大数据报中仅能展示部分，而不能展示其的具体介绍。因此我又打算通过基于余弦相似度的分类算法来做一个小型的搜索系统。&lt;/br&gt;<br>以上就是我项目的研究背景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;
    综述
&lt;/h3&gt;

&lt;p&gt; 链接：&lt;a href=&quot;https://pan.baidu.com/s/10DHtZbPnH2SsuaPaZcIuLQ&quot;&gt;https://pan.baidu.com/s/10DHtZbPnH2SsuaPaZcIuLQ&lt;/a&gt;&lt;br&gt;提</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="课程设计" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（二）:框架介绍</title>
    <link href="http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/"/>
    <id>http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/</id>
    <published>2022-11-16T16:00:00.000Z</published>
    <updated>2023-03-26T15:49:43.317Z</updated>
    
    <content type="html"><![CDATA[<h3>Scrapy框架</h3><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><p>所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专业的描述就是，抓取特定网站网页的HTML数据。抓取网页的一般方法是，定义一个入口页面，然后一般一个页面会有其他页面的URL，于是从当前页面获取到这些URL加入到爬虫的抓取队列中，然后进入到新页面后再递归的进行上述的操作，其实说来就跟深度遍历或广度遍历一样。</p><p>Scrapy 使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。</p><h3>Hadoop</h3><h4>背景</h4><p>Hadoop是一个由Apache基金会所开发的<a href="https://baike.baidu.com/item/分布式系统/4905336?fromModule=lemma_inlink">分布式系统</a>基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个<a href="https://baike.baidu.com/item/分布式文件系统/1250388?fromModule=lemma_inlink">分布式文件系统</a>（ Distributed File System），其中一个组件是<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>（Hadoop Distributed File System）。HDFS有高<a href="https://baike.baidu.com/item/容错性/9131391?fromModule=lemma_inlink">容错性</a>的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问<a href="https://baike.baidu.com/item/应用程序/5985445?fromModule=lemma_inlink">应用程序</a>的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）<a href="https://baike.baidu.com/item/POSIX/3792413?fromModule=lemma_inlink">POSIX</a>的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>和<a href="https://baike.baidu.com/item/MapReduce/133425?fromModule=lemma_inlink">MapReduce</a>。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。</p><h4>优点</h4><p>Hadoop是一个能够让用户轻松架构和使用的分布式计算平台。用户可以轻松地在Hadoop上开发和运行处理海量数据的应用程序。它主要有以下几个优点：&lt;/br&gt;<br>1.高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖&lt;/br&gt;。&lt;/br&gt;<br>2.高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。&lt;/br&gt;<br>3.高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。&lt;/br&gt;<br>4.高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。&lt;/br&gt;<br>5.低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。&lt;/br&gt;<br>Hadoop带有用Java语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如C++。</p><h3>Spark </h3><p>   Spark使用Scala语言进行实现，它是一种面向对象、函数式编程语言，能够像操作本地集合对象一样轻松地操作分布式数据集，具有以下特点。<br>1.运行速度快：Spark拥有DAG执行引擎，支持在内存中对数据进行迭代计算。官方提供的数据表明，如果数据由磁盘读取，速度是Hadoop MapReduce的10倍以上，如果数据从内存中读取，速度可以高达100多倍。<br>2.易用性好：Spark不仅支持Scala编写应用程序，而且支持Java和Python等语言进行编写，特别是Scala是一种高效、可拓展的语言，能够用简洁的代码处理较为复杂的处理工作。&lt;/br&gt;<br>3.通用性强：Spark生态圈即BDAS（伯克利数据分析栈）包含了Spark Core、Spark SQL、Spark Streaming、MLLib和GraphX等组件，这些组件分别处理Spark Core提供内存计算框架、SparkStreaming的实时处理应用、Spark SQL的即席查询、MLlib或MLbase的机器学习和GraphX的图处理。<br>4.随处运行：Spark具有很强的适应性，能够读取HDFS、Cassandra、HBase、S3和Techyon为持久层读写原生数据，能够以Mesos、YARN和自身携带的Standalone作为资源管理器调度job，来完成Spark应用程序的计算。</p><h3>Mongodb</h3><h2>背景介绍</h2><p>MongoDB是一个基于分布式文件存储的数据库。</p><p>由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><h2>业务场景</h2><p>传统的关系型数据库(如MySQL)，在数据操作的三高需求以及应对Web2.0的网站需求面前，显得力不从心，而 MongoDB可应对“三高“需求：</p><p>High performance：对数据库高并发读写的需求</p><p>Huge Storage：对海量数据的高效率存储和访问的需求</p><p>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</p><p>具体应用场景：</p><p>社交场景，使用 MongoDB存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。</p><p>游戏场景，使用 MongoDB存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、高效率存储和访问。</p><p>物流场景，使用 MongoDB存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</p><p>物联网场景，使用 MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。</p><p>视频直播，使用 MongoDB存储用户信息、点赞互动信息等。</p><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高</p><p>对于这样的数据，我们更适合使用 MongoDB来实现数据的存储。</p><h2>特点</h2><p>（1）高性能</p><p>MongoDB提供高性能的数据持久性。特别是，</p><p>对嵌入式数据模型的支持减少了数据库系统上I/O活动。</p><p>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种O2O应用）</p><p>mmapv1、 wiredtiger、 mongorocks（ rocks）、 In-memory等多引擎支持满足各种场景需求</p><p>Gridfs解决文件存储的需求</p><p>（2）高可用性</p><p>MongoDB的复制工具称为副本集（ replica set），它可提供自动故障转移和数据冗余</p><p>（3）高扩展性</p><p>MongoDB提供了水平可扩展性作为其核心功能的一部分。</p><p>分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p><p>（4）丰富的查询支持</p><p>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p><p>（5）其他特点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;
Scrapy框架
&lt;/h3&gt;

&lt;p&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。&lt;/p&gt;
&lt;p&gt;所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="课程设计" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（三）:模型介绍</title>
    <link href="http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/"/>
    <id>http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/</id>
    <published>2022-11-16T16:00:00.000Z</published>
    <updated>2023-03-26T16:17:19.272Z</updated>
    
    <content type="html"><![CDATA[<h3>Scrapy框架</h3><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><p>所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专业的描述就是，抓取特定网站网页的HTML数据。抓取网页的一般方法是，定义一个入口页面，然后一般一个页面会有其他页面的URL，于是从当前页面获取到这些URL加入到爬虫的抓取队列中，然后进入到新页面后再递归的进行上述的操作，其实说来就跟深度遍历或广度遍历一样。</p><p>Scrapy 使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。</p><h3>Hadoop</h3><h4>背景</h4><p>Hadoop是一个由Apache基金会所开发的<a href="https://baike.baidu.com/item/分布式系统/4905336?fromModule=lemma_inlink">分布式系统</a>基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个<a href="https://baike.baidu.com/item/分布式文件系统/1250388?fromModule=lemma_inlink">分布式文件系统</a>（ Distributed File System），其中一个组件是<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>（Hadoop Distributed File System）。HDFS有高<a href="https://baike.baidu.com/item/容错性/9131391?fromModule=lemma_inlink">容错性</a>的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问<a href="https://baike.baidu.com/item/应用程序/5985445?fromModule=lemma_inlink">应用程序</a>的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）<a href="https://baike.baidu.com/item/POSIX/3792413?fromModule=lemma_inlink">POSIX</a>的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>和<a href="https://baike.baidu.com/item/MapReduce/133425?fromModule=lemma_inlink">MapReduce</a>。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。</p><h4>优点</h4><p>Hadoop是一个能够让用户轻松架构和使用的分布式计算平台。用户可以轻松地在Hadoop上开发和运行处理海量数据的应用程序。它主要有以下几个优点：&lt;/br&gt;<br>1.高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖&lt;/br&gt;。&lt;/br&gt;<br>2.高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。&lt;/br&gt;<br>3.高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。&lt;/br&gt;<br>4.高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。&lt;/br&gt;<br>5.低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。&lt;/br&gt;<br>Hadoop带有用Java语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如C++。</p><h3>Spark </h3><p>   Spark使用Scala语言进行实现，它是一种面向对象、函数式编程语言，能够像操作本地集合对象一样轻松地操作分布式数据集，具有以下特点。<br>1.运行速度快：Spark拥有DAG执行引擎，支持在内存中对数据进行迭代计算。官方提供的数据表明，如果数据由磁盘读取，速度是Hadoop MapReduce的10倍以上，如果数据从内存中读取，速度可以高达100多倍。<br>2.易用性好：Spark不仅支持Scala编写应用程序，而且支持Java和Python等语言进行编写，特别是Scala是一种高效、可拓展的语言，能够用简洁的代码处理较为复杂的处理工作。&lt;/br&gt;<br>3.通用性强：Spark生态圈即BDAS（伯克利数据分析栈）包含了Spark Core、Spark SQL、Spark Streaming、MLLib和GraphX等组件，这些组件分别处理Spark Core提供内存计算框架、SparkStreaming的实时处理应用、Spark SQL的即席查询、MLlib或MLbase的机器学习和GraphX的图处理。<br>4.随处运行：Spark具有很强的适应性，能够读取HDFS、Cassandra、HBase、S3和Techyon为持久层读写原生数据，能够以Mesos、YARN和自身携带的Standalone作为资源管理器调度job，来完成Spark应用程序的计算。</p><h3>Mongodb</h3><h2>背景介绍</h2><p>MongoDB是一个基于分布式文件存储的数据库。</p><p>由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><h2>业务场景</h2><p>传统的关系型数据库(如MySQL)，在数据操作的三高需求以及应对Web2.0的网站需求面前，显得力不从心，而 MongoDB可应对“三高“需求：</p><p>High performance：对数据库高并发读写的需求</p><p>Huge Storage：对海量数据的高效率存储和访问的需求</p><p>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</p><p>具体应用场景：</p><p>社交场景，使用 MongoDB存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。</p><p>游戏场景，使用 MongoDB存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、高效率存储和访问。</p><p>物流场景，使用 MongoDB存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</p><p>物联网场景，使用 MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。</p><p>视频直播，使用 MongoDB存储用户信息、点赞互动信息等。</p><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高</p><p>对于这样的数据，我们更适合使用 MongoDB来实现数据的存储。</p><h2>特点</h2><p>（1）高性能</p><p>MongoDB提供高性能的数据持久性。特别是，</p><p>对嵌入式数据模型的支持减少了数据库系统上I/O活动。</p><p>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种O2O应用）</p><p>mmapv1、 wiredtiger、 mongorocks（ rocks）、 In-memory等多引擎支持满足各种场景需求</p><p>Gridfs解决文件存储的需求</p><p>（2）高可用性</p><p>MongoDB的复制工具称为副本集（ replica set），它可提供自动故障转移和数据冗余</p><p>（3）高扩展性</p><p>MongoDB提供了水平可扩展性作为其核心功能的一部分。</p><p>分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p><p>（4）丰富的查询支持</p><p>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p><p>（5）其他特点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;
Scrapy框架
&lt;/h3&gt;

&lt;p&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。&lt;/p&gt;
&lt;p&gt;所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="课程设计" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（四）:了解NLP的卷积神经网络</title>
    <link href="http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A13/"/>
    <id>http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A13/</id>
    <published>2022-11-16T16:00:00.000Z</published>
    <updated>2023-03-27T06:46:23.948Z</updated>
    
    <content type="html"><![CDATA[<h3>了解NLP的卷积神经网络</h3><p>当我们听到卷积神经网络（CNN）时，我们通常会想到计算机视觉。CNN负责图像分类的重大突破，并且是当今大多数计算机视觉系统的核心，从Facebook的自动照片标记到自动驾驶汽车。</p><p>最近，我们也开始将CNN应用于自然语言处理中的问题，并得到了一些有趣的结果。在这篇文章中，我将尝试总结CNN是什么，以及它们如何在NLP中使用。对于计算机视觉用例来说，CNN背后的直觉更容易理解，所以我将从那里开始，然后慢慢转向NLP。</p><h4>什么是卷积？</h4><p>对我来说，理解<em>卷积</em>的最简单方法是将其视为应用于矩阵的滑动窗口函数。这很拗口，但看可视化就很清楚了：</p><p><img src="https://dennybritz.com/img/Convolution_schematic.gif" alt=""></p><p>带 3×3 滤波器的卷积，来源：<a href="http://deeplearning.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/">http://deeplearning.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/</a></p><p>想象一下，左边的矩阵表示一个黑白图像。每个条目对应一个像素，0 表示黑色，1 表示白色（灰度图像通常在 0 到 255 之间）。滑动窗口称为内核、过滤器<em>或</em>特征检测器。在这里，我们使用 3×3 过滤器，将其值逐个乘以原始矩阵，然后将它们相加。为了获得完整的卷积，我们通过在整个矩阵上滑动过滤器来为每个元素执行此操作。</p><p>您可能想知道您实际上可以用它做什么。以下是一些直观的例子。</p><h4 id="将每个像素与其相邻值求平均值会使图像模糊："><a href="#将每个像素与其相邻值求平均值会使图像模糊：" class="headerlink" title="将每个像素与其相邻值求平均值会使图像模糊："></a>将每个像素与其相邻值求平均值会使图像模糊：</h4><p><img src="https://docs.gimp.org/en/images/filters/examples/convolution-blur.png" alt=""></p><p><img src="https://docs.gimp.org/en/images/filters/examples/generic-taj-convmatrix-blur.jpg" alt=""></p><h4 id="取像素与其相邻像素之间的差异可检测边缘："><a href="#取像素与其相邻像素之间的差异可检测边缘：" class="headerlink" title="取像素与其相邻像素之间的差异可检测边缘："></a>取像素与其相邻像素之间的差异可检测边缘：</h4><p>（要直观地理解这一点，请考虑图像中平滑的部分会发生什么，其中像素颜色等于其相邻颜色的颜色：添加取消，结果值为 0 或黑色。如果强度有锋利的边缘，例如从白色到黑色的过渡，你会得到很大的差异和由此产生的白色值）</p><p><img src="https://docs.gimp.org/en/images/filters/examples/convolution-edge-detect1.png" alt=""></p><p><img src="https://docs.gimp.org/en/images/filters/examples/generic-taj-convmatrix-edge-detect.jpg" alt=""></p><h3 id="什么是卷积神经网络？"><a href="#什么是卷积神经网络？" class="headerlink" title="什么是卷积神经网络？#"></a>什么是卷积神经网络？<a href="https://dennybritz.com/posts/wildml/understanding-convolutional-neural-networks-for-nlp/#what-areconvolutional-neural-networks">#</a></h3><p>现在你知道什么是卷积了。但是CNN呢？CNN本质上是几层卷积，其中非线性<em>激活函数</em>（如<a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks">ReLU</a>)或<a href="https://reference.wolfram.com/language/ref/Tanh.html">tanh</a>）应用于结果。在传统的前馈神经网络中，我们将每个输入神经元连接到下一层的每个输出神经元。这也称为全连接层或仿射层。在CNN中，我们改为在输入层上使用卷积来计算输出。这会导致本地连接，其中输入的每个区域都连接到输出中的一个神经元。每个图层应用不同的过滤器，通常为数百或数千个，如上所示，并组合其结果。还有一些东西叫做池化（子采样）层，但我稍后会谈到这一点。在训练阶段，<strong>CNN</strong> 会根据您要执行的任务自动<strong>学习其过滤器的值</strong>。例如，图像分类 CNN 可以学习从第一层中的原始像素检测边缘，然后使用边缘检测第二层中的简单形状，然后使用这些形状来阻止更高级别的特征，例如较高层中的面部形状。最后一层是使用这些高级功能的分类器。</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-07-at-7.26.20-AM.png" alt=""></p><p>这种计算有两个方面值得关注：<strong>位置不变性和**</strong>组合性<em>*。假设您要对图像中是否存在大象进行分类。因为你在整个图像上滑动滤镜，所以你并不真正关心大象出现</em>在哪里<em>。在实践中，</em>池化<em>还可以为您提供平移、旋转和缩放的不变性，但稍后会详细介绍。第二个关键方面是（局部）组成性。每个过滤器</em>将*较低级别要素的局部修补程序组成为更高级别表示形式。这就是为什么CNN在计算机视觉中如此强大的原因。从像素构建边缘、从边缘构建形状以及从形状构建更复杂的对象，这很直观。</p><h4 id="那么，这些如何适用于NLP？"><a href="#那么，这些如何适用于NLP？" class="headerlink" title="那么，这些如何适用于NLP？"></a>那么，这些如何适用于NLP？</h4><p>大多数NLP任务的输入不是图像像素，而是表示为矩阵的句子或文档。矩阵的每一行对应于一个标记，通常是一个单词，但它可以是字符。也就是说，每一行都是表示一个单词的向量。通常，这些向量是<em>词嵌入</em>（低维表示），如<a href="https://code.google.com/p/word2vec/">word2vec</a>或<a href="http://nlp.stanford.edu/projects/glove/">GloVe</a>，但它们也可能是将单词索引为词汇表的单热向量。对于使用 10 维嵌入的 100 个单词的句子，我们将有一个 10×100 矩阵作为我们的输入。这就是我们的“形象”。</p><p>在视觉中，我们的过滤器在图像的局部斑块上滑动，但在NLP中，我们通常使用在矩阵（单词）的整行上滑动的过滤器。因此，过滤器的“宽度”通常与输入矩阵的宽度相同。高度或<em>区域大小</em>可能会有所不同，但一次超过 2-5 个单词的滑动窗口是典型的。综上所述，NLP 的卷积神经网络可能如下所示（花几分钟时间尝试理解这张图片以及如何计算维度。您现在可以忽略池化，稍后我们将解释）：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-12.05.40-PM.png" alt=""></p><p>用于句子分类的卷积神经网络 （CNN） 架构图示。在这里，我们描述了三个过滤器区域大小：2、3 和 4，每个都有 2 个过滤器。每个过滤器对句子矩阵执行卷积并生成（可变长度）特征图。然后对每个图执行 1-max 池化，即记录每个特征图中的最大数量。因此，从所有六个映射生成一个单变量特征向量，并将这 6 个特征连接起来形成倒数第二层的特征向量。然后，最终的softmax层接收此特征向量作为输入，并使用它来对句子进行分类;这里我们假设二元分类，因此描述了两种可能的输出状态。资料来源：hang， Y.， &amp; Wallace， B. （2015）.用于句子分类的卷积神经网络的敏感性分析.</p><p>我们对计算机视觉的直觉呢？位置不变性和局部组合性对于图像来说很直观，但对于NLP来说就不那么重要了。你可能非常关心句子中出现单词的位置。彼此接近的像素可能在语义上相关（同一对象的一部分），但对于单词并不总是如此。在许多语言中，短语的某些部分可以用其他几个单词分隔。构图方面也不明显。显然，单词以某些方式组成，例如修饰名词的形容词，但这究竟是如何工作的，更高层次的表示实际上“意味着”并不像计算机视觉案例那样明显。</p><p>考虑到这一切，CNN似乎不适合NLP任务。<a href="https://dennybritz.com/posts/wildml/recurrent-neural-networks-tutorial-part-1/">递归神经网络</a>更直观。它们类似于我们处理语言的方式，或者至少是我们认为我们处理语言的方式：从左到右依次阅读。幸运的是，这并不意味着CNN不起作用。<a href="https://en.wikipedia.org/wiki/All_models_are_wrong">所有模型都是错误的，但有些模型是有用的</a>。事实证明，应用于NLP问题的CNN表现得非常好。简单的<a href="https://en.wikipedia.org/wiki/Bag-of-words_model">Bag of Words模型</a>显然过于简单，假设不正确，但多年来一直是标准方法，并产生了相当好的结果。</p><p>CNN的一个重要论点是它们速度很快。非常快。卷积是计算机图形学的核心部分，在 GPU 上的硬件级别实现。与<a href="https://en.wikipedia.org/wiki/N-gram">n-grams</a>相比，CNN在表示方面也很<em>有效</em>。对于大量词汇，计算超过 3 克的任何东西很快就会变得昂贵。甚至谷歌也没有提供超过5克的任何东西。卷积过滤器会自动学习良好的表示，而无需表示整个词汇表。使用大于 5 的过滤器是完全合理的。我喜欢认为第一层中的许多学习过滤器捕获的特征与 n 元语法非常相似（但不限于），但以更紧凑的方式表示它们。</p><h3 id="CNN-Hyperparameters"><a href="#CNN-Hyperparameters" class="headerlink" title="CNN Hyperparameters"></a>CNN Hyperparameters</h3><p>在解释如何将CNN应用于NLP任务之前，让我们看一下构建CNN时需要做出的一些选择。希望这将帮助您更好地了解该领域的文献。</p><h4 id="Narrow-vs-Wide-convolution"><a href="#Narrow-vs-Wide-convolution" class="headerlink" title="Narrow vs. Wide convolution"></a>Narrow vs. Wide convolution</h4><p>当我在上面解释卷积时，我忽略了我们如何应用过滤器的一些细节。在矩阵中心应用 3×3 滤波器工作正常，但边缘呢？如何将过滤器应用于顶部和左侧没有任何相邻元素的矩阵的第一个元素？您可以使用<em>零填充</em>。所有落在矩阵之外的元素都被视为零。通过执行此操作，您可以将过滤器应用于输入矩阵的每个元素，并获得更大或相同大小的输出。添加零填充也称为宽卷积<strong>，</strong>不使用零填充将是<em>窄卷积</em>。1D 中的示例如下所示：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-9.47.41-AM.png" alt=""></p><p>窄卷积与宽卷积。滤波器尺寸 5，输入尺寸 7。来源：用于句子建模的卷积神经网络（2014）</p><p>您可以看到，当您有一个相对于输入大小较大的过滤器时，卷积有多宽是有用的，甚至是必要的。在上面，窄卷积产生大小的输出(7−5)+1=3(7−5)+1=3，以及大小的宽卷积输出(7+2∗4−5)+1=11(7+2∗4−5)+1=11. 更一般地说，输出大小的公式为</p><script type="math/tex; mode=display">n_out=(n_{in}+2*n_padding-n_{filter})+1</script><h4 id="Stride-Size"><a href="#Stride-Size" class="headerlink" title="Stride Size"></a>Stride Size</h4><p>卷积的另一个超参数是<em>步幅大小</em>，它通过您希望在每一步移动过滤器的程度来定义。在上述所有示例中，步幅均为 1，并且过滤器的连续应用重叠。步幅越大，滤波器的应用越少，输出尺寸越小。<a href="http://cs231n.github.io/convolutional-networks/">Stanford cs231 website</a>以下内容显示了应用于一维输入的步幅大小 1 和 2：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-10.18.08-AM.png" alt=""></p><p>卷积步幅大小。左：步幅大小 1。右：步幅大小 2。来源： <a href="http://cs231n.github.io/convolutional-networks/">http://cs231n.github.io/convolutional-networks/</a></p><p>在文献中，我们通常看到步幅大小为 1，但更大的步幅大小可能允许您构建一个行为类似于<a href="https://en.wikipedia.org/wiki/Recursive_neural_network">递归神经网络</a>的模型，即看起来像一棵树。</p><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>卷积神经网络的一个关键方面是<em>池化层，</em>通常在卷积层之后应用。池化层对其输入进行子采样。最常见的方法是将其池化以应用�一个�<em>马·</em>对每个筛选器的结果进行操作。您不一定需要在完整矩阵上池化，也可以在窗口上池化。例如，下面显示了 2×2 窗口的最大池化。在 NLP 中，我们通常对整个输出应用池化，每个滤波器只产生一个数字：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-2.18.38-PM.png" alt=""></p><p>CNN 中的最大池化。来源： <a href="http://cs231n.github.io/convolutional-networks/#pool">http://cs231n.github.io/convolutional-networks/#pool</a></p><p>为什么要池化？有几个原因。池化的一个属性是它提供固定大小的输出矩阵，这通常是分类所必需的。例如，如果您有 1，000 个筛选器，并且对每个筛选器应用最大池化，则无论筛选器的大小或输入的大小如何，都将获得 1000 维输出。这允许您使用可变大小的句子和可变大小的过滤器，但始终获得相同的输出维度以馈送到分类器中。</p><p>池化也会降低输出维度，但（希望）保留最突出的信息。您可以将每个过滤器视为检测特定特征，例如检测句子是否包含否定词，例如“不惊人”。如果此短语出现在句子中的某处，则对该区域应用筛选器的结果将产生较大的值，但在其他区域中将产生较小的值。通过执行 max 运算，您可以保留有关特征是否出现在句子中的信息，但您将丢失有关其确切显示位置的信息。但是，这些关于地点的信息真的没有用吗？是的，它是，它有点类似于一袋n-gram模型正在做的事情。您正在丢失有关局部性的全局信息（句子中发生某些事情的位置），但您保留了过滤器捕获的本地信息，例如“不惊人”与“惊人不惊人”非常不同。</p><p>在想象识别中，池化还为平移（移位）和旋转提供了基本的不变性。在某个区域上进行池化时，即使将图像移动或旋转几个像素，输出也将大致保持不变，因为无论如何，最大操作都会选择相同的值。</p><h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>我们需要了解的最后一个概念是<em>渠道</em>。通道是输入数据的不同“视图”。例如，在图像识别中，您通常具有RGB（红色，绿色，蓝色）通道。您可以跨通道应用卷积，权重不同或相等。在NLP中，你也可以想象有各种各样的通道：你可以为不同的单词嵌入（例如<a href="https://code.google.com/p/word2vec/">word2vec</a>和<a href="http://nlp.stanford.edu/projects/glove/">GloVe</a>）提供一个单独的通道，或者你可以有一个通道来表示用不同的语言表示的同一个句子，或者用不同的方式表达。</p><h3 id="卷积神经网络应用于NLP"><a href="#卷积神经网络应用于NLP" class="headerlink" title="卷积神经网络应用于NLP"></a>卷积神经网络应用于NLP</h3><p>现在让我们看看CNN在自然语言处理中的一些应用。我会尝试总结一些研究结果。我总是会错过许多有趣的应用程序，但我希望至少涵盖一些更受欢迎的结果。</p><p>最适合CNN似乎是分类任务，例如情绪分析，垃圾邮件检测或主题分类。卷积和池化操作会丢失有关单词本地顺序的信息，因此 PoS 标记或实体提取中的序列标记更难适应纯 CNN 架构（尽管并非不可能，您可以向输入添加位置特征）。</p><p>[1] 在各种分类数据集上评估 CNN 架构，主要由情感分析和主题分类任务组成。CNN架构在数据集上实现了非常好的性能，并在少数数据集上实现了最先进的性能。令人惊讶的是，本文中使用的网络非常简单，这就是它强大的原因。输入层是由连接的 <a href="https://code.google.com/p/word2vec/">word2vec</a> 词嵌入组成的句子。接下来是具有多个过滤器的卷积层，然后是最大池化层，最后是softmax分类器。该论文还以静态和动态词嵌入的形式尝试了两种不同的通道，其中一个通道在训练期间进行调整，另一个则不调整。之前在 [2] 中提出了类似但稍微复杂的架构。[6] 在此网络架构中添加了一个执行“语义聚类”的附加层。</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-8.03.47-AM.png" alt=""></p><p>[4] 从头开始训练 CNN，无需像 word2vec 或 GloVe 这样的预先训练的词向量。它将卷积直接应用于独热向量。作者还为输入数据提出了一种节省空间的词袋状表示，减少了网络需要学习的参数数量。在[5]中，作者用额外的无监督“区域嵌入”扩展了模型，该嵌入是使用CNN预测文本区域上下文来学习的。这些论文中的方法似乎适用于长篇文本（如电影评论），但它们在短文本（如推文）上的表现尚不清楚。直观地说，对短文本使用预先训练的单词嵌入比对长文本使用它们会产生更大的收益是有道理的。</p><p>构建CNN架构意味着有许多超参数可供选择，其中一些我在上面介绍过：输入响应（word2vec，GloVe，one-hot），卷积过滤器的数量和大小，池化策略（最大值，平均值）和激活函数（ReLU，tanh）。[7] 对 CNN 架构中不同超参数的影响进行了实证评估，调查了它们对多次运行的性能和方差的影响。如果您希望实现自己的CNN进行文本分类，那么使用本文的结果作为起点将是一个好主意。一些突出的结果是，最大池化总是胜过平均池化，理想的过滤器大小很重要但取决于任务，并且正则化似乎在所考虑的NLP任务中没有太大的不同。这项研究的一个警告是，所有数据集在文档长度方面都非常相似，因此相同的准则可能不适用于看起来有很大差异的数据。</p><p>[8] 探索用于关系提取和关系分类任务的 CNN。除了词向量之外，作者还使用词与感兴趣实体的相对位置作为卷积层的输入。此模型假定给定实体的位置，并且每个示例输入都包含一个关系。[9]和[10]探索了类似的模型。</p><p>CNN在NLP中的另一个有趣的用例可以在[11]和[12]中找到，来自Microsoft Research。这些论文描述了如何学习可用于信息检索的句子的语义有意义的表示。论文中给出的示例包括根据用户当前正在阅读的内容向用户推荐可能感兴趣的文档。句子表示基于搜索引擎日志数据进行训练。</p><p>大多数CNN架构以一种或另一种方式学习单词和句子的嵌入（低维表示），作为其训练过程的一部分。并非所有论文都关注训练的这一方面或研究学习嵌入的意义。[13]提出了一个CNN架构来预测Facebook帖子的主题标签，同时为单词和句子生成有意义的嵌入。然后，这些学习的嵌入成功地应用于另一项任务 - 向用户推荐可能感兴趣的文档，并根据点击流数据进行训练。</p><h4 id="Character-Level-CNNs"><a href="#Character-Level-CNNs" class="headerlink" title="Character-Level CNNs"></a>Character-Level CNNs</h4><p>到目前为止，所有提出的模型都是基于文字的。但也有人研究将CNN直接应用于角色。[14] 学习字符级嵌入，将它们与预先训练的词嵌入连接起来，并使用 CNN 进行词性标记。[15][16] 探索了使用 CNN 直接从角色中学习，而无需任何预先训练的嵌入。值得注意的是，作者使用了一个相对深度的网络，共有9层，并将其应用于情感分析和文本分类任务。结果表明，直接从字符级输入中学习在大型数据集（数百万个示例）上效果非常好，但在较小的数据集（数十万个示例）上表现不佳。[17] 探索了字符级卷积在语言建模中的应用，在每个时间步使用字符级 CNN 的输出作为 LSTM 的输入。相同的模型应用于各种语言。</p><p>令人惊讶的是，基本上上述所有论文都是在过去1-2年内发表的。显然，CNN之前在NLP方面已经有过出色的工作，就像从<a href="http://arxiv.org/abs/1103.0398">Scratch开始的自然语言处理（几乎）</a>一样，但是新结果和最新系统发布的步伐显然正在加快</p><p>參考链接：</p><p><a href="https://dennybritz.com/posts/wildml/understanding-convolutional-neural-networks-for-nlp/">Understanding Convolutional Neural Networks for NLP · Denny’s Blog (dennybritz.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;
了解NLP的卷积神经网络
&lt;/h3&gt;

&lt;p&gt;当我们听到卷积神经网络（CNN）时，我们通常会想到计算机视觉。CNN负责图像分类的重大突破，并且是当今大多数计算机视觉系统的核心，从Facebook的自动照片标记到自动驾驶汽车。&lt;/p&gt;
&lt;p&gt;最近，我们也开始将CNN应用于</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="课程设计" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（五）:Transformer模型</title>
    <link href="http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A14/"/>
    <id>http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A14/</id>
    <published>2022-11-16T16:00:00.000Z</published>
    <updated>2023-03-27T06:55:26.152Z</updated>
    
    <content type="html"><![CDATA[<p>Transformer是一个利用注意力机制来提高模型训练速度的模型。关于注意力机制可以参看<a href="https://zhuanlan.zhihu.com/p/52119092">这篇文章</a>，trasnformer可以说是完全基于自注意力机制的一个深度学习模型，因为它适用于并行化计算，和它本身模型的复杂程度导致它在精度和性能上都要高于之前流行的RNN循环神经网络。</p><p>那什么是transformer呢？</p><p>你可以简单理解为它是一个黑盒子，当我们在做文本翻译任务是，我输入进去一个中文，经过这个黑盒子之后，输出来翻译过后的英文。</p><p><img src="https://pic4.zhimg.com/80/v2-1a4f5b236563d6307acb58cc5a95b2b7_720w.webp" alt=""></p><p>那么在这个黑盒子里面都有什么呢？</p><p>里面主要有两部分组成：Encoder 和 Decoder</p><p><img src="https://pic2.zhimg.com/80/v2-8bf3b3ac8836ef1a9f16e1669fb29511_720w.webp" alt=""></p><p>当我输入一个文本的时候，该文本数据会先经过一个叫Encoders的模块，对该文本进行编码，然后将编码后的数据再传入一个叫Decoders的模块进行解码，解码后就得到了翻译后的文本，对应的我们称Encoders为编码器，Decoders为解码器。</p><p>那么编码器和解码器里边又都是些什么呢？</p><p>细心的同学可能已经发现了，上图中的Decoders后边加了个s，那就代表有多个编码器了呗，没错，这个编码模块里边，有很多小的编码器，一般情况下，Encoders里边有6个小编码器，同样的，Decoders里边有6个小解码器。</p><p><img src="https://pic4.zhimg.com/80/v2-739d9498e0a36296240741be909d35f7_720w.webp" alt=""></p><p>我们看到，在编码部分，每一个的小编码器的输入是前一个小编码器的输出，而每一个小解码器的输入不光是它的前一个解码器的输出，还包括了整个编码部分的输出。</p><p>那么你可能又该问了，那每一个小编码器里边又是什么呢？</p><p>我们放大一个encoder，发现里边的结构是一个自注意力机制加上一个前馈神经网络。</p><p><img src="https://pic1.zhimg.com/80/v2-8c63aaf7e71b94fdb5d6df89abdaf118_720w.webp" alt=""></p><p>我们先来看下self-attention是什么样子的。</p><p>我们通过几个步骤来解释：</p><p>1、首先，self-attention的输入就是词向量，即整个模型的最初的输入是词向量的形式。那自注意力机制呢，顾名思义就是自己和自己计算一遍注意力，即对每一个输入的词向量，我们需要构建self-attention的输入。在这里，transformer首先将词向量乘上三个矩阵，得到三个新的向量，之所以乘上三个矩阵参数而不是直接用原本的词向量是因为这样增加更多的参数，提高模型效果。对于输入X1(机器)，乘上三个矩阵后分别得到Q1,K1,V1，同样的，对于输入X2(学习)，也乘上三个不同的矩阵得到Q2,K2,V2。</p><p><img src="https://pic3.zhimg.com/80/v2-15142b393f03a309c926754f00307d46_720w.webp" alt=""></p><p>2、那接下来就要计算注意力得分了，这个得分是通过计算Q与各个单词的K向量的点积得到的。我们以X1为例，分别将Q1和K1、K2进行点积运算，假设分别得到得分112和96。</p><p><img src="https://pic2.zhimg.com/80/v2-42ccd93ac7540619b02ef03faef21c15_720w.webp" alt=""></p><p>3、将得分分别除以一个特定数值8（K向量的维度的平方根，通常K向量的维度是64）这能让梯度更加稳定，则得到结果如下：</p><p><img src="https://pic3.zhimg.com/80/v2-8a98e66c20fb25e96e1f690309ae6166_720w.webp" alt=""></p><p>4、将上述结果进行softmax运算得到，softmax主要将分数标准化，使他们都是正数并且加起来等于1。</p><p><img src="https://pic3.zhimg.com/80/v2-1701b674a3e09ae91301d6cd9727f912_720w.webp" alt=""></p><p>5、将V向量乘上softmax的结果，这个思想主要是为了保持我们想要关注的单词的值不变，而掩盖掉那些不相关的单词（例如将他们乘上很小的数字）</p><p><img src="https://pic2.zhimg.com/80/v2-c18a30a6b8738af5cd1b5c0e2080e695_720w.webp" alt=""></p><p>6、将带权重的各个V向量加起来，至此，产生在这个位置上（第一个单词）的self-attention层的输出，其余位置的self-attention输出也是同样的计算方式。</p><p><img src="https://pic3.zhimg.com/80/v2-3577071e71ccfa49a4f60f4a5187f0ce_720w.webp" alt=""><br> 将上述的过程总结为一个公式就可以用下图表示：</p><p><img src="https://pic4.zhimg.com/80/v2-0190eb46d1c46efc04926821e69fd377_720w.webp" alt=""></p><p>self-attention层到这里就结束了吗？</p><p>还没有，论文为了进一步细化自注意力机制层，增加了“多头注意力机制”的概念，这从两个方面提高了自注意力层的性能。</p><p>第一个方面，他扩展了模型关注不同位置的能力，这对翻译一下句子特别有用，因为我们想知道“it”是指代的哪个单词。</p><p><img src="https://pic1.zhimg.com/80/v2-dc386abf38141384c43918689b0bbb64_720w.webp" alt=""></p><p>第二个方面，他给了自注意力层多个“表示子空间”。对于多头自注意力机制，我们不止有一组Q/K/V权重矩阵，而是有多组（论文中使用8组），所以每个编码器/解码器使用8个“头”（可以理解为8个互不干扰自的注意力机制运算），每一组的Q/K/V都不相同。然后，得到8个不同的权重矩阵Z，每个权重矩阵被用来将输入向量投射到不同的表示子空间。</p><p>经过多头注意力机制后，就会得到多个权重矩阵Z，我们将多个Z进行拼接就得到了self-attention层的输出：</p><p><img src="https://pic2.zhimg.com/80/v2-1be30f537678c89b2768ed31ff5bb491_720w.webp" alt=""></p><p>上述我们经过了self-attention层，我们得到了self-attention的输出，self-attention的输出即是前馈神经网络层的输入，然后前馈神经网络的输入只需要一个矩阵就可以了，不需要八个矩阵，所以我们需要把这8个矩阵压缩成一个，我们怎么做呢？只需要把这些矩阵拼接起来然后用一个额外的权重矩阵与之相乘即可。</p><p><img src="https://pic4.zhimg.com/80/v2-7394f6eb418b403588b0ca5a6751749f_720w.webp" alt=""></p><p>最终的Z就作为前馈神经网络的输入。</p><p>接下来就进入了小编码器里边的前馈神经网模块了，关于前馈神经网络，网上已经有很多资料，在这里就不做过多讲解了，只需要知道，前馈神经网络的输入是self-attention的输出，即上图的Z,是一个矩阵，矩阵的维度是（序列长度×D词向量），之后前馈神经网络的输出也是同样的维度。</p><p>以上就是一个小编码器的内部构造了，一个大的编码部分就是将这个过程重复了6次，最终得到整个编码部分的输出。</p><p>然后再transformer中使用了6个encoder，为了解决梯度消失的问题，在Encoders和Decoder中都是用了残差神经网络的结构，即每一个前馈神经网络的输入不光包含上述self-attention的输出Z，还包含最原始的输入。</p><p>上述说到的encoder是对输入（机器学习）进行编码，使用的是自注意力机制+前馈神经网络的结构，同样的，在decoder中使用的也是同样的结构。也是首先对输出（machine learning）计算自注意力得分，不同的地方在于，进行过自注意力机制后，将self-attention的输出再与Decoders模块的输出计算一遍注意力机制得分，之后，再进入前馈神经网络模块。</p><p><img src="https://pic4.zhimg.com/v2-5e32534b9a651289cb3eb2b409d5996b_r.jpg" alt=""></p><p>以上，就讲完了Transformer编码和解码两大模块，那么我们回归最初的问题，将“机器学习”翻译成“machine learing”，解码器输出本来是一个浮点型的向量，怎么转化成“machine learing”这两个词呢？</p><p>是个工作是最后的线性层接上一个softmax，其中线性层是一个简单的全连接神经网络，它将解码器产生的向量投影到一个更高维度的向量（logits）上，假设我们模型的词汇表是10000个词，那么logits就有10000个维度，每个维度对应一个惟一的词的得分。之后的softmax层将这些分数转换为概率。选择概率最大的维度，并对应地生成与之关联的单词作为此时间步的输出就是最终的输出啦！！</p><p>假设词汇表维度是6，那么输出最大概率词汇的过程如下：</p><p><img src="https://pic4.zhimg.com/80/v2-6d0a0d38ab824914942121d1ae78cd0b_720w.webp" alt=""></p><p>以上就是Transformer的框架了，但是还有最后一个问题，我们都是到RNN中的每个输入是时序的，是又先后顺序的，但是Transformer整个框架下来并没有考虑顺序信息，这就需要提到另一个概念了：“位置编码”。</p><p>Transformer中确实没有考虑顺序信息，那怎么办呢，我们可以在输入中做手脚，把输入变得有位置信息不就行了，那怎么把词向量输入变成携带位置信息的输入呢？</p><p>我们可以给每个词向量加上一个有顺序特征的向量，发现sin和cos函数能够很好的表达这种特征，所以通常位置向量用以下公式来表示：</p><p><img src="https://pic1.zhimg.com/80/v2-a671b951ef42d09c349db12c35175998_720w.webp" alt=""></p><p><img src="https://pic1.zhimg.com/80/v2-c17ebc4594bd0c0d01fab289abde5ec4_720w.webp" alt=""></p><p>最后祭出这张经典的图，最初看这张图的时候可能难以理解，希望大家在深入理解Transformer后再看这张图能够有更深刻的认识。</p><p><img src="https://pic1.zhimg.com/80/v2-1d9129c9c0d5367591bd093f79155e40_720w.webp" alt=""></p><p><img src="https://pic4.zhimg.com/v2-8fbde14eac35db43cfe1734d4714a7db_r.jpg" alt=""></p><p>參考文獻：<a href="https://zhuanlan.zhihu.com/p/82312421">十分钟理解Transformer - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Transformer是一个利用注意力机制来提高模型训练速度的模型。关于注意力机制可以参看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/52119092&quot;&gt;这篇文章&lt;/a&gt;，trasnformer可以说是完全基于自注意力机制的一个深度学习模型，</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="课程设计" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（五）:基于余弦相似的搜索算法</title>
    <link href="http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A15/"/>
    <id>http://example.com/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A15/</id>
    <published>2022-11-16T16:00:00.000Z</published>
    <updated>2023-03-27T07:03:02.761Z</updated>
    
    <content type="html"><![CDATA[<h3>基于余弦相似的搜索算法</h3><p>给一个例子：</p><p><a href="https://postimg.cc/p9WSKJRj"><img src="https://i.postimg.cc/1zwZhvdv/VRUP-2-IEP-G-5-L-2-C-VMO.png" alt="VRUP-2-IEP-G-5-L-2-C-VMO.png"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;
基于余弦相似的搜索算法
&lt;/h3&gt;

&lt;p&gt;给一个例子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://postimg.cc/p9WSKJRj&quot;&gt;&lt;img src=&quot;https://i.postimg.cc/1zwZhvdv/VRUP-2-IEP-G-5-L-2-C-</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="课程设计" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建一个神经元</title>
    <link href="http://example.com/2022/11/15/CNN%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%AD%A6%E4%B9%A01/"/>
    <id>http://example.com/2022/11/15/CNN%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%AD%A6%E4%B9%A01/</id>
    <published>2022-11-14T16:00:00.000Z</published>
    <updated>2022-11-25T03:44:41.884Z</updated>
    
    <content type="html"><![CDATA[<h3><font face='楷体'>实现方法</font></h3><h5><font face='楷体'>神经元（Neurons）:它是神经网络的基本单元。神经元先获得输入，然后执行某些数学运算后，再产生一个输出。比如一个2输入神经元的例子：</font></h5><p><img src="https://picx.zhimg.com/80/v2-5550feac69724dcbc145574525ae42f6_720w.webp?source=1940ef5c" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;font face=&#39;楷体&#39;&gt;实现方法&lt;/font&gt;&lt;/h3&gt;

&lt;h5&gt;&lt;font face=&#39;楷体&#39;&gt;神经元（Neurons）:它是神经网络的基本单元。神经元先获得输入，然后执行某些数学运算后，再产生一个输出。比如一个2输入神经元的例子：&lt;/font&gt;&lt;/h5&gt;

</summary>
      
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CNN" scheme="http://example.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>实验二：词频统计与可视化</title>
    <link href="http://example.com/2022/10/31/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA3/"/>
    <id>http://example.com/2022/10/31/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA3/</id>
    <published>2022-10-31T13:39:53.000Z</published>
    <updated>2022-10-30T17:44:18.363Z</updated>
    
    <content type="html"><![CDATA[<p><h1 align='center'>实验二：词频统计与可视化</h1><br> <h5 align='center'> Design by W.H Huang | Direct by Prof Feng</h5></p><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><p>通过本次实验，你应该：</p><ul><li>熟悉 <em>hadoop</em>+ <em>Spark</em>下编程环境</li><li>掌握基于<em>Spark</em>的基本<em>MAP REDUCE</em> 操作</li><li>掌握基本大数据可视化工具</li><li>独立完成本次青年群体择偶观分析实验</li><li>【新增】远程开发相关知识</li></ul><p>本次实验需小组内分工合作完成两个任务：</p><ol><li><p><em>WordCount</em> 词频统计</p><p>你将会使用到 <em>jieba</em> 分词 &amp; 基于 <em>pySpark</em> 的基本 <em>MAP REDUCE</em> 操作进行词频统计，在指定数据集上大数据分析青年群体择偶观倾向。</p></li><li><p>大数据可视化</p><p>你将使用 <em>echars &amp; WordCloud</em> 两个可视化库来进行大数据可视化，小组独立完成核心代码编写、测试。</p></li></ol><h2 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2 实验准备"></a>2 实验准备</h2><h3 id="2-0-成绩说明"><a href="#2-0-成绩说明" class="headerlink" title="2.0 成绩说明"></a>2.0 成绩说明</h3><p>本次实验，根据各位同学选择的<strong>不同环境搭建方式</strong>，不同的成绩分数说明如下。</p><p>【注】本次实验不要求使用分布式。</p><div class="table-container"><table><thead><tr><th style="text-align:center">实验环境</th><th style="text-align:center">最高分</th></tr></thead><tbody><tr><td style="text-align:center">云服务器</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">VM虚拟机</td><td style="text-align:center">95</td></tr></tbody></table></div><p>在本次实验我们给予学有余力的同学，在完成本次实验的基础上提出了扩展要求。</p><p>【注】加分后总分不超过100分。</p><div class="table-container"><table><thead><tr><th style="text-align:center">扩展要求</th><th style="text-align:center">加分</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1. 使用分布式完成本次实验</td><td style="text-align:center">+5</td><td style="text-align:center">可参考ex3~ex4</td></tr><tr><td style="text-align:center">2. 扩充原有数据集（100M以上），或基于新的数据集进行实验</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据数据量、质量、难度给分</td></tr><tr><td style="text-align:center">3. 新增更多可视化，如柱状图等</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据可视化工作量给分</td></tr><tr><td style="text-align:center">4. 使用更好的算法分析数据，如应用深度学习模型Bert</td><td style="text-align:center">+10</td><td style="text-align:center">有对比实验最好</td></tr></tbody></table></div><h3 id="2-1-上传文件"><a href="#2-1-上传文件" class="headerlink" title="2.1 上传文件"></a>2.1 上传文件</h3><p>在开始实验前， 首先要将代码及相关资源上传到服务器。该小节将介绍如何使用FTP软件将本地（Windows）文件上传到服务器(Linux)。</p><ol><li><p>下载软件</p><p>FTP工具我们选择<code>Filezilla</code> ，下载地址：<a href="https://pc.qq.com/search.html#!keyword=fielzilla">Filezilla下载</a> </p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/RLvUt4bDNa69X1Y.png" alt="1579960280360"></p><p>点击进行下载安装，安装过程较为简单不再赘述。</p></li><li><p>连接服务器</p><p>依次点击：文件 —&gt; 站点管理器 —&gt;  新站点 </p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/snKEbvuzyc2CXLR.png" alt="1580056871863"></p></li><li><p>上传文件</p><p>如下图所示，左侧为本地文件，右侧为服务器文件目录（默认为 <code>/home/hadoop</code>）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/aWGltFuJnEXmvpV.png" alt="1580057006302"></p><p>上传完毕后，可在服务器上查看文件：</p><p><img src="https://i.loli.net/2020/09/17/c12v7n9fI4h5BSi.png" alt="1580057304136"></p></li></ol><h3 id="2-2-【强烈建议】远程开发"><a href="#2-2-【强烈建议】远程开发" class="headerlink" title="2.2 【强烈建议】远程开发"></a>2.2 【强烈建议】远程开发</h3><blockquote><p>教程支持：@<a href="https://github.com/leexinhao">white_windmills</a> @<a href="https://github.com/Wanghui-Huang">Wanghui-Huang</a> @<a href="https://github.com/ghc2000">ghc2000</a></p><ul><li>云环境：基于华为云，腾讯云/阿里云也可</li><li>操作系统：基于Ubantu，CentOS下也可</li></ul></blockquote><p>在教程<code>ex0</code> &amp; <code>2.1节</code>时，我们介绍了：</p><ul><li><p><code>SSH</code>工具，如<code>Xshell</code> ，可以很方便在<strong>终端命令行操作</strong>远程服务器；</p></li><li><p><code>FTP</code> 工具，如<code>Filezilla</code> ，可以很方便的<strong>上传/下载</strong>数据集和代码等；</p></li></ul><p>但是因为<strong>代码运行环境在远程服务器</strong>上，我们只能这么进行代码编写、调试：</p><ol><li><code>Filezilla</code>上传数据集等资源；</li><li><code>Xshell</code>连接服务器命令行操作，使用<code>vim</code> 编写代码，关键地方<code>print</code>；</li><li>编写好后命令行下执行 <code>python code.py</code> ，观察代码<code>print</code>输出 &amp; 调试。</li></ol><p>显然<strong>这样做效率是很低下</strong>的。或者你还想到：</p><ol><li>VNC登陆云服务器，安装桌面、IDE等；</li><li>在VNC中云桌面编写代码。</li></ol><p>但这种做法经过实际尝试也是不建议的：</p><ul><li><strong>资源问题</strong>：安装桌面要<strong>消耗服务器很大的资源</strong>，对于本来就<strong>资源不足</strong>的丐版云服务器雪上加霜；</li><li><strong>操作问题</strong>：VNC桌面登陆，复制、粘贴等基本操作都很麻烦，不太方便；</li><li><strong>网络问题</strong>：实际操作下，网络延迟有时比较大，加上启动桌面很耗资源，经常会卡成PPT。</li></ul><p>因此对于实际开发来说，我们还是<strong>更希望能使用本地IDE去调试远程代码，而不是使用vim或者直接远程服务器安装IDE</strong>。</p><p>那么，<strong>如何在本地电脑使用IDE去调试远程机器上的代码</strong>？</p><ul><li>现在我们可以在VSCode/Pycharm 进行远程开发相关配置；</li><li>VSCode/Pycharm 等IDE通常还<strong>集成了终端环境</strong>，方便我们操作服务器。</li></ul><p>正式开始前，我们先<strong>检查一下SSH安装情况</strong>。</p><ol><li><p>查看是否安装了ssh-server服务</p><p>非云系统默认只安装ssh-client服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep ssh</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210709104708181.png" alt="image-20210709104708181" style="zoom:80%;" /></p><p>华为云等云厂商一般还会默认安装ssh-server服务，如果没有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>确认ssh-server启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221133305362.png" alt="image-20211221133305362"></p><p>如果看到<code>sshd</code>，说明ssh-server已经成功启动。</p><p>特别的，我们设置一下<strong>允许密码登陆root用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>注释配置文件中的<code>PermitRootLogin without-password</code>，即前面加一个<code>#</code>号</li><li>增加<code>PermitRootLogin yes</code> 一行</li></ul><p>最后重启服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh stop</span><br><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-1-VSCode远程开发实践"><a href="#2-2-1-VSCode远程开发实践" class="headerlink" title="2.2.1 VSCode远程开发实践"></a>2.2.1 VSCode远程开发实践</h4><ol><li><p>安装Remote-SSH插件</p><p>左侧Extension图标 —-&gt; 输入 <code>Remote-SSH</code> —-&gt;安装即可。注意，需要<strong>远程和本地都进行安装</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163014391.png" alt="image-20211206163014391"></p></li><li><p>配置Remote-SSH插件</p><p>如图所示选择<code>.ssh/config</code> 文件进行配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163445062.png" alt="image-20211206163445062"></p><p>打开文件后，需要设置以下字段：</p><ul><li>Host：自定义即可</li><li>HostName：云主机<strong>公网IP</strong></li><li>User：登陆的用户，选择root</li><li>IdentityFile：免密登录私钥地址，如果没有配置则每次远程登录需要输入密码</li></ul><p>以下为示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">roy-cpp</span></span><br><span class="line">  <span class="string">HostName</span> <span class="number">121.36</span><span class="number">.59</span><span class="number">.23</span> <span class="comment"># 云主机公网IP</span></span><br><span class="line">  <span class="string">User</span>  <span class="string">root</span></span><br><span class="line">  <span class="string">IdentityFile</span> <span class="string">D:/huawei_rsa/id_rsa</span> <span class="comment"># 这行可删除</span></span><br></pre></td></tr></table></figure></li><li><p>登陆测试</p><p>点击下图按钮进行登陆：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206164334870.png" alt="image-20211206164334870"></p><p>输入密码后，便可以看到远程服务器已经成功连接。</p></li><li><p>远程开发实践</p><p>连接上后就和我们本地使用VSCode没有什么区别：</p><ul><li><p><strong>打开远程文件</strong>：File—-&gt;Open Folder—-&gt;指定文件夹路径，类似打开本地文件；</p></li><li><p><strong>使用终端</strong>：在VSCode下方<code>Terminal</code>一栏可进行命令行操作，可认为是一个ssh连接的界面，你可以在上面进行之前<code>Xshell</code>等软件的所有操作；</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211222132204902.png" alt="image-20211222132204902"></p></li><li><p><strong>远程debug</strong>：使用<code>python</code>插件，注意<u>远端&amp;本地</u>都要安装。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135337775.png" alt="image-20211221135337775"></p></li></ul></li></ol><h4 id="2-2-2-Pycharm远程开发实践"><a href="#2-2-2-Pycharm远程开发实践" class="headerlink" title="2.2.2 Pycharm远程开发实践"></a>2.2.2 Pycharm远程开发实践</h4><blockquote><p>在Pycharm中此功能需要用<strong>专业版</strong>，正版的话直接去官网学生申请即可（我们重大的邮箱没法申请，需要拍学生证申请）。</p></blockquote><ol><li><p>SSH配置</p><p>打开File-&gt;Settings-&gt;SSH Configurations，进行如下配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135547820.png" alt="image-20211221135547820"></p><p>输入完成后，点击Test Connection，测试一下连接状态</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135637429.png" alt="image-20211221135637429"></p></li><li><p>新建SSH Session</p><p>点击：Tools—-&gt;Start SSH Session…—-&gt;Edit credentials，现在可以进行对服务器的命令行操作（可以视作之前的ssh窗口）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135824733.png" alt="image-20211221135824733"></p><p>仅仅使用命令行是肯定不够的，pycharm提供了很多更便捷的工具。</p></li><li><p>配置远端python解释器</p><p>点击：File—-&gt;Settings—-&gt;Project:…—&gt;Project Interpreter，添加python解释器：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140024771.png" alt="image-20211221140024771"></p><p>选择SSH Interpreter，选择刚刚配置好的服务器：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140058246.png" alt="image-20211221140058246"></p><p>选择服务器中你需要的解释器，以及项目文件的映射路径，勾选自动同步等配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140124800.png" alt="image-20211221140124800"></p><p>配置完成后就和本地解释器的使用差不多了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140151969.png" alt="image-20211221140151969"></p><p>特别的如果需要修改映射路径可以在：tools-&gt;Deployment-&gt;Configurations，下进行修改。</p></li><li><p>打开远端目录</p><p>通过：tools—&gt;Deployment—&gt;Configurations—&gt;Browse Remote Host，打开远端目录文件树。</p><p>之后就可以操作远程目录的文件：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140412518.png" alt="image-20211221140412518"></p></li><li><p>问题解决</p><blockquote><p>[<strong>ERROR#1</strong>] 远端解释器连接失败。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140524288.png" alt="image-20211221140524288"></p></blockquote><p>一般是因为解释器路径写错了，很多系统默认装的是python3，修改解释器路径即可：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140625493.png" alt="image-20211221140625493"></p><blockquote><p>[<strong>ERROR#2</strong>] 华为云的openEuler系统ssh连不上。</p></blockquote><p>可能是服务器设置问题，需要修改/etc/ssh/sshd_config文件：</p><p>首先，运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>接着，我们要做如下修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AllowAgentForwarding <span class="built_in">yes</span></span><br><span class="line">AllowTcpForwarding <span class="built_in">yes</span></span><br><span class="line">GatewayPorts <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-3-扩展阅读：C-远程开发实践"><a href="#2-2-3-扩展阅读：C-远程开发实践" class="headerlink" title="2.2.3 扩展阅读：C++远程开发实践"></a>2.2.3 扩展阅读：C++远程开发实践</h4><blockquote><p>最近在学C++，想配置C++远程开发环境？最好还能调试代码？</p></blockquote><p>请参考：<a href="https://hwh.zone/p/18652/">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a></p><h3 id="2-3-安装相关库"><a href="#2-3-安装相关库" class="headerlink" title="2.3 安装相关库"></a>2.3 安装相关库</h3><blockquote><p>:warning: 注意，<strong>本实验需要你安装桌面环境</strong>：请参考<code>ex0:2.1.2 可视化界面</code> 。</p></blockquote><p>先更新<code>pip</code> ，否则可能会出现安装失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install --upgrade pip  </span><br></pre></td></tr></table></figure><p>如果以下调用yum命令出错，请将以下两个文件的第一行改为<code>python2/2.7</code>。相关讨论可见：<a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/23">issue#23</a> 。</p><ol><li><p>修改urlgrabber-ext-down</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/libexec/urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211222000428258.png" alt="image-20211222000428258"></p></li><li><p>修改yum</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211222000511787.png" alt="image-20211222000511787"></p></li></ol><p>下面开始正式安装本次实验所需的库文件。</p><ul><li><p>安装字体文件</p><p>本次实验，需要wqy-microhei.ttc文件，但在<code>/usr/share/fonts</code> 可能并不存在该文件。需要自行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install wqy-microhei-fonts</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>jieba</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install jieba -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>wordcloud</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install wordcloud -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>pyecharts</code> </p><blockquote><p>需要指定安装1.7.0版本，否则下面代码API调用接口不正确。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts==1.7.0</span><br><span class="line">sudo pip3 install snapshot-selenium</span><br></pre></td></tr></table></figure></li><li><p>安装驱动（易错）</p><blockquote><p>具体讨论可参考：@<a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/30">issue#30</a> @<a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/21">issue#21</a></p></blockquote><p><code>pyechars</code> 模块保存图片需要安装相应<strong>chromedriver和google-chrome</strong> ，并且<strong>版本号要一一对应</strong>。</p><ul><li><p>安装google-chrome</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/CentOS-Base.repo   http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">sudo curl https://intoli.com/install-google-chrome.sh | bash </span><br><span class="line">ldd /opt/google/chrome/chrome | grep <span class="string">&quot;not found&quot;</span></span><br><span class="line"></span><br><span class="line">google-chrome --no-sandbox --headless --disable-gpu --screenshot https://www.baidu.com/</span><br></pre></td></tr></table></figure></li><li><p>安装chromedrive</p><p>chromedrive版本要和google-chrome对应，所以我们先查看google-chrome版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable --version</span><br></pre></td></tr></table></figure><p>记录版本号后，去<a href="https://npm.taobao.org/mirrors/chromedriver/">https://npm.taobao.org/mirrors/chromedriver/</a> 下载对应的驱动。下载方式：</p><ul><li><p>推荐： <code>wget  下载链接</code> 形式 ，例如下载95版本的chromedriver</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O chromedriver_linux64.zip https://npm.taobao.org/mirrors/chromedriver/107.0.5304.62/chromedriver_linux64.zip</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>笨一点：本地机器下载后，使用FTP工具上传到服务器</p></li></ul><p>下载后，在下载的<strong>压缩文件所在的路径</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先删除之前的chromedriver</span></span><br><span class="line">sudo <span class="built_in">rm</span> -f /usr/bin/chromedriver</span><br><span class="line">sudo <span class="built_in">rm</span> -f /usr/local/bin/chromedriver</span><br><span class="line">sudo <span class="built_in">rm</span> -f /usr/local/share/chromedriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.unzip 解压</span></span><br><span class="line"><span class="comment"># 解压出文件chromedriver</span></span><br><span class="line">unzip chromedriver_linux64.zip    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.赋予777权限</span></span><br><span class="line"><span class="built_in">chmod</span> 777 chromedriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.mv 移动到/usr/bin/路径</span></span><br><span class="line">sudo <span class="built_in">mv</span>  chromedriver /usr/bin/</span><br></pre></td></tr></table></figure><h3 id="2-4-设置日志级别"><a href="#2-4-设置日志级别" class="headerlink" title="2.4 设置日志级别"></a>2.4 设置日志级别</h3><blockquote><p>由于<code>spark</code> 在运行时会打印非常多的日志，为了便于调试观察，我们设置日志级别为 <code>WARN</code> 。</p></blockquote><p>以下为全局设置日志级别方式，你也可在代码中临时设置 <code>sc.setLogLevel(&quot;WARN&quot;)</code>  （详见<code>ex3.pdf</code>）。</p><ol><li><p>切换到<code>conf</code> 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/conf</span><br></pre></td></tr></table></figure></li><li><p>设置配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> log4j2.properties.template log4j.properties</span><br><span class="line">vim log4j2.properties</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">status = error</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">property</span>.LOG_HOME=/output/logs</span><br><span class="line">   <span class="built_in">property</span>.BACKUP_HOME=backup</span><br><span class="line">   <span class="built_in">property</span>.SERVER_NAME=buddie-Service</span><br><span class="line">   <span class="built_in">property</span>.EVERY_FILE_SIZE=10M</span><br><span class="line">   <span class="built_in">property</span>.OUTPUT_LOG_LEVEL=INFO</span><br><span class="line">   <span class="built_in">property</span>.FILE_MAX=<span class="number">10</span></span><br><span class="line">   </span><br><span class="line">   appender.console.<span class="built_in">type</span> = Console</span><br><span class="line">   appender.console.name = STDOUT</span><br><span class="line">   appender.console.layout.<span class="built_in">type</span> = PatternLayout</span><br><span class="line">   appender.console.layout.pattern = %m%n</span><br><span class="line">   </span><br><span class="line">   appender.rolling.<span class="built_in">type</span>=RollingFile</span><br><span class="line">   appender.rolling.name=RollingFileAll</span><br><span class="line">   appender.rolling.<span class="built_in">filter</span>.threshold.level = trace</span><br><span class="line">   appender.rolling.<span class="built_in">filter</span>.threshold.<span class="built_in">type</span> = ThresholdFilter</span><br><span class="line">   appender.rolling.fileName=$&#123;LOG_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_<span class="built_in">all</span>.log</span><br><span class="line">   appender.rolling.filePattern=$&#123;LOG_HOME&#125;/dev_$&#123;BACKUP_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_<span class="built_in">all</span>.%d&#123;yyyy-MM-dd-HH&#125;.log</span><br><span class="line">   appender.rolling.layout.<span class="built_in">type</span>=PatternLayout</span><br><span class="line">   appender.rolling.layout.pattern=%d %p %C&#123;<span class="number">1.</span>&#125; [%t] %m%n</span><br><span class="line">   appender.rolling.policies.<span class="built_in">type</span>=Policies</span><br><span class="line">   appender.rolling.policies.time.<span class="built_in">type</span>=TimeBasedTriggeringPolicy</span><br><span class="line">   appender.rolling.policies.time.interval=<span class="number">2</span></span><br><span class="line">   appender.rolling.policies.time.modulate=true</span><br><span class="line">   appender.rolling.policies.size.<span class="built_in">type</span>=SizeBasedTriggeringPolicy</span><br><span class="line">   appender.rolling.policies.size.size=$&#123;EVERY_FILE_SIZE&#125;</span><br><span class="line">   appender.rolling.strategy.<span class="built_in">type</span>=DefaultRolloverStrategy</span><br><span class="line">   </span><br><span class="line">   appender.error.<span class="built_in">type</span>=RollingFile</span><br><span class="line">   appender.error.name=RollingFileError</span><br><span class="line">   appender.error.<span class="built_in">filter</span>.threshold.level = error</span><br><span class="line">   appender.error.<span class="built_in">filter</span>.threshold.<span class="built_in">type</span> = ThresholdFilter</span><br><span class="line">   appender.error.fileName=$&#123;LOG_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_error.log</span><br><span class="line">   appender.error.filePattern=$&#123;LOG_HOME&#125;/dev_$&#123;BACKUP_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_error.%d&#123;yyyy-MM-dd-HH&#125;.log</span><br><span class="line">   appender.error.layout.<span class="built_in">type</span>=PatternLayout</span><br><span class="line">   appender.error.layout.pattern=%d %p %C&#123;<span class="number">1.</span>&#125; [%t] %m%n</span><br><span class="line">   appender.error.policies.<span class="built_in">type</span>=Policies</span><br><span class="line">   appender.error.policies.time.<span class="built_in">type</span>=TimeBasedTriggeringPolicy</span><br><span class="line">   appender.error.policies.time.interval=<span class="number">2</span></span><br><span class="line">   appender.error.policies.time.modulate=true</span><br><span class="line">   appender.error.policies.size.<span class="built_in">type</span>=SizeBasedTriggeringPolicy</span><br><span class="line">   appender.error.policies.size.size=$&#123;EVERY_FILE_SIZE&#125;</span><br><span class="line">   appender.error.strategy.<span class="built_in">type</span>=DefaultRolloverStrategy</span><br><span class="line">   </span><br><span class="line">   appender.charge.<span class="built_in">type</span>=RollingFile</span><br><span class="line">   appender.charge.name=RollingFileCharge</span><br><span class="line">   appender.charge.<span class="built_in">filter</span>.threshold.level = trace</span><br><span class="line">   appender.charge.<span class="built_in">filter</span>.threshold.<span class="built_in">type</span> = ThresholdFilter</span><br><span class="line">   appender.charge.fileName=$&#123;LOG_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_charge.log</span><br><span class="line">   appender.charge.filePattern=$&#123;LOG_HOME&#125;/dev_$&#123;BACKUP_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_charge.%d&#123;yyyy-MM-dd-HH&#125;.log</span><br><span class="line">   appender.charge.layout.<span class="built_in">type</span>=PatternLayout</span><br><span class="line">   appender.charge.layout.pattern=%d %p %C&#123;<span class="number">1.</span>&#125; [%t] %m%n</span><br><span class="line">   appender.charge.policies.<span class="built_in">type</span>=Policies</span><br><span class="line">   appender.charge.policies.time.<span class="built_in">type</span>=TimeBasedTriggeringPolicy</span><br><span class="line">   appender.charge.policies.time.interval=<span class="number">2</span></span><br><span class="line">   appender.charge.policies.time.modulate=true</span><br><span class="line">   appender.charge.policies.size.<span class="built_in">type</span>=SizeBasedTriggeringPolicy</span><br><span class="line">   appender.charge.policies.size.size=$&#123;EVERY_FILE_SIZE&#125;</span><br><span class="line">   appender.charge.strategy.<span class="built_in">type</span>=DefaultRolloverStrategy</span><br><span class="line">   </span><br><span class="line">   logger.activity.name = buddie.activity</span><br><span class="line">   logger.activity.level = debug</span><br><span class="line">   logger.activity.additivity = false</span><br><span class="line">   logger.activity.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   logger.activity.appenderRef.error.ref = RollingFileError</span><br><span class="line">   logger.activity.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   </span><br><span class="line">   logger.login.name = buddie.login</span><br><span class="line">   logger.login.level = debug</span><br><span class="line">   logger.login.additivity = false</span><br><span class="line">   logger.login.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   logger.login.appenderRef.error.ref = RollingFileError</span><br><span class="line">   logger.login.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   </span><br><span class="line">   logger.charge.name = buddie.charge</span><br><span class="line">   logger.charge.level = trace</span><br><span class="line">   logger.charge.additivity = false</span><br><span class="line">   logger.charge.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   logger.charge.appenderRef.error.ref = RollingFileError</span><br><span class="line">   logger.charge.appenderRef.charge.ref = RollingFileCharge</span><br><span class="line">   logger.charge.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   </span><br><span class="line">   rootLogger.level = info</span><br><span class="line">   rootLogger.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   rootLogger.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   rootLogger.appenderRef.error.ref = RollingFileError</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><p>   <img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/3ZNGEld1BuSQihL.png" alt="1580093095312"></p><h2 id="3-实验流程"><a href="#3-实验流程" class="headerlink" title="3 实验流程"></a>3 实验流程</h2><h3 id="（已弃用）3-0-命令行下完成实验"><a href="#（已弃用）3-0-命令行下完成实验" class="headerlink" title="（已弃用）3.0 命令行下完成实验"></a>（已弃用）3.0 命令行下完成实验</h3><blockquote><p>:warning: <strong>该小节编写、调试代码方式已被弃用，采用远程开发模式</strong> :warning: </p><p><code>2021-12-20</code>：建议大家使用<strong>远程开发</strong>，进行代码编写，实验调试等。远程开发教程请参考：2.2节 【强烈建议-远程开发】。</p></blockquote><p>在实验开始之前，我们建议你按照以下流程完成实验：</p><ol><li><strong>命令行</strong> 下完成代码 <strong>单元测试</strong></li><li>单元测试无误，将代码填充在相应给出的<code>py</code> 文件函数中</li><li><code>spark-submit</code> 方式提交代码</li></ol><blockquote><p>:slightly_smiling_face: 如何在命令行下完成单元测试？</p></blockquote><ol><li><p>启动 <code>pyspark</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">bin/pyspark</span><br></pre></td></tr></table></figure><blockquote><p>:warning:  后续实验都是在集群环境下（本次实验不需要），启动<code>pyspark</code>应该按以下方式：</p><ul><li><p>启动集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动hadoop集群</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/hadoop  </span><br><span class="line">sbin/start-all.sh</span><br><span class="line"><span class="comment"># 启动spark集群</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">sbin/start-master.sh</span><br><span class="line">sbin/start-slaves.sh</span><br></pre></td></tr></table></figure></li><li><p>启动<code>pyspark</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/pyspark --master spark://master:7077</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>命令行下单元测试</p><p>例如，本次实验要求你完成<code>jiebaCut</code>函数编写：</p><blockquote><p>完成下列指定位置编码，使得<code>str</code> 为所有答案拼接而成的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jiebaCut</span>(<span class="params">answers_filePath</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    结巴分词</span></span><br><span class="line"><span class="string">    :param answers_filePath: answers.txt路径</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取answers.txt</span></span><br><span class="line">    answersRdd = sc.textFile(answers_filePath) <span class="comment"># answersRdd每一个元素对应answers.txt每一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 利用SpardRDD reduce()函数,合并所有回答</span></span><br><span class="line">    <span class="comment"># 【现在你应该完成下面函数编码】</span></span><br><span class="line">    <span class="built_in">str</span> = answersRdd.reduce(<span class="keyword">lambda</span> )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># jieba分词</span></span><br><span class="line">    words_list = jieba.lcut(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> words_list</span><br></pre></td></tr></table></figure><p>:warning: 命令行模式下，不用设置 <code>SparkContext、SparkSession</code>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf = SparkConf().setAppName(<span class="string">&quot;ex2&quot;</span>).setMaster(<span class="string">&quot;local&quot;</span>)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br></pre></td></tr></table></figure><p>会自动生成实例<code>sc</code>，可直接使用！</p></blockquote><p>首先定义<code>answers_filePath</code> ，查询此前代码指定按照如下方式进行拼接：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/ONIJoVzw9EcGWqf.png" alt="1580526312394"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; answers_filePath = <span class="string">&#x27;file:///home/hadoop/Experiment/Ex2_WordCount/src/answers.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>按照流程读入文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; answersRdd = sc.textFile(answers_filePath)</span><br><span class="line">&gt;&gt;&gt; answersRdd.take(10)  <span class="comment"># 展示前10行数据验证</span></span><br></pre></td></tr></table></figure><p>现在你可以尝试在命令行下 <strong>实时交互</strong> 完成  <code>str = answersRdd.reduce(lambda )</code> 这行代码完整编写。</p><p>例如，你可以如此进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; answersRdd.reduce(lambda a,b: a+b)</span><br><span class="line"><span class="string">&#x27;★★★更新于4个月以后★7月14日晚★★★写这个答案时，刚刚过完春节，在家被催婚心烦意乱，随手刷到，一时兴起...&#x27;</span></span><br></pre></td></tr></table></figure><p>会实时显示交互结果，验证是否编码正确。</p></li><li><p>提交代码</p><p>在命令行下单元测试后，便可以填写在相应<code>py</code> 文件中。</p><p>最后通过 <code>spark-submit</code>  方式提交代码。相应如何提交，在实验后有详细介绍，这里不再赘述。</p></li></ol><h3 id="3-1-数据集介绍"><a href="#3-1-数据集介绍" class="headerlink" title="3.1  数据集介绍"></a>3.1  数据集介绍</h3><blockquote><p>本次实验数据集来源于2019级研究生@<strong><em>W.H. Huang</em></strong>，数据集包含了知乎全站 <strong>择偶观</strong> 相关问题下所有 <em><u>答案 &amp;作者&amp;年龄&amp;地区等信息</u></em> 。原<strong>完整</strong>数据存储于<code>mysql</code>数据库，出于简化实验数据部署等目的，本次实验<strong>仅使用其中部分数据</strong>以<code>txt</code>文本形式展示。</p></blockquote><p>数据集 <code>answers.txt</code> 每一行代表一个完整回答，一共有3W条回答，如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/emVwLuQxP7DHIi9.png" alt="1580057443238"></p><p>每一条回答均已去除图片、视频URL、HTML标签等。</p><h3 id="3-2-WordCount-py"><a href="#3-2-WordCount-py" class="headerlink" title="3.2 WordCount.py"></a>3.2 WordCount.py</h3><h4 id="3-2-1-完成编码"><a href="#3-2-1-完成编码" class="headerlink" title="3.2.1 完成编码"></a>3.2.1 完成编码</h4><p>你现在应该独立完成<code>WordCount.py</code> 编码，可在服务器上查看：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/AHPiBwYqOWoVeM5.png" alt="1580059797013"></p><p><code>WordCount.py</code> 有<code>3</code>个函数，它们的作用如下：</p><ul><li><code>getStopWords</code> ：读取<code>stop_words.txt</code> 所有停用词，返回一个 <code>python List</code></li><li><code>jiebaCut</code> : 将所有答案合并，并进行分词，返回一个 <code>python List</code></li><li><code>wordcout</code> : 核心函数，利用<code>SparkRdd</code> 完成词频统计</li></ul><h5 id="jiebaCut"><a href="#jiebaCut" class="headerlink" title="jiebaCut"></a><code>jiebaCut</code></h5><p>完成下列指定位置编码，使得<code>str</code> 为所有答案拼接而成的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jiebaCut</span>(<span class="params">answers_filePath</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    结巴分词</span></span><br><span class="line"><span class="string">    :param answers_filePath: answers.txt路径</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取answers.txt</span></span><br><span class="line">    answersRdd = sc.textFile(answers_filePath) <span class="comment"># answersRdd每一个元素对应answers.txt每一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 利用SpardRDD reduce()函数,合并所有回答</span></span><br><span class="line">    <span class="comment"># 【现在你应该完成下面函数编码】</span></span><br><span class="line">     <span class="built_in">str</span> = answersRdd.reduce(<span class="keyword">lambda</span>  )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># jieba分词</span></span><br><span class="line">    words_list = jieba.lcut(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> words_list</span><br></pre></td></tr></table></figure><h5 id="wordcout"><a href="#wordcout" class="headerlink" title="wordcout"></a><code>wordcout</code></h5><p>完成下面指定位置编码，使得<code>resRdd</code> 包含所有词频统计结果，且降序排列。</p><p>打印<code>resRdd</code> 前十个元素应该为如下结果，<code>resRdd.take(10)</code> :</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/TCVPya3An1iYRG9.png" alt="1580060016321"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordcount</span>(<span class="params">isvisualize=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对所有答案进行</span></span><br><span class="line"><span class="string">    :param visualize: 是否进行可视化</span></span><br><span class="line"><span class="string">    :return: 将序排序结果RDD</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取停用词表</span></span><br><span class="line">    stopwords = getStopWords(SRCPATH + <span class="string">&#x27;stop_words.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结巴分词</span></span><br><span class="line">    words_list = jiebaCut(<span class="string">&quot;file://&quot;</span> + SRCPATH + <span class="string">&quot;answers.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 词频统计</span></span><br><span class="line">    wordsRdd = sc.parallelize(words_list)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># wordcount：去除停用词等同时对最后结果按词频进行排序</span></span><br><span class="line">    <span class="comment"># 完成SparkRDD操作进行词频统计</span></span><br><span class="line">    <span class="comment"># 提示：你应该依次使用</span></span><br><span class="line">    <span class="comment">#      1.filter函数进行停用词过滤&amp;去除长度=1的词汇</span></span><br><span class="line">    <span class="comment">#      2.map进行映射，如[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;a&#x27;] --&gt; [(&#x27;a&#x27;,1),(&#x27;b&#x27;,1),(&#x27;a&#x27;,1)] </span></span><br><span class="line">    <span class="comment">#      3.reduceByKey相同key进行合并 [(&#x27;a&#x27;,2),(&#x27;b&#x27;,1)] </span></span><br><span class="line">    <span class="comment">#      4.sortBy进行排序，注意应该是降序排序</span></span><br><span class="line">    <span class="comment">#【现在你应该完成下面函数编码】</span></span><br><span class="line">    resRdd = wordsRdd.<span class="built_in">filter</span>(<span class="keyword">lambda</span> word: ) \</span><br><span class="line">                     .<span class="built_in">filter</span>(<span class="keyword">lambda</span> word: ) \</span><br><span class="line">                     .<span class="built_in">map</span>(<span class="keyword">lambda</span> word: ) \</span><br><span class="line">                     .reduceByKey(<span class="keyword">lambda</span> a, b: ) \</span><br><span class="line">                     .sortBy(ascending=<span class="literal">False</span>, numPartitions=<span class="literal">None</span>,keyfunc=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])\ </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化展示</span></span><br><span class="line">    <span class="keyword">if</span> isvisualize:</span><br><span class="line">        v = visualize()</span><br><span class="line">        <span class="comment"># 饼状图可视化</span></span><br><span class="line">        pieDic = v.rdd2dic(resRdd,<span class="number">10</span>)</span><br><span class="line">        v.drawPie(pieDic)</span><br><span class="line">        <span class="comment"># 词云可视化</span></span><br><span class="line">        wwDic = v.rdd2dic(resRdd,<span class="number">50</span>)</span><br><span class="line">        v.drawWorcCloud(wwDic)</span><br><span class="line">    <span class="keyword">return</span>  resRdd</span><br></pre></td></tr></table></figure><h4 id="3-2-2-提交代码"><a href="#3-2-2-提交代码" class="headerlink" title="3.2.2 提交代码"></a>3.2.2 提交代码</h4><p>此时主函数代码，设置可视化为<code>False</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行词频统计，不进行可视化</span></span><br><span class="line">    resRdd = wordcount(isvisualize=False)</span><br><span class="line">    <span class="built_in">print</span>(resRdd.take(10))  <span class="comment"># 查看前10个</span></span><br></pre></td></tr></table></figure><ol><li><p>切换到<code>spark</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br></pre></td></tr></table></figure></li><li><p>提交代码（单机模式）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit /home/hadoop/Experiment/Ex2_WordCount/WordCount.py</span><br></pre></td></tr></table></figure><blockquote><p>:warning: 如果启动了集群需要先关闭，因为<strong>本次实验并非在集群环境下运行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查看结果</p><p>你应该得到如下结果：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/gQeIUcVjBlaiHoN.png" alt="1580543879036"></p></li></ol><h3 id="3-3-visualize-py"><a href="#3-3-visualize-py" class="headerlink" title="3.3 visualize.py"></a>3.3 visualize.py</h3><p>在本节你应该完成对<code>visualize.py</code> 核心代码编写。</p><h4 id="3-3-1-完成编码"><a href="#3-3-1-完成编码" class="headerlink" title="3.3.1 完成编码"></a>3.3.1 完成编码</h4><p>可在服务器上查看<code>visualize.py</code> 文件如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/hNYsGkQwReicIoE.png" alt="1580060759868"></p><p><code>visualize.py</code> 一共有<code>3</code>个函数，它们的作用如下：</p><ul><li><code>rdd2dic</code> ： 将<code>resRdd</code>转换为<code>python Dic</code>，并截取指定长度<code>topK</code></li><li><code>drawWorcCloud</code> ：进行词云可视化，同时保存结果</li><li><code>drawPie</code> ： 进行饼图可视化，同时保存结果</li></ul><h5 id="rdd2dic"><a href="#rdd2dic" class="headerlink" title="rdd2dic"></a><code>rdd2dic</code></h5><p>完成下面指定位置编码，将<code>resRDD</code>转换为<code>python Dic</code> ，并截取指定长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rdd2dic</span>(<span class="params">self,resRdd,topK</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将RDD转换为Dic，并截取指定长度topK</span></span><br><span class="line"><span class="string">    :param resRdd: 词频统计降序排序结果RDD</span></span><br><span class="line"><span class="string">    :param topK: 截取的指定长度</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 提示：SparkRdd有函数可直接转换</span></span><br><span class="line">    <span class="comment">#【现在你应该完成下面函数编码】</span></span><br><span class="line">    </span><br><span class="line">    resDic =              </span><br><span class="line">    <span class="comment"># 截取字典前K个</span></span><br><span class="line">    K = <span class="number">0</span></span><br><span class="line">    wordDicK = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> resDic.items():</span><br><span class="line">        <span class="comment"># 完成循环截取字典</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> wordDicK</span><br></pre></td></tr></table></figure><h4 id="3-3-2-提交代码"><a href="#3-3-2-提交代码" class="headerlink" title="3.3.2 提交代码"></a>3.3.2 提交代码</h4><p>此时主函数代码，设置可视化为<code>True</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行词频统计，并可视化</span></span><br><span class="line">    resRdd = wordcount(isvisualize=True)</span><br></pre></td></tr></table></figure><ol><li><p>切换到<code>spark</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br></pre></td></tr></table></figure></li><li><p>提交代码</p><blockquote><p>依旧强调，非特殊说明不要在root用户执行代码，可能会出现以下错误：</p><p>“ERROR:zygote_host_impl_linux.cc (90)] Running as root without —no-sandbox is not supported.“</p><p>本次操作是在hadoop用户下。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit /home/hadoop/Experiment/Ex2_WordCount/WordCount.py</span><br></pre></td></tr></table></figure></li><li><p>问题解决</p><ul><li><p><strong>[ERROR#1] selenium. common. exception. webdriver exception: message: chrome not reachable</strong></p><p>通常是因为chromedriver程序占用了端口，控制台登陆重启服务器即可。相关讨论可见 <a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/5">issue#5 @lympassion</a></p></li><li><p><strong>[ERROR#2]  Operation not permitted</strong></p><blockquote><p>感谢<a href="https://github.com/a-fly-fly-bird">a-fly-fly-bird</a> 同学提供的解决方案。</p></blockquote><ol><li><p><strong>jieba.cache操作不足</strong> ：PermissionError: [Errno 1] Operation not permitted: ‘/tmp/tmpg255ml7f’ -&gt; ‘/tmp/jieba.cache’</p><p>这是因为 jieba 默认情况下在 /tmp 下存储缓存文件，然而不是 root 用户，权限不够。解决办法是修改默认缓存文件的目录，把缓存文件放在用户的目录下面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/lib/python3.6/site-packages/jieba/__init__.py</span><br></pre></td></tr></table></figure><p>将self.tmp_dir 赋值为用户目录下的任意目录，如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/140518379-b7c93055-df45-4409-8e96-4f1ebfcbd7f5.png" alt="image"></p></li><li><p><strong>render.html权限不够</strong> ：Permission denied: ‘render.html’</p><p>修改render.html权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 render.html</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>[ERROR#3]  运行chromedriver生成echarts图片报错</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/140520039-07bcc908-5d52-47ee-a2a4-03b62eb210a9.png" alt="image"></p><p>重新安装snapshot-selenium即可解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 uninstall snapshot-selenium</span><br><span class="line">pip3 install snapshot-selenium</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看结果</p><p>查看目录 <code>/home/hadoop/Experiment/Ex2_WordCount/results</code> ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/tusdOxpvHlhFCYT.png" alt="1580061469320"></p><p>可以看出：<code>身高、家庭、性格、父母、学历</code> 等是青年群体择偶最在意的几个特质。</p></li></ol><h2 id="4-扩展实验"><a href="#4-扩展实验" class="headerlink" title="4 扩展实验"></a>4 扩展实验</h2><p>根据第2节：在本次实验我们给予学有余力的同学，在完成本次实验的基础上提出了扩展要求。</p><p>【注】加分后总分不超过100分。</p><div class="table-container"><table><thead><tr><th style="text-align:center">扩展要求</th><th style="text-align:center">加分</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">1. 使用分布式完成本次实验</td><td style="text-align:center">+5</td><td style="text-align:center">可参考ex3~ex4</td></tr><tr><td style="text-align:center">2. 扩充原有数据集（100M以上），或基于新的数据集进行实验</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据数据量、质量、难度给分</td></tr><tr><td style="text-align:center">3. 新增更多可视化，如柱状图等</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据可视化工作量给分</td></tr><tr><td style="text-align:center">4.使用更好的算法分析数据，如应用深度学习模型Bert</td><td style="text-align:center">+10</td><td style="text-align:center">有对比实验更好</td></tr></tbody></table></div><p>当然，<strong>如果你有更好的idea</strong>来完善更新本次实验，请联系老师或助教，我们还会考虑为你申请本年度的优秀课设（每一年都有同学通过该方式获得优秀课设）。</p><p>详情你可参考：<a href="https://github.com/Wanghui-Huang/CQU_bigdata">CQU_bigdata-开源贡献</a>。</p><h2 id="5-实验小结"><a href="#5-实验小结" class="headerlink" title="5 实验小结"></a>5 实验小结</h2><p>本次实验中你使用Hadoop&amp;Spark编写了自己第一个项目，相信你一定有所收获。当然，你还体验了下远程开发的快感。</p><p>接下来的实验，你将会进一步学习在分布式集群下进行大数据分析，如：在集群执行任务、<code>hdfs</code>的使用等。同时你也将开始了解基本机器学习算法在大数据分析的应用，这将包括 <code>Kmeans</code>、<code>SVM</code> 等经典机器学习算法。</p><p>我们将尽量设计有趣、生动的实例来帮助你理解。最后，恭喜你完成第一个在基于<code>Spark</code>平台的大数据分析小项目，希望你从中获得了不少乐趣 :) 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;h1 align=&#39;center&#39;&gt;实验二：词频统计与可视化&lt;/h1&gt;&lt;br&gt; &lt;h5 align=&#39;center&#39;&gt; Design by W.H Huang | Direct by Prof Feng&lt;/h5&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-实验目的&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大数据导论" scheme="http://example.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    <category term="华为云学习" scheme="http://example.com/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Brigram模型用于预测</title>
    <link href="http://example.com/2022/10/21/NLP%E5%AD%A6%E4%B9%A01/"/>
    <id>http://example.com/2022/10/21/NLP%E5%AD%A6%E4%B9%A01/</id>
    <published>2022-10-20T16:00:00.000Z</published>
    <updated>2022-10-21T17:45:45.267Z</updated>
    
    <content type="html"><![CDATA[<h5><font face='楷体'>    1、    基于训练语料，训练一个基于字的Bigram语言模型。当用户输入某个字序列，程序可以自动推荐该序列的后一个字（依次列出概率最大的5个可能字选项），根据提示用户选择某个字后，程序可以继续推荐下一个字的列表。例如：输入“长江大”，程序猜测下一个可能的字为“桥”、“河”、“学”、“道”等。<br>    要求：（1）要求至少使用一种平滑方法。（2）提交电子文档一份（word），内含两部分内容：程序源码文本，程序运行结果截图（至少包含三个测试语句运行结果）；（3）同时提交源程序文件（可采用任意语言开发）。<br><font face='楷体' color=red>    在这里我使用的是美团评论的数据集，具体地址找不到了。主要是为我们国创项目来学一些比较新的东西，然后基于老师的作业来做的一些东西。希望大家只是借鉴，要有自己的灵感，也欢迎交流！后续会周更</font>    </font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#构建数据库，并将最终数据库保存为一个npy文件！</span></span><br><span class="line"><span class="number">2.</span>doubleWords = &#123;&#125;  </span><br><span class="line"><span class="number">3.</span><span class="keyword">def</span> <span class="title function_">train02</span>(<span class="params">filename</span>):  </span><br><span class="line"><span class="number">4.</span>    doubleWords_pre=&#123;&#125;  </span><br><span class="line"><span class="number">5.</span>    f=<span class="built_in">open</span>(filename,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line"><span class="number">6.</span>    <span class="comment">#一共有多少个句子  </span></span><br><span class="line"><span class="number">7.</span>    num=<span class="number">0</span>  </span><br><span class="line"><span class="number">8.</span>    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():  </span><br><span class="line"><span class="number">9.</span>        <span class="comment"># 匹配所有中文形成一个list包,按符号分割出所有的字符  </span></span><br><span class="line"><span class="number">10.</span>        line1 = re.findall(<span class="string">&#x27;[\u4e00-\u9fa5]+&#x27;</span>, line)  </span><br><span class="line"><span class="number">11.</span>        <span class="keyword">for</span> words <span class="keyword">in</span> line1:  </span><br><span class="line"><span class="number">12.</span>            <span class="comment">#存前一个字符  </span></span><br><span class="line"><span class="number">13.</span>            words1=<span class="string">&#x27;B&#x27;</span>+words+<span class="string">&#x27;E&#x27;</span>  </span><br><span class="line"><span class="number">14.</span>            pre=<span class="string">&#x27; &#x27;</span>  </span><br><span class="line"><span class="number">15.</span>            <span class="comment">#计算一个字的频数和两个字连续出现的频数  </span></span><br><span class="line"><span class="number">16.</span>            <span class="keyword">for</span> word <span class="keyword">in</span> words1:  </span><br><span class="line"><span class="number">17.</span>                <span class="keyword">if</span> pre != <span class="string">&#x27; &#x27;</span>:  </span><br><span class="line"><span class="number">18.</span>                    <span class="keyword">if</span> pre <span class="keyword">in</span> doubleWords_pre:  </span><br><span class="line"><span class="number">19.</span>                        <span class="keyword">if</span> word <span class="keyword">in</span> doubleWords_pre[pre]:  </span><br><span class="line"><span class="number">20.</span>                            doubleWords_pre[pre][word]+=<span class="number">1</span>  </span><br><span class="line"><span class="number">21.</span>                        <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">22.</span>                            doubleWords_pre[pre][word]=<span class="number">1</span>  </span><br><span class="line"><span class="number">23.</span>                    <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">24.</span>                        doubleWords_pre[pre]=&#123;&#125;  </span><br><span class="line"><span class="number">25.</span>                pre=word  </span><br><span class="line"><span class="number">26.</span>            num+=<span class="number">1</span>  </span><br><span class="line"><span class="number">27.</span>    f.close()  </span><br><span class="line"><span class="number">28.</span>    <span class="comment"># 保存初始概率文件  </span></span><br><span class="line"><span class="number">29.</span>    np.save(<span class="string">&quot;data/doubleWords_pre&quot;</span>, doubleWords_pre)  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#采用平滑处理方法+二元文法  </span></span><br><span class="line"><span class="number">2.</span><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">worda ,wordb</span>):  </span><br><span class="line"><span class="number">3.</span>    <span class="keyword">if</span> worda <span class="keyword">in</span> doubleWords:  </span><br><span class="line"><span class="number">4.</span>        <span class="keyword">if</span> wordb <span class="keyword">in</span> doubleWords[worda]:  </span><br><span class="line"><span class="number">5.</span>            <span class="built_in">sum</span>=<span class="number">0</span>  </span><br><span class="line"><span class="number">6.</span>        <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">7.</span>            doubleWords[worda][wordb]=<span class="number">0</span>  </span><br><span class="line"><span class="number">8.</span>    <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">9.</span>        doubleWords[worda]=&#123;&#125;  </span><br><span class="line"><span class="number">10.</span>        doubleWords[worda][wordb]=<span class="number">0</span>  </span><br><span class="line"><span class="number">11.</span>    fenzi=doubleWords[worda][wordb]+<span class="number">1</span>  </span><br><span class="line"><span class="number">12.</span>    fenmu=<span class="number">0</span>  </span><br><span class="line"><span class="number">13.</span>    <span class="keyword">for</span> key <span class="keyword">in</span> doubleWords[worda]:  </span><br><span class="line"><span class="number">14.</span>        fenmu=fenmu+doubleWords[worda][key]+<span class="number">1</span>  </span><br><span class="line"><span class="number">15.</span>    doubleWords[worda][wordb]+=<span class="number">1</span>  </span><br><span class="line"><span class="number">16.</span>    <span class="keyword">return</span> (fenzi/fenmu)  </span><br><span class="line"><span class="number">17.</span>  </span><br><span class="line"><span class="number">18.</span><span class="comment">#采用二元文法计算概率,需要自己加&#x27;B&#x27;和&#x27;E&#x27;:  </span></span><br><span class="line"><span class="number">19.</span><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">word</span>):  </span><br><span class="line"><span class="number">20.</span>    <span class="built_in">sum</span>=<span class="number">1.0</span>  </span><br><span class="line"><span class="number">21.</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)-<span class="number">1</span>) :  </span><br><span class="line"><span class="number">22.</span>        <span class="built_in">sum</span>=<span class="built_in">sum</span>*fun1(word[i],word[i+<span class="number">1</span>])  </span><br><span class="line"><span class="number">23.</span>    <span class="keyword">return</span> <span class="built_in">sum</span>  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#预测结果  </span></span><br><span class="line"><span class="number">2.</span><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">word</span>):  </span><br><span class="line"><span class="number">3.</span>    preRes=&#123;&#125;  </span><br><span class="line"><span class="number">4.</span>    <span class="built_in">str</span>=word[<span class="built_in">len</span>(word)-<span class="number">1</span>]  </span><br><span class="line"><span class="number">5.</span>    s = <span class="built_in">sum</span>(doubleWords[<span class="built_in">str</span>].values())  </span><br><span class="line"><span class="number">6.</span>    <span class="keyword">for</span> key <span class="keyword">in</span> doubleWords[<span class="built_in">str</span>]:  </span><br><span class="line"><span class="number">7.</span>        <span class="keyword">if</span> key==<span class="string">&#x27;E&#x27;</span>:<span class="keyword">continue</span>  </span><br><span class="line"><span class="number">8.</span>        str1=<span class="built_in">str</span>+key+<span class="string">&#x27;E&#x27;</span>  </span><br><span class="line"><span class="number">9.</span>        preRes[key]=fun(str1)  </span><br><span class="line"><span class="number">10.</span>    <span class="keyword">return</span> preRes  </span><br><span class="line"><span class="number">11.</span>  </span><br><span class="line"><span class="number">12.</span><span class="comment">#将预测结果排序，选取前五个  </span></span><br><span class="line"><span class="number">13.</span><span class="keyword">def</span> <span class="title function_">Paixu</span>(<span class="params">word</span>):  </span><br><span class="line"><span class="number">14.</span>    Result=[]  </span><br><span class="line"><span class="number">15.</span>    preRes=predict(word)  </span><br><span class="line"><span class="number">16.</span>    preRes = <span class="built_in">sorted</span>(preRes.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)  </span><br><span class="line">   <span class="comment">#这考虑了语料库不足的情况！</span></span><br><span class="line"><span class="number">17.</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="number">5</span>,<span class="built_in">len</span>(preRes)):  </span><br><span class="line"><span class="number">18.</span>        Result.append(preRes[i][<span class="number">0</span>])  </span><br><span class="line"><span class="number">19.</span>    <span class="keyword">return</span> Result  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5&gt;&lt;font face=&#39;楷体&#39;&gt;
    1、    基于训练语料，训练一个基于字的Bigram语言模型。当用户输入某个字序列，程序可以自动推荐该序列的后一个字（依次列出概率最大的5个可能字选项），根据提示用户选择某个字后，程序可以继续推荐下一个字的列表。例如：输入“长江</summary>
      
    
    
    
    <category term="国创贾旺旺" scheme="http://example.com/categories/%E5%9B%BD%E5%88%9B%E8%B4%BE%E6%97%BA%E6%97%BA/"/>
    
    
    <category term="国创own" scheme="http://example.com/tags/%E5%9B%BD%E5%88%9Bown/"/>
    
    <category term="NLP" scheme="http://example.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>云服务器远程连接失败处理</title>
    <link href="http://example.com/2022/10/16/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>http://example.com/2022/10/16/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-10-16T05:51:33.187Z</updated>
    
    <content type="html"><![CDATA[<h5>    某天晚上突然遇到这个问题，远程连接怎么也连接不上，后来查了很多资料，终于发现了问题所在。具体如下</h5><h5>   我们在华为云网页打开使用VPN登录，并在命令行下输入如下命令：</h5><p><img src="https://s2.loli.net/2022/10/16/KexFyUlzfgn3VLa.png" alt="183df258fb3634b8ebc27f.png"></p><h5>   这个时候我们会发现如上问题，network和NetworkManager都没开。   <br>而NetworkManager 是一个为系统提供检测和配置功能以便自动连接到网络的程序。NetworkManager 的功能对无线和有线网络都很有用。对于无线网络，NetworkManager 偏好已知的无线网络，并能切换到最可靠的网络。能感知 NetworkManager 的应用程序可以切换在线和离线模式。这个可能是导致我们出现问题的最大弊端之一</h5><h5>    解决方法，请输入如下命令即可</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5&gt;
    某天晚上突然遇到这个问题，远程连接怎么也连接不上，后来查了很多资料，终于发现了问题所在。具体如下
&lt;/h5&gt;

&lt;h5&gt;
   我们在华为云网页打开使用VPN登录，并在命令行下输入如下命令：
&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.loli</summary>
      
    
    
    
    <category term="大数据导论" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA/"/>
    
    
    <category term="错误" scheme="http://example.com/tags/%E9%94%99%E8%AF%AF/"/>
    
    <category term="华为云" scheme="http://example.com/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中文分词任务</title>
    <link href="http://example.com/2022/10/08/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E4%BB%BB%E5%8A%A1/"/>
    <id>http://example.com/2022/10/08/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-10-07T16:00:00.000Z</published>
    <updated>2022-10-08T05:47:12.716Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/08/DNTcU91LxlM3ufY.jpg" alt="扫描全能王 2022-10-08 13.40_1.jpg"></p><p><img src="https://s2.loli.net/2022/10/08/gpir1bytBIfQPo4.jpg" alt="扫描全能王 2022-10-08 13.40_2.jpg"></p><p><img src="https://s2.loli.net/2022/10/08/HPuGD1B6lb5rAKn.jpg" alt="扫描全能王 2022-10-08 13.40_3.jpg"></p><p><img src="https://s2.loli.net/2022/10/08/LbIEGTyAmeMhS2U.jpg" alt="扫描全能王 2022-10-08 13.40_4.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/10/08/DNTcU91LxlM3ufY.jpg&quot; alt=&quot;扫描全能王 2022-10-08 13.40_1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/20</summary>
      
    
    
    
    <category term="Nlp" scheme="http://example.com/categories/Nlp/"/>
    
    
    <category term="Nlp" scheme="http://example.com/tags/Nlp/"/>
    
  </entry>
  
</feed>
