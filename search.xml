<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Anchor-based and Anchor-free 概念理解2</title>
      <link href="/2023/05/02/CV%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2023/05/02/CV%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2>十七、RetinaNet简要介绍</h2><p>RetinaNet是一种用于目标检测的深度学习模型，由Facebook AI Research提出。它是一种基于单级检测器（one-stage detector）的检测器，可以同时预测多个尺度和不同宽高比的目标框，并且在目标检测的准确性和速度方面都具有很好的表现。</p><p>RetinaNet的核心思想是引入了一种名为Focal Loss的新的损失函数。这个损失函数可以有效地解决单级检测器在处理大量背景样本和少量正样本时的类别不平衡问题，从而提高目标检测的准确性。</p><p>RetinaNet的架构由两个主要组成部分构成：特征提取网络和预测网络。特征提取网络通常是一个预训练的卷积神经网络（如ResNet、Inception等），用于提取图像特征。预测网络包括一个特征金字塔网络（Feature Pyramid Network，FPN）和一个预测头（prediction head），用于生成目标框的位置和类别预测。</p><p>在RetinaNet中，特征金字塔网络可以生成一系列具有不同尺度和语义级别的特征图。预测头则包括两个子网络：一个用于生成目标框的位置偏移量（即边界框回归器），另一个用于预测每个目标框的类别（即分类器）。这两个子网络在不同尺度的特征图上进行操作，以便同时检测不同大小和宽高比的目标。</p><p>总体来说，RetinaNet是一种简单而有效的目标检测器，通过引入新的损失函数和设计特征金字塔网络来提高单级检测器的准确性，并在多个目标检测基准测试中取得了很好的成绩。</p><p>RetinaNet的整体流程可以分为以下几个步骤：</p><ol><li>特征提取：输入图像经过卷积神经网络（如ResNet等）进行特征提取，得到一系列具有不同尺度和语义级别的特征图。</li><li>特征金字塔网络：特征金字塔网络（Feature Pyramid Network，FPN）将不同尺度的特征图进行融合，生成一系列具有不同分辨率的特征金字塔。</li><li>预测头：对于每个特征金字塔，预测头包括两个子网络：一个用于生成目标框的位置偏移量（即边界框回归器），另一个用于预测每个目标框的类别（即分类器）。</li><li>Anchor生成：对于每个特征金字塔，根据其分辨率和比例，生成一组anchor boxes，用于对检测目标进行采样。</li><li>目标检测：对于每个特征金字塔和对应的anchor boxes，使用边界框回归器和分类器进行目标检测。具体地，分类器输出每个anchor box中各个类别的概率，而边界框回归器则预测每个anchor box与实际目标框之间的偏移量，从而生成最终的目标框。</li><li>Focal Loss：使用Focal Loss作为损失函数，对分类器的输出进行优化，以解决单级检测器中类别不平衡的问题，从而提高目标检测的准确性。</li><li>NMS：使用非极大值抑制（NMS）进行目标框的筛选，去除重叠度较高的目标框，得到最终的目标检测结果。</li></ol><p>总体来说，RetinaNet通过特征金字塔网络和Focal Loss等方法，克服了单级检测器在处理大量背景样本和少量正样本时的类别不平衡问题，从而在目标检测的准确性和速度方面都具有很好的表现。</p><h2>十八、FCOS流程</h2><p>FCOS（Fully Convolutional One-Stage Object Detection）是一种基于全卷积网络的单阶段目标检测方法，其流程如下：</p><ol><li>特征提取：输入图像通过卷积神经网络（如ResNet等）进行特征提取，得到一系列特征图。</li><li>特征金字塔网络：对于每个特征图，使用特征金字塔网络（Feature Pyramid Network，FPN）进行跨尺度特征融合，生成一组具有不同分辨率的特征金字塔。</li><li>分类头和回归头：在每个特征金字塔上，使用分类头和回归头分别预测每个像素点是否为物体以及物体的位置和大小。</li><li>Anchor-free检测：与RetinaNet不同，FCOS是一种anchor-free检测方法，它不需要预定义的anchor boxes。相反，对于每个像素点，使用回归头预测它相对于物体的中心点和大小，从而生成目标框。</li><li>损失函数：FCOS使用IoU Loss作为损失函数，以衡量预测框与真实框之间的重叠程度。同时，FCOS还使用了Center-ness Loss来约束目标框的中心点，以进一步提高检测精度。</li><li>NMS：使用非极大值抑制（NMS）进行目标框的筛选，去除重叠度较高的目标框，得到最终的目标检测结果。</li></ol><p>总体来说，FCOS通过使用全卷积网络和IoU Loss等方法，实现了无需anchor boxes的目标检测，从而在保证准确性的同时大大降低了计算复杂度，具有较高的实用价值。</p><h2>十九、FCOS和Retainnet 如何定义正负样本</h2><p>在RetinaNet中，模型首先计算每个anchor box与ground-truth box之间的IoU（交并比），如果IoU大于预设的阈值θp，则将该anchor box标记为正样本；如果IoU小于预设的阈值θn，则将该anchor box标记为负样本；对于IoU在阈值范围内的anchor box，则被忽略不参与训练。这种方式适用于anchor-based的检测模型，因为它们将anchor box作为预设样本。</p><p>而在FCOS中，模型采用了基于空间和尺度约束的方法来定义正负样本。具体来说，对于每个ground-truth box，模型会在其周围的一定范围内选取一组anchor points，并将它们标记为候选正样本。然后，根据预设的尺度范围，从这些候选正样本中选取最佳的正样本，并将剩下的anchor points标记为负样本。这种方式适用于anchor-free的检测模型，因为它们将目标的中心点作为预设样本。</p><p>总之，两种模型的正负样本定义方式略有不同，但都基于IoU或空间尺度约束，并且都旨在使正样本和负样本具有代表性，提高模型的训练效果。</p><p>在FCOS中，预设的尺度范围是为每个特征金字塔层级定义的。具体来说，对于第k层的金字塔特征图，设其步长为sk，那么预设的尺度范围为 [sk/2, 2sk]。这个范围的含义是：对于第k层特征图上的每个anchor point，它们的有效感受野（effective receptive field）应该在以目标中心为中心、宽高为 [sk/2, 2sk] 的区域内。只有落在这个区域内的anchor point才会被视为正样本，否则就被标记为负样本。</p><p>在训练过程中，模型会根据目标的真实尺度（即目标的宽高）来动态地调整预设的尺度范围，从而使得正负样本的定义更加准确。具体来说，对于每个ground-truth box，模型会计算其真实宽高与预设尺度范围的比值，然后根据这个比值来调整预设的尺度范围。这样做的好处是，能够在不同尺度的特征金字塔层级上更加准确地定义正负样本，从而提高模型的检测效果。</p><h2>二十、请详细解释FCOS和Retainnet的Regression starting status</h2><p>在目标检测中，回归模块的任务是对预测框进行微调，从而更精确地匹配目标的位置。RetinaNet和FCOS在回归模块的实现上略有不同，其中Regression starting status是一个重要的概念。</p><p>RetinaNet中，回归模块的输入是一个anchor box和对应的分类概率，输出是该anchor box的边界框坐标偏移量。为了让回归模块更容易学习到边界框的位置信息，RetinaNet采用了一种称为“Regression starting status”的策略。具体来说，对于每个anchor box，RetinaNet在训练开始时先计算它与所有ground truth boxes的IoU值，并选取IoU最高的那个ground truth box作为该anchor box的起始位置，然后再对其进行微调。这个起始位置相当于是回归模块的初始输入，有助于加速模型的收敛。</p><p>FCOS中，回归模块的输入是一个像素点的坐标以及对应的分类概率，输出是该点到目标边界框四个边界的距离。为了更好地学习到边界框的位置信息，FCOS同样采用了Regression starting status策略。具体来说，FCOS在训练开始时会预先计算每个ground truth box的中心点与特征图上所有像素点的距离，并将这些距离转换为初始回归值。这样，在后续的训练过程中，回归模块只需要微调这些初始值即可，大大加快了模型的收敛速度。需要注意的是，FCOS在计算初始回归值时还会根据ground truth box的大小调整其对应的特征金字塔层级，从而进一步提高模型的精度。</p><h2>二十一、GroupNorm  GIoU Loss In GT Box Centerness  Scalar 简要解释这五个改善措施</h2><p>这五个改善措施是针对目标检测中存在的问题进行的改进，简要解释如下：</p><ol><li>GroupNorm：在传统的批标准化（Batch Normalization，BN）中，小批量样本会导致较大的方差和偏移，使得模型难以收敛。而Group Normalization（GN）则是将通道分为若干组，每组计算均值和方差，从而减小了mini-batch size的依赖，稳定了归一化效果。</li><li>GIoU Loss：传统的目标检测损失函数，如IoU Loss、Smooth L1 Loss等，不能完全衡量预测框与真实框之间的重叠度。而 Generalized IoU Loss（GIoU Loss）考虑了预测框与真实框之间的完全重叠情况，从而更准确地衡量二者之间的重叠度。</li><li>In GT Box：在预测框回归中，传统方法会将所有样本视为负样本，仅仅关注预测框和真实框之间的差异。而在 GT Box 中，只有位于真实边界框内部的样本被视为正样本，使得模型更专注于内部样本的学习。</li><li>Centerness Scalar：在 RetinaNet 中，引入了一个额外的centerness值，用于衡量预测框与目标中心点的距离，从而更加关注包围目标的预测框是否包含目标中心，而不是仅仅关注重叠度。</li><li>Adaptive Training Sample Selection：在 FCOS 中，引入了自适应训练样本选择机制，将样本的权重与预测框中心到真实框边界的距离相关联，更加关注离真实框较近的预测框，有效地减少了负样本对模型的干扰。</li></ol><h2>二十二、AP性能</h2><p>平均精度（Average Precision，AP）是衡量目标检测算法性能的一种常用指标。它基于精确率-召回率曲线（Precision-Recall Curve，PR曲线）计算得到。在目标检测任务中，精确率表示检测出的物体中真正属于目标物体的比例，而召回率表示所有真正属于目标物体的物体中被正确检测到的比例。PR曲线展示了精确率和召回率之间的关系。</p><p>平均精度的计算方法是对PR曲线下的面积进行积分得到，具体来说，对PR曲线进行离散化，计算每个点的精确率和召回率，然后对这些点进行插值，计算出PR曲线下的面积，最后取平均值作为平均精度。</p><p>AP的取值范围在0到1之间，值越大表示检测算法的性能越好。一般来说，AP值大于0.5就可以认为是一个比较好的检测算法，AP值大于0.8可以认为是一个非常好的检测算法。</p><h2>二十三、ATSS为什么要使用均值和方差作为它的阈值</h2><p>ATSS算法使用均值和标准差的和作为IoU阈值的原因是为了动态地调整正负样本的阈值，从而更好地适应不同的数据集和目标。传统的目标检测算法使用固定的IoU阈值来划分正负样本，但是这种方法容易受到数据集中目标尺寸和密度的影响，导致检测性能下降。而ATSS算法使用均值和标准差的和来自适应地调整阈值，能够更好地适应不同的目标尺寸和密度，从而提高检测性能。具体来说，当目标比较稀疏时，使用较小的阈值可以更好地保留目标，而当目标比较密集时，使用较大的阈值可以减少误检。因此，使用均值和标准差的和作为IoU阈值可以使ATSS算法更加灵活和高效。</p><p>使用均值作为阈值的优点是，它可以反映出正负样本的平衡情况。对于一个较为平衡的数据集，正负样本的数量相对均衡，此时使用均值作为阈值可以更好地反映正负样本的覆盖情况。而如果使用一个固定的阈值，可能会导致正负样本的覆盖不均衡，从而影响模型的性能。因此，在正负样本的数量相对均衡时，使用均值作为阈值可以提高模型的鲁棒性和泛化性能。</p><p>使用方差作为阈值的优点是可以提高模型的鲁棒性。方差反映了样本数据分布的离散程度，如果数据分布比较分散，则方差较大，反之亦然。因此，使用方差可以考虑数据分布的变化范围，从而更加准确地确定阈值，避免了因单一阈值无法满足不同数据分布的情况而导致的模型泛化性能下降的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anchor-based and Anchor-free 概念理解</title>
      <link href="/2023/05/02/CV%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>/2023/05/02/CV%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2>一、FPN</h2>FPN是特征金字塔网络（Feature Pyramid Network）的缩写，是一种用于目标检测的深度学习模型。相较于传统的卷积神经网络（CNN），FPN的最大特点在于它可以生成不同尺度的特征金字塔，为检测不同大小物体提供支持。FPN模型在目标检测中的核心思想是提出一种新的特征提取方法，该方法可以产生具有不同尺度信息的特征金字塔，其中较低层级的金字塔主要用于检测较小的目标，而较高层级的金字塔主要用于检测较大的目标。FPN模型将金字塔中的特征图沿着空间维度上采样，并和低层级的特征图进行融合，从而产生具有不同尺度信息的特征金字塔。FPN模型不仅可以提高目标检测的准确率，而且可以提高模型的速度和效率。在目标检测任务中，FPN模型经常被用来检测不同大小的目标，并且在许多比赛和实际应用中表现优异，如COCO2017比赛、物体检测、图像分割等领域。<h2>二、Focal Loss</h2><p>Focal Loss是一种用于解决类别不平衡问题的损失函数，在2017年提出并广泛应用于目标检测和图像分割等领域。它是由Ross Girshick等人提出的一篇论文”Focal Loss for Dense Object Detection”中提出的。</p><p>在目标检测和图像分割等任务中，常常会遇到类别不平衡的情况，即某些类别的样本数量远多于其他类别的样本数量。这种情况下，传统的交叉熵损失函数会将大量的权重分配给数量较多的类别，导致少量的类别被忽视，从而影响模型的性能。</p><p>Focal Loss通过引入一个平衡因子，来缓解类别不平衡问题，该平衡因子主要通过减小易分类样本的权重来实现，同时增加难分类样本的权重。具体来说，Focal Loss对于易分类的样本，降低了它们的权重，从而减少了其对损失函数的贡献；对于难分类的样本，增加了它们的权重，从而增加了其对损失函数的贡献。这种方法可以使模型更加关注难分类样本，提高模型的性能。</p><p>在目标检测和图像分割等领域，Focal Loss已经被广泛应用于各种深度学习模型中，并取得了显著的性能提升。</p><h2>三、FPN模型和Focal Loss 对 anchor-free的影响</h2><p>PN模型和Focal Loss对anchor-free目标检测的影响如下：</p><ol><li>FPN模型：FPN模型可以生成不同尺度的特征金字塔，其中较低层级的金字塔主要用于检测较小的目标，而较高层级的金字塔主要用于检测较大的目标。对于anchor-free目标检测，FPN模型可以提供多尺度的特征金字塔，有利于检测不同大小的目标。因此，FPN模型在anchor-free目标检测中也被广泛应用。</li><li>Focal Loss：Focal Loss对于易分类的样本，降低了它们的权重，从而减少了其对损失函数的贡献；对于难分类的样本，增加了它们的权重，从而增加了其对损失函数的贡献。在anchor-free目标检测中，Focal Loss可以使模型更加关注难以分类的目标，提高模型的性能。</li></ol><p>综上所述，FPN模型和Focal Loss都可以对anchor-free目标检测产生积极的影响。在实际应用中，它们经常被同时应用于anchor-free目标检测中，以提高检测的准确率和效率。</p><h2>四、为什么有了FPN模型和Focal Loss ， anchor-free越来越受欢迎</h2><p>有了FPN模型和Focal Loss，anchor-free目标检测越来越受欢迎，主要有以下原因：</p><ol><li>更加灵活：相比于传统的anchor-based目标检测方法，anchor-free方法不需要提前定义一组锚点，因此更加灵活。这意味着anchor-free方法可以应用于各种不同的目标检测场景，例如目标大小和形状不确定的情况。</li><li>更高效：在anchor-based方法中，每个锚点都需要进行预测，因此会产生大量的冗余计算。而anchor-free方法则没有这个问题，因为它只需要对特征图中的像素进行分类和回归。这使得anchor-free方法在计算效率方面更有优势。</li><li>更加准确：FPN模型可以生成多尺度的特征金字塔，有利于检测不同大小的目标。Focal Loss可以使模型更加关注难以分类的目标，提高模型的性能。这些技术的应用使得anchor-free方法在准确率方面越来越接近传统的anchor-based方法，甚至超过了一些基于锚点的方法。</li></ol><p>综上所述，FPN模型和Focal Loss的出现，使得anchor-free方法在目标检测领域受到了越来越多的关注和应用。同时，随着深度学习技术的不断发展和优化，相信anchor-free方法将会在未来的目标检测领域中发挥越来越重要的作用。</p><h2>五、anchor-based目标检测方法可以分为one-stage和two-stage方法，请分别详细描述这两种方法，讨论他们的优点和缺点</h2><p>目标检测是计算机视觉领域的一个重要研究方向，其中anchor-based方法是常用的目标检测方法之一。它可以分为one-stage和two-stage方法，下面分别对这两种方法进行详细描述，并讨论它们的优缺点。</p><p><h3>1、One-stage方法</h3><br>One-stage方法是指在单个网络中完成目标检测的方法，最典型的代表是YOLO（You Only Look Once）和SSD（Single Shot MultiBox Detector）等。</p><p><h3>YOLO</h3><br>YOLO使用一个单独的卷积神经网络，直接对整张图片进行目标检测，具体流程如下：</p><ol><li>将输入图像划分为SxS个网格，每个网格负责预测B个边界框和C个类别概率。</li><li>对于每个边界框，预测其包含目标的置信度，以及其相对于该网格的坐标和大小。</li><li>最后根据置信度和类别概率筛选出目标并进行定位。</li></ol><p><h3>SSD</h3><br>SSD也是一种单阶段的目标检测方法，其主要思想是使用多尺度的卷积特征图进行检测。具体流程如下：</p><ol><li>对输入图像使用多尺度的卷积网络提取特征，得到多个不同大小的特征图。</li><li>对每个特征图，通过卷积层和预测层进行目标检测，得到每个位置的类别概率和边界框偏移量。</li><li>将所有特征图的预测结果合并，并通过非极大值抑制（NMS）筛选出目标。</li></ol><p><h4>One-stage方法的优点</h4></p><ol><li>实时性高：由于One-stage方法只需要对图像进行一次前向计算，因此它们的处理速度比Two-stage方法更快，适用于实时的目标检测场景。</li><li>目标检测精度高：One-stage方法可以通过增加网络深度、调整网络结构和损失函数等手段来提高检测精度，已经可以达到很高的性能。</li></ol><p><h4>One-stage方法的缺点</h4></p><ol><li>对小目标的检测不够准确：One-stage方法在检测小目标时，由于缺少多尺度特征金字塔和先验框等信息，容易出现误检或漏检的问题。</li><li>目标定位精度低：One-stage方法对于目标的定位精度不如Two-stage方法，因为它们缺乏ROI池化层或者其他明确的目标定位策略。</li></ol><p><h3>2、Two-stage方法</h3><br>Two-stage方法是指目标检测分为两个阶段进行，第一个阶段是在图像中提取一些候选区域，第二个阶段是对这些候选区域进行分类和定位，最典型的代表是Faster R-CNN和Mask R-CNN等。</p><p><h4>Faster R-CNN</h4><br>Faster R-CNN主要包含两个模块：Region Proposal Network（RPN）和Fast R-CNN。</p><ol><li>RPN：对输入图像进行卷积特征提取，并在每个特征点处产生多个不同尺寸和长宽比的锚点框（anchor box）。</li><li>Fast R-CNN：将RPN提取的锚点框作为候选区域，通过ROI pooling层将每个候选区域映射到固定大小的特征图上，再通过全连接层进行分类和回归。</li><li>最后通过非极大值抑制筛选出最终的目标框。</li></ol><p><h4>Mask R-CNN</h4><br>Mask R-CNN是在Faster R-CNN的基础上增加了一个Mask预测分支，可以同时进行目标检测和语义分割。</p><ol><li>RPN：同Faster R-CNN。</li><li>RoIAlign：对候选区域进行更精确的特征映射，得到每个候选区域的固定大小特征图。</li><li>分类和回归：同Faster R-CNN。</li><li>Mask分支：在每个RoI区域上进行预测，生成每个像素的目标掩码。</li></ol><p><h4>Two-stage方法的优点</h4></p><ol><li>对小目标检测更准确：Two-stage方法通过金字塔特征提取、RPN等策略可以生成不同尺度的候选区域，能够更准确地检测小目标。</li><li>目标定位精度更高：Two-stage方法在RoI pooling层等环节对目标进行定位，可以精确地定位目标的位置。</li></ol><p><h4>Two-stage方法的缺点</h4></p><ol><li>实时性较低：Two-stage方法需要对图像进行两次前向计算，速度较慢，适用于对实时性要求不高的场景。</li><li>设计和调参难度较大：Two-stage方法需要进行目标检测和提取候选区域两个任务的优化，需要在设计和调参上付出更多的努力。</li></ol><p>总的来说，One-stage方法适用于实时性要求高，目标检测精度要求适中的场景，Two-stage方法适用于对目标检测精度要求高，实时性要求适中的场景。</p><h2>六、Anchor-free detectors directly find objects without preset anchors in two different ways.</h2><p>Anchor-free目标检测器直接在图像中寻找物体而不需要预设锚点，可以分为两种不同的方式：</p><ol><li>CenterNet</li></ol><p>CenterNet直接在图像中寻找物体中心点，并以此为基础进行目标检测。具体来说，CenterNet使用高斯热力图来表示目标中心点，然后通过回归网络来输出目标框的位置和尺寸，并进行目标分类。在预测过程中，CenterNet将每个像素点都视为候选中心点，通过筛选出具有高响应值的中心点来实现目标检测。</p><ol><li>FCOS</li></ol><p>FCOS（Fully Convolutional One-Stage）是一种全卷积的、基于中心点的单阶段目标检测器。FCOS通过预测每个像素点对于物体中心点的距离和偏移量，来确定目标的位置和尺寸。同时，FCOS还引入了一个特征金字塔网络来处理不同尺度的特征图，并通过分类和回归来预测目标类别和边界框。与CenterNet不同，FCOS使用密集采样来获得足够多的正负样本，并且在训练过程中使用了一种新的损失函数来平衡不同大小的目标之间的重要性。</p><p>总的来说，CenterNet和FCOS都是基于中心点的Anchor-free目标检测器，它们不需要预设的锚点，具有更好的可解释性和泛化能力，但由于需要对每个像素点进行处理，因而在速度上可能有所欠缺。</p><h2>七、We use the ImageNet pretrained ResNet-50 with 5-level feature pyramid structure as the backbone.这句话中ResNet-50是用来干嘛的呢</h2>这句话中提到的ResNet-50是作为目标检测模型的骨干网络(backbone)来使用的。骨干网络负责从输入图像中提取特征，为后续的目标检测任务提供丰富的、具有多尺度特征的表示。在这篇论文中，作者使用了ImageNet预训练的ResNet-50作为骨干网络，通过5-level feature pyramid structure生成5个不同尺度的特征图，用于目标检测任务的实现。预训练的ResNet-50具有很强的图像特征提取能力，可以有效地提高目标检测的准确率和召回率。<h2>八、During training,we resize the input images to keep their shorter side being 800 and their longer side less or equal to 1, 333. 这句话是什么意思</h2>这句话的意思是，在训练过程中，作者将输入的图像调整大小，使它们的短边为800个像素，并且长边不超过1333个像素。这是因为在目标检测任务中，输入图像的大小对模型的精度和速度都有一定的影响。为了兼顾模型的精度和速度，通常需要对输入图像进行预处理，使它们的大小符合一定的规范。在这里，作者规定了一个较小的短边800像素，可以有效地控制模型的计算量，并且保证了模型能够检测到较小的目标。同时，由于较大的输入图像可能会降低模型的速度和精度，因此作者限制了长边的大小不超过1333个像素，以避免输入图像过大。<h2>九、After that, we use the preset score 0.05 to filter out plenty of background bounding boxes, and then output the top 1000 detections per feature pyramid这一步有什么作用。 preset score 0.05是什么意思</h2>这句话中的 "preset score 0.05" 指的是预设的置信度阈值，即筛选出置信度大于0.05的边界框。在目标检测中，置信度分数是指模型对于每个边界框所估计的该边界框包含目标的概率值，一般为0到1之间的实数。在这个阶段，筛选出置信度高于0.05的边界框可以去除很多背景框和错误的边界框，以保留置信度高、更有可能是真实目标的边界框。同时输出每个特征金字塔层级的前1000个检测结果，可以得到更多的目标检测结果，以提高模型的召回率，即检测到更多的真实目标。在目标检测任务中，置信度分数的计算方式通常由网络架构和损失函数共同决定。通常情况下，模型会为每个边界框输出一个包含两个值的向量，即分类得分和回归坐标值。分类得分表示该边界框属于目标类别的概率值，回归坐标值表示该边界框相对于anchor的坐标偏移值。在RetinaNet中，每个anchor对应的回归坐标值有4个，分别对应着边界框的左上角和右下角两个点的x,y坐标。模型会利用这些分类得分和回归坐标值来计算每个边界框的置信度分数，一般使用以下公式：score = cls_score * max(0, 1 - L1_distance(gt_box, pred_box) / w * h)其中，cls_score表示该边界框属于目标类别的分类得分，gt_box和pred_box分别表示真实边界框和预测边界框，L1_distance表示两个边界框之间的L1距离，w和h表示anchor的宽和高。这个公式的含义是，置信度分数由分类得分和预测框与真实框之间的重合程度共同决定，重合程度越高，置信度分数越大。最终，每个边界框的置信度分数会与预设的置信度阈值进行比较，保留分数大于阈值的边界框。<h2>十一、the Non-Maximum Suppres-sion (NMS)</h2>在目标检测中，同一个物体可能被不同的锚框（anchor box）所检测到，这时需要通过非极大值抑制（Non-Maximum Suppression，NMS）来去除重叠的框，保留置信度最高的那个框。具体来说，NMS的流程是这样的：1. 对所有的检测框按照置信度从高到低进行排序；2. 取出置信度最高的检测框，并将其加入最终的检测结果列表中；3. 对剩余的检测框进行以下操作：- 计算当前检测框与最终检测结果列表中已有框的重叠程度（一般使用IoU，即交并比）；- 如果重叠程度大于预设阈值，将此检测框舍去；- 如果重叠程度小于等于预设阈值，将此检测框加入最终检测结果列表中。1. 重复步骤2和3，直到所有检测框都被处理完毕。最终得到的结果是保留了置信度最高的框并且去除了与其重叠度较高的框的结果列表。<h2>十二、AP performance</h2>在目标检测中，AP是Average Precision的缩写，是一个用来衡量检测器检测精度的指标。它的计算方法是在不同的置信度阈值下，计算每个类别的precision和recall，并通过不同阈值下的面积累加得到平均准确率。AP值越高，说明检测器的性能越好。在目标检测中，AP是衡量检测算法性能的一个常用指标。对于每一个类别，AP值是通过计算precision-recall曲线下面积得到的，表示模型对该类别的检测能力。precision表示预测为该类别的bounding box中，有多少是正确的，而recall表示该类别的所有目标物体中，有多少被检测出来了。为了计算precision-recall曲线，我们需要首先对预测的bounding box按照置信度从高到低排序，然后在不同置信度阈值下计算precision和recall，然后将precision和recall的值绘制成曲线。AP值就是precision-recall曲线下面积的大小，值域从0到1。因为在不同的置信度阈值下，precision和recall的值会有所变化，所以AP值是一个综合了不同置信度下的检测性能的指标。<h2>十三、Furthermore, some new improvements have been made for FCOS including moving centerness to regression branch, using GIoU loss function and normalizing regression targets by corresponding strides.</h2>- Moving centerness to regression branch：在传统的FCOS中，中心度（用于度量目标距离特征图中心的距离）是与分类分支并行的单独分支。在这个改进中，中心度被移动到了回归分支，与边界框的偏移和宽高一起进行预测，从而可以共享更多的特征信息。- Using GIoU loss function：传统的IoU损失函数通常用于度量预测边界框和实际边界框之间的重叠程度。然而，IoU损失没有考虑边界框之间的间隙，而GIoU损失将这些间隙考虑在内，可以更好地反映边界框的拟合情况。- Normalizing regression targets by corresponding strides.：传统的FCOS中，回归目标是以像素为单位计算的。这个改进将回归目标标准化为特征图上对应的步长，使得不同尺度的目标具有相同的回归范围。<h2>十四、However, part of the AP gap between the anchor-based detector (32.5%) and the anchor-free detector (37.8%) results from some universal improvements that are proposed or used in FCOS, such as adding GroupNorm in heads, using the GIoU  regression loss function, limiting positive samples in the ground-truth box [56], introducing the centerness branch [56] and adding a trainablescalar [56] for each level feature pyramid.</h2><p>这句话是在讨论 anchor-based 检测器和 anchor-free 检测器之间性能差距的原因。作者指出，这两种检测器的性能差距不完全是由于 anchor-free 检测器的优越性导致的，而是由于在 anchor-free 检测器中使用了一些新的改进方法，这些方法也可以应用于 anchor-based 检测器中。</p><p>这些改进方法对于 anchor-based 和 anchor-free 检测器都有帮助，并且有助于缩小两者之间的性能差距。</p><ol><li>添加 GroupNorm [62]：传统的 BatchNorm 是在 batch 维度上进行标准化的，而 GroupNorm 是在 channel 维度上进行标准化的。在目标检测任务中，batch size 很小，因此使用 GroupNorm 可以更好地适应小批量数据。</li><li>使用 GIoU [48] 回归损失函数：GIoU 是一种与 IOU 相关的评估指标，它可以更准确地评估边界框之间的距离。使用 GIoU 作为回归损失函数可以提高模型的精度。</li><li>限制正样本在 ground-truth 区域内：在训练过程中，限制正样本在 ground-truth 区域内可以更好地训练模型，避免正样本落在背景区域。</li><li>引入 centerness 分支：centerness 是指目标中心点与边界框中心点之间的距离，引入 centerness 分支可以更好地度量目标的位置。</li><li>添加每个级别的特征金字塔的可训练标量：为每个级别的特征金字塔添加可训练标量可以提高模型的表现能力。</li></ol><p>综上所述，这些改进方法可以显著提高目标检测模型的性能，从而缩小锚点型检测器和非锚点型检测器之间的差距。</p><p><h2>十五、spatial and scale dimension </h2><br>在目标检测中，一张图像通常会被分成多个区域，每个区域都会被生成多个大小不同、长宽比不同的 anchor boxes。空间维度指的是这些区域，尺度维度指的是不同大小、长宽比的 anchor boxes。</p><p><h2>十六、ATSS中的超参数k是什么意思 </h2><br>在 ATSS 算法中，超参数 k 表示需要选择多少个与目标框的重叠度最高的锚框作为正样本。具体来说，对于每个目标框，ATSS 算法会计算其与所有锚框的 IoU 值，然后根据这些 IoU 值从高到低排序，并选择与目标框 IoU 最高的前 k 个锚框作为正样本。k 是一个预先设定的常数值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDE求解</title>
      <link href="/2023/03/15/Diffusion%20-%20%E5%89%AF%E6%9C%AC%20(3)/"/>
      <url>/2023/03/15/Diffusion%20-%20%E5%89%AF%E6%9C%AC%20(3)/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/06/pldDhQfv1eX5NrI.jpg" alt="扫描全能王 2023-05-06 23.12_1.jpg"></p><p><img src="https://s2.loli.net/2023/05/06/oxiE3I6zm9gF5aS.jpg" alt="扫描全能王 2023-05-06 23.12_2.jpg"></p><p><img src="https://s2.loli.net/2023/05/06/AnqSxRZIBhOVUKN.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDIM</title>
      <link href="/2023/03/10/Diffusion%20-%20%E5%89%AF%E6%9C%AC%20(2)/"/>
      <url>/2023/03/10/Diffusion%20-%20%E5%89%AF%E6%9C%AC%20(2)/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/06/y5cFZKpUETj2wkP.jpg" alt="扫描全能王 2023-05-06 21.55_4.jpg"></p><p><img src="https://s2.loli.net/2023/05/06/apkNQ3vxnuLjtWo.jpg" alt="扫描全能王 2023-05-06 21.55_5.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffusion (贝叶斯)</title>
      <link href="/2023/03/10/Diffusion%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2023/03/10/Diffusion%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/06/OVnQ94CUDc8sxhK.jpg" alt="扫描全能王 2023-05-06 21.55_2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffusion （拆楼建楼）</title>
      <link href="/2023/03/08/Diffusion/"/>
      <url>/2023/03/08/Diffusion/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/05/06/dmOEHuNVz2KYnLc.jpg" alt="扫描全能王 2023-05-06 21.55_1.jpg"></p><p><img src="https://s2.loli.net/2023/05/06/HfTnkoX3BdP2ryO.jpg" alt="扫描全能王 2023-05-06 21.55_3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/04/%E7%AE%97%E6%B3%953/"/>
      <url>/2023/03/04/%E7%AE%97%E6%B3%953/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数二分算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数二分算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度加法</span></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度乘低精度</span></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度除以低精度</span></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/blog/content/277/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维前缀和</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维差分</span></span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维差分</span></span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位运算</span></span><br><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针算法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/277/">https://www.acwing.com/blog/content/277/</a><br>来源：AcWing</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Attention学习机制数学推导</title>
      <link href="/2023/03/02/Attention%E5%AD%A6%E4%B9%A0%E6%9C%BA%E5%88%B6%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
      <url>/2023/03/02/Attention%E5%AD%A6%E4%B9%A0%E6%9C%BA%E5%88%B6%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>注意力机制是一种在深度学习中常用的机制，可以在处理变长输入序列时，让模型更加关注与当前任务相关的信息。下面是注意力机制的数学证明。</p><p>假设我们有一个输入序列$x = (x_1, x_2, …, x_T)$，其中每个$x_t$都是一个向量，$y$是输出序列。我们需要在每个时间步$t$选择适当的$x_t$来计算$y_t$。注意力机制的思想是，对于每个时间步$t$，我们计算出$x_t$和所有$x_i$之间的相似度得分，然后根据这些得分来给每个$x_i$分配一个权重，最终使用加权平均的方法来计算$y_t$。</p><p>具体来说，我们可以使用一个查询向量$q_t$来度量$x_t$和所有$x_i$之间的相似度。一种常用的计算方式是点积计算：</p><script type="math/tex; mode=display">\text{score}(q_t, x_i) = q_t^Tx_i</script><p>接着，我们可以将得分进行归一化，得到一个权重向量$\alpha<em>t$，其中$\alpha</em>{t,i}$表示在计算$y_t$时应该分配给$x_i$的权重：</p><script type="math/tex; mode=display">\alpha_{t,i} = \frac{\exp(\text{score}(q_t, x_i))}{\sum_{j=1}^{T}\exp(\text{score}(q_t, x_j))}</script><p>最后，我们可以使用加权平均的方法来计算$y_t$：</p><script type="math/tex; mode=display">y_t = \sum_{i=1}^{T}\alpha_{t,i}x_i</script><p>注意力机制的数学证明主要是通过反向传播算法来训练模型。假设$L$是损失函数，我们需要计算$L$对$q_t$和$x_i$的梯度。根据链式法则，我们可以将$L$对$x_i$的梯度表示为：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial x_i} = \sum_{t=1}^{T}\frac{\partial L}{\partial y_t}\alpha_{t,i}</script><p>这意味着，对于每个$x_i$，我们可以通过对所有$y_t$进行加权求和，来计算$L$对$x_i$的梯度。类似地，我们可以将$L$对$q_t$的梯度表示为：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial q_t} = \sum_{i=1}^{T}\frac{\partial L}{\partial y_t}\frac{\partial y_t}{\partial \alpha_{t,i}}\frac{\partial \alpha_{t,i}}{\partial q_t}</script><p>其中，$\frac{\partial y<em>t}{\partial \alpha</em>{t,i}}$表示$y<em>t$对$\alpha</em>{t,i}$的梯度，可以通过链式法则计算得出：</p><script type="math/tex; mode=display">\frac{\partial y_t}{\partial \alpha_{t,i}} = x_i</script><p>$\frac{\partial \alpha_{t,i}}{\partial q_t}$表示$\</p>]]></content>
      
      
      <categories>
          
          <category> RNN  VS  Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法之排序</title>
      <link href="/2023/01/17/%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/17/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>,x=q[i+j&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(x&gt;q[i]);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(x&lt;q[j]);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">int</span> tmp[];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;= mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])tmp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)tmp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=r)tmp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)q[i]=tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快排 </tag>
            
            <tag> 归并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法之高精度加减乘除法</title>
      <link href="/2023/01/17/%E7%AE%97%E6%B3%952/"/>
      <url>/2023/01/17/%E7%AE%97%E6%B3%952/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">高精度加法</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a , b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">高精度减法</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A&gt;=B ?</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=b[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">sub</span>(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=A[i]-t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>())t=t-B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()!=<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b))&#123;</span><br><span class="line">        <span class="keyword">auto</span> C=<span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> C=<span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法之二分</title>
      <link href="/2023/01/17/%E7%AE%97%E6%B3%951/"/>
      <url>/2023/01/17/%E7%AE%97%E6%B3%951/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两种整数二分方法</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浮点数二分</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整数二分 </tag>
            
            <tag> 浮点数二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kullback-Leibler(KL)散度</title>
      <link href="/2022/12/30/KL%E6%95%A3%E5%BA%A6/"/>
      <url>/2022/12/30/KL%E6%95%A3%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1><font face='楷体'>1.概要</font></h1><h3><font face='楷体'>在这篇文章中，将探讨一种比较两个概率分布的方法，称为Kullback-Leibler散度(通常简称为KL散度)。通常在概率和统计中，我们会用更简单的近似分布来代替观察到的数据或复杂的分布。KL散度帮助我们衡量在选择近似值时损失了多少信息。</font></h3><h1><font face='楷体'>2.公式</font></h1><h3><font face='楷体'>KL散度起源于信息论。信息论的主要目标是量化数据中有多少信息。信息论中最重要的指标称为熵，通常表示为H。概率分布的熵的定义是：</font></h3>$$H=-\sum_{i=0}^nlogp(x_i)$$<h3><font face='楷体'>如果在我们的计算中我们使用log2，我们可以把熵解释为“我们编码信息所需要的最小比特数”。在这种情况下，根据我们的经验分布，信息将是每个牙齿计数的观察结果。根据我们观察到的数据，我们的概率分布的熵为3.12比特。比特的数目告诉我们，在单一情况下，我们平均需要多少比特来编码我们将观察到的牙齿数目。</font></h3><h3><font face='楷体'>熵没有告诉我们可以实现这种压缩的最佳编码方案。信息的最佳编码是一个非常有趣的主题，但对于理解KL散度而言不是必需的。熵的关键在于，只要知道所需位数的理论下限，我们就可以准确地量化数据中有多少信息。现在我们可以对此进行量化，当我们将观察到的分布替换为参数化的近似值时，我们丢失了多少信息。</font></h3><h1><font face='楷体'>使用KL散度测量丢失的信息</font></h1><h3><font face='楷体'>Kullback-Leibler散度只是对我们的熵公式的略微修改。不仅仅是有我们的概率分布p，还有上近似分布q。然后，我们查看每个log值的差异：</font></h3><script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{i=1}^Np(x_i)(log\frac{p(x_i)}{q(x_i)})</script><h3><font face='楷体'>本质上，我们用KL散度看的是对原始分布中的数据概率与近似分布之间的对数差的期望。再说一次，如果我们考虑log2，我们可以将其解释为“我们预计有多少比特位的信息丢失”。我们可以根据期望重写公式：</font></h3><script type="math/tex; mode=display">D_{KL}(p||q)=E[log\frac{p(x_i)}{q(x_i)}]</script><h3><font face='楷体'>利用KL散度，我们可以精确地计算出当我们近似一个分布与另一个分布时损失了多少信息。</font></h3><h1><font face='楷体'>3.注意:KL散度不是距离</font></h1><h3><font face='楷体'>将KL散度视为距离度量可能很诱人，但是我们不能使用KL散度来测量两个分布之间的距离。这是因为KL散度不是对称的。</font></h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN数学推导</title>
      <link href="/2022/12/10/RNN%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/"/>
      <url>/2022/12/10/RNN%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>循环神经网络（RNN）是一种特殊类型的神经网络，它在输入之间保持一种状态，并使用该状态来处理序列数据。下面是RNN的数学推导。</p><p>假设我们有一个输入序列$x = (x_1, x_2, …, x_T)$，其中每个$x_t$都是一个向量，$y$是输出序列，$h_t$是RNN在处理$x_t$时的隐藏状态。RNN的隐藏状态$h_t$通过以下递归方式计算：</p><script type="math/tex; mode=display">h_t = f(Ux_t + Wh_{t-1})</script><p>其中，$U$和$W$是权重矩阵，$f$是激活函数，通常是tanh或ReLU。$h_0$通常被初始化为全零向量。</p><p>在计算完所有隐藏状态后，我们可以通过一个输出层来预测输出序列$y$，该输出层可以是全连接层，也可以是softmax层，具体取决于任务的要求。例如，在情感分类任务中，我们可能只需要一个全连接层来预测情感标签。</p><p>输出层的计算方式如下：</p><script type="math/tex; mode=display">y_t = g(Vh_t)</script><p>其中，$V$是权重矩阵，$g$是激活函数。在分类任务中，$g$通常是softmax函数。</p><p>现在我们可以通过反向传播算法来训练RNN，其中损失函数$L$定义为预测输出$y$与实际输出$\hat{y}$之间的交叉熵：</p><script type="math/tex; mode=display">L = -\sum_{t=1}^{T}\hat{y}_t\log(y_t)</script><p>在反向传播过程中，我们需要计算损失函数对权重矩阵$U$、$W$和$V$的梯度。假设$\delta_t$表示损失函数对$h_t$的梯度，则：</p><script type="math/tex; mode=display">\delta_T = \frac{\partial L}{\partial y_T} \odot g'(Vh_T)</script><script type="math/tex; mode=display">\delta_t = \left(\frac{\partial L}{\partial y_t} + \frac{\partial L}{\partial h_{t+1}}\frac{\partial h_{t+1}}{\partial h_t}\right) \odot f'(Ux_t + Wh_{t-1})</script><p>其中，$\odot$表示向量点积，$g’$和$f’$分别是$g$和$f$的导数。我们可以使用这些梯度来更新权重矩阵，例如：</p><script type="math/tex; mode=display">V \leftarrow V - \eta\sum_{t=1}^{T}\delta_t h_t^T</script><script type="math/tex; mode=display">U \leftarrow U - \eta\sum_{t=1}^{T}\delta_t x_t^T</script><script type="math/tex; mode=display">W \leftarrow W - \eta\sum_{t=1}^{T}\delta_t h_{t-1}^T</script><p>其中，$\eta$是学习率。这些更新将使网络逐步调整权重，以最小化损失函数并提高预测精度。</p>]]></content>
      
      
      <categories>
          
          <category> RNN  VS  Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题</title>
      <link href="/2022/12/10/%E5%88%B7%E9%A2%98/"/>
      <url>/2022/12/10/%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="D:\text\BlogGit\image\1.jpg" alt=""></p><p><img src="D:\text\BlogGit\image\1.1.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace  std;</span><br><span class="line"><span class="built_in">int</span> <span class="type">List</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">int</span> w[<span class="number">1005</span>];//价值</span><br><span class="line"><span class="built_in">int</span> v[<span class="number">1005</span>];//体积</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    <span class="built_in">int</span> N,V;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    w[<span class="number">0</span>]=v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;V+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v[i]&gt;j)&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]=<span class="type">List</span>[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]=<span class="built_in">max</span>(<span class="type">List</span>[i-<span class="number">1</span>][j],<span class="type">List</span>[i-<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="type">List</span>[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\text\BlogGit\image\1.2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> N,V;</span><br><span class="line"><span class="built_in">int</span> v[<span class="number">1010</span>],val[<span class="number">1010</span>];</span><br><span class="line"><span class="built_in">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j&lt;=V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];//继承上一个背包</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])</span><br><span class="line">            &#123;  //完全背包状态转移方程</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i-<span class="number">1</span>][j],dp[i][j-v[i]]+val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(<span class="string">&quot;%d&quot;</span>,dp[N][V]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\text\BlogGit\image\1.3.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace  std;</span><br><span class="line"><span class="built_in">int</span> <span class="type">List</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">int</span> w[<span class="number">1005</span>];//价值</span><br><span class="line"><span class="built_in">int</span> v[<span class="number">1005</span>];//体积</span><br><span class="line"><span class="built_in">int</span> s[<span class="number">1005</span>];//件数</span><br><span class="line"><span class="built_in">int</span> N,V;</span><br><span class="line"><span class="built_in">int</span> k;</span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    w[<span class="number">0</span>]=v[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v[i],&amp;w[i],&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(<span class="type">List</span>,<span class="number">0</span>,sizeof(<span class="type">List</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;V+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            k=<span class="built_in">min</span>(s[i],j/v[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> t=<span class="number">0</span>;t&lt;=k;t++)&#123;</span><br><span class="line">                <span class="type">List</span>[i][j]= <span class="built_in">max</span>(<span class="type">List</span>[i][j],<span class="type">List</span>[i-<span class="number">1</span>][j-t*v[i]]+t*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="type">List</span>[N][V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（一）</title>
      <link href="/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3>    综述</h3><p> 链接：<a href="https://pan.baidu.com/s/10DHtZbPnH2SsuaPaZcIuLQ">https://pan.baidu.com/s/10DHtZbPnH2SsuaPaZcIuLQ</a><br>提取码：tf9p</p><p> 目前，大数据越来越多的和人工智能关联起来。而人工智能发展迅猛，在多个领域取得了巨大的成就，比如自然语言处理，图像处理，数据挖掘等。而本文正是诞生在如此环境下。首先本文基于Scrapy框架爬取豆瓣短评数据并进行清洗，然后通过hadoop+spark+mongodb完全分布式部署框架来进行数据的分类与采集，最终我们得到了比例为8:1:1的训练集、测试集和验证集。并在此基础上，我们调用了TextCNN、TextRCNN、TextRNN_Att、FastText、Transformer五大文本分类模型训练豆瓣Top250的短评，最后训练出五个可以通过短评来判断电影种类的模型，我们分别计算这五个模型的各个参数，最终选择一个较好的模型——TextRCNN模型来作为我们的后端模型。我们使用Fastapi来进行前后端分离的web应用。同时，我们在此基础上，为了能够让使用者能够仔细观察一个电影的具体情况，找到自己喜欢的电影，我们建立了基于余弦相似度的搜索模型，达到了模糊搜索的功能，并将其与前端相连，形成我们整个完整的项目。</p><h3>  研究背景</h3><p>目前，大数据越来越多的和人工智能关联起来。而人工智能发展迅猛，在多个领域取得了巨大的成就，比如自然语言处理，图像处理，数据挖掘等。文本挖掘是其中的一个研究方向。根据维基百科的定义，文本挖掘也叫文本数据挖掘，或是文本分析，是从文本中获取高质量信息的过程，典型的任务有文本分类、自动问答、情感分析、机器翻译等。文本分类是将数据分成预先定义好的类别，一般流程为：1. 预处理，比如分词，去掉停用词；2. 文本表示及特征选择；3. 分类器构造；4. 分类器根据文本的特征进行分类；5. 分类结果的评价。&lt;/br&gt;<br>由于近年来人工智能的快速发展，文本分类技术已经可以很好的确定一个未知文档的类别，而且准确度也很好。借助文本分类，可以方便进行海量信息处理，节约大量的信息处理费用。广泛应用于过滤信息，组织与管理信息，数字图书馆、垃圾邮件过滤等社会生活的各个领域。&lt;/br&gt;</p><p>同时，随着网络的发展，电影事业的发展越来越繁荣，其的种类也越来越繁多。目前电影主要可以分为动作、喜剧、犯罪、爱情、科幻、战争等多种类型。而不同类型的电影，读者关于它们的评论却大相径庭。在基于hadoop+spark完全分布式平台的本次项目，我们主要针对于犯罪、喜剧、科幻和战争四种类型差异较大的电影，采用爬虫爬取到的不同类型的电影的影评作为数据集，运用TextCNN、TextRCNN、TextRNN_Att、FastText、Transformer五种文本分类模型来进行训练，最后选取一个预测结果结果最好的模型加载作为我们的fastapi+webUI实现的后端。最后因为电影在大数据报中仅能展示部分，而不能展示其的具体介绍。因此我又打算通过基于余弦相似度的分类算法来做一个小型的搜索系统。&lt;/br&gt;<br>以上就是我项目的研究背景。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（二）:框架介绍</title>
      <link href="/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/"/>
      <url>/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/</url>
      
        <content type="html"><![CDATA[<h3>Scrapy框架</h3><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><p>所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专业的描述就是，抓取特定网站网页的HTML数据。抓取网页的一般方法是，定义一个入口页面，然后一般一个页面会有其他页面的URL，于是从当前页面获取到这些URL加入到爬虫的抓取队列中，然后进入到新页面后再递归的进行上述的操作，其实说来就跟深度遍历或广度遍历一样。</p><p>Scrapy 使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。</p><h3>Hadoop</h3><h4>背景</h4><p>Hadoop是一个由Apache基金会所开发的<a href="https://baike.baidu.com/item/分布式系统/4905336?fromModule=lemma_inlink">分布式系统</a>基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个<a href="https://baike.baidu.com/item/分布式文件系统/1250388?fromModule=lemma_inlink">分布式文件系统</a>（ Distributed File System），其中一个组件是<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>（Hadoop Distributed File System）。HDFS有高<a href="https://baike.baidu.com/item/容错性/9131391?fromModule=lemma_inlink">容错性</a>的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问<a href="https://baike.baidu.com/item/应用程序/5985445?fromModule=lemma_inlink">应用程序</a>的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）<a href="https://baike.baidu.com/item/POSIX/3792413?fromModule=lemma_inlink">POSIX</a>的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>和<a href="https://baike.baidu.com/item/MapReduce/133425?fromModule=lemma_inlink">MapReduce</a>。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。</p><h4>优点</h4><p>Hadoop是一个能够让用户轻松架构和使用的分布式计算平台。用户可以轻松地在Hadoop上开发和运行处理海量数据的应用程序。它主要有以下几个优点：&lt;/br&gt;<br>1.高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖&lt;/br&gt;。&lt;/br&gt;<br>2.高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。&lt;/br&gt;<br>3.高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。&lt;/br&gt;<br>4.高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。&lt;/br&gt;<br>5.低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。&lt;/br&gt;<br>Hadoop带有用Java语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如C++。</p><h3>Spark </h3><p>   Spark使用Scala语言进行实现，它是一种面向对象、函数式编程语言，能够像操作本地集合对象一样轻松地操作分布式数据集，具有以下特点。<br>1.运行速度快：Spark拥有DAG执行引擎，支持在内存中对数据进行迭代计算。官方提供的数据表明，如果数据由磁盘读取，速度是Hadoop MapReduce的10倍以上，如果数据从内存中读取，速度可以高达100多倍。<br>2.易用性好：Spark不仅支持Scala编写应用程序，而且支持Java和Python等语言进行编写，特别是Scala是一种高效、可拓展的语言，能够用简洁的代码处理较为复杂的处理工作。&lt;/br&gt;<br>3.通用性强：Spark生态圈即BDAS（伯克利数据分析栈）包含了Spark Core、Spark SQL、Spark Streaming、MLLib和GraphX等组件，这些组件分别处理Spark Core提供内存计算框架、SparkStreaming的实时处理应用、Spark SQL的即席查询、MLlib或MLbase的机器学习和GraphX的图处理。<br>4.随处运行：Spark具有很强的适应性，能够读取HDFS、Cassandra、HBase、S3和Techyon为持久层读写原生数据，能够以Mesos、YARN和自身携带的Standalone作为资源管理器调度job，来完成Spark应用程序的计算。</p><h3>Mongodb</h3><h2>背景介绍</h2><p>MongoDB是一个基于分布式文件存储的数据库。</p><p>由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><h2>业务场景</h2><p>传统的关系型数据库(如MySQL)，在数据操作的三高需求以及应对Web2.0的网站需求面前，显得力不从心，而 MongoDB可应对“三高“需求：</p><p>High performance：对数据库高并发读写的需求</p><p>Huge Storage：对海量数据的高效率存储和访问的需求</p><p>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</p><p>具体应用场景：</p><p>社交场景，使用 MongoDB存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。</p><p>游戏场景，使用 MongoDB存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、高效率存储和访问。</p><p>物流场景，使用 MongoDB存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</p><p>物联网场景，使用 MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。</p><p>视频直播，使用 MongoDB存储用户信息、点赞互动信息等。</p><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高</p><p>对于这样的数据，我们更适合使用 MongoDB来实现数据的存储。</p><h2>特点</h2><p>（1）高性能</p><p>MongoDB提供高性能的数据持久性。特别是，</p><p>对嵌入式数据模型的支持减少了数据库系统上I/O活动。</p><p>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种O2O应用）</p><p>mmapv1、 wiredtiger、 mongorocks（ rocks）、 In-memory等多引擎支持满足各种场景需求</p><p>Gridfs解决文件存储的需求</p><p>（2）高可用性</p><p>MongoDB的复制工具称为副本集（ replica set），它可提供自动故障转移和数据冗余</p><p>（3）高扩展性</p><p>MongoDB提供了水平可扩展性作为其核心功能的一部分。</p><p>分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p><p>（4）丰富的查询支持</p><p>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p><p>（5）其他特点</p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（三）:模型介绍</title>
      <link href="/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/"/>
      <url>/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/</url>
      
        <content type="html"><![CDATA[<h3>Scrapy框架</h3><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><p>所谓网络爬虫，就是一个在网上到处或定向抓取数据的程序，当然，这种说法不够专业，更专业的描述就是，抓取特定网站网页的HTML数据。抓取网页的一般方法是，定义一个入口页面，然后一般一个页面会有其他页面的URL，于是从当前页面获取到这些URL加入到爬虫的抓取队列中，然后进入到新页面后再递归的进行上述的操作，其实说来就跟深度遍历或广度遍历一样。</p><p>Scrapy 使用 Twisted这个异步网络库来处理网络通讯，架构清晰，并且包含了各种中间件接口，可以灵活的完成各种需求。</p><h3>Hadoop</h3><h4>背景</h4><p>Hadoop是一个由Apache基金会所开发的<a href="https://baike.baidu.com/item/分布式系统/4905336?fromModule=lemma_inlink">分布式系统</a>基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个<a href="https://baike.baidu.com/item/分布式文件系统/1250388?fromModule=lemma_inlink">分布式文件系统</a>（ Distributed File System），其中一个组件是<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>（Hadoop Distributed File System）。HDFS有高<a href="https://baike.baidu.com/item/容错性/9131391?fromModule=lemma_inlink">容错性</a>的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问<a href="https://baike.baidu.com/item/应用程序/5985445?fromModule=lemma_inlink">应用程序</a>的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）<a href="https://baike.baidu.com/item/POSIX/3792413?fromModule=lemma_inlink">POSIX</a>的要求，可以以流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：<a href="https://baike.baidu.com/item/HDFS/4836121?fromModule=lemma_inlink">HDFS</a>和<a href="https://baike.baidu.com/item/MapReduce/133425?fromModule=lemma_inlink">MapReduce</a>。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。</p><h4>优点</h4><p>Hadoop是一个能够让用户轻松架构和使用的分布式计算平台。用户可以轻松地在Hadoop上开发和运行处理海量数据的应用程序。它主要有以下几个优点：&lt;/br&gt;<br>1.高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖&lt;/br&gt;。&lt;/br&gt;<br>2.高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。&lt;/br&gt;<br>3.高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。&lt;/br&gt;<br>4.高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。&lt;/br&gt;<br>5.低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。&lt;/br&gt;<br>Hadoop带有用Java语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如C++。</p><h3>Spark </h3><p>   Spark使用Scala语言进行实现，它是一种面向对象、函数式编程语言，能够像操作本地集合对象一样轻松地操作分布式数据集，具有以下特点。<br>1.运行速度快：Spark拥有DAG执行引擎，支持在内存中对数据进行迭代计算。官方提供的数据表明，如果数据由磁盘读取，速度是Hadoop MapReduce的10倍以上，如果数据从内存中读取，速度可以高达100多倍。<br>2.易用性好：Spark不仅支持Scala编写应用程序，而且支持Java和Python等语言进行编写，特别是Scala是一种高效、可拓展的语言，能够用简洁的代码处理较为复杂的处理工作。&lt;/br&gt;<br>3.通用性强：Spark生态圈即BDAS（伯克利数据分析栈）包含了Spark Core、Spark SQL、Spark Streaming、MLLib和GraphX等组件，这些组件分别处理Spark Core提供内存计算框架、SparkStreaming的实时处理应用、Spark SQL的即席查询、MLlib或MLbase的机器学习和GraphX的图处理。<br>4.随处运行：Spark具有很强的适应性，能够读取HDFS、Cassandra、HBase、S3和Techyon为持久层读写原生数据，能够以Mesos、YARN和自身携带的Standalone作为资源管理器调度job，来完成Spark应用程序的计算。</p><h3>Mongodb</h3><h2>背景介绍</h2><p>MongoDB是一个基于分布式文件存储的数据库。</p><p>由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><h2>业务场景</h2><p>传统的关系型数据库(如MySQL)，在数据操作的三高需求以及应对Web2.0的网站需求面前，显得力不从心，而 MongoDB可应对“三高“需求：</p><p>High performance：对数据库高并发读写的需求</p><p>Huge Storage：对海量数据的高效率存储和访问的需求</p><p>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</p><p>具体应用场景：</p><p>社交场景，使用 MongoDB存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。</p><p>游戏场景，使用 MongoDB存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、高效率存储和访问。</p><p>物流场景，使用 MongoDB存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</p><p>物联网场景，使用 MongoDB存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。</p><p>视频直播，使用 MongoDB存储用户信息、点赞互动信息等。</p><p>这些应用场景中，数据操作方面的共同特点是：</p><p>（1）数据量大</p><p>（2）写入操作频繁（读写都很频繁）</p><p>（3）价值较低的数据，对事务性要求不高</p><p>对于这样的数据，我们更适合使用 MongoDB来实现数据的存储。</p><h2>特点</h2><p>（1）高性能</p><p>MongoDB提供高性能的数据持久性。特别是，</p><p>对嵌入式数据模型的支持减少了数据库系统上I/O活动。</p><p>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种O2O应用）</p><p>mmapv1、 wiredtiger、 mongorocks（ rocks）、 In-memory等多引擎支持满足各种场景需求</p><p>Gridfs解决文件存储的需求</p><p>（2）高可用性</p><p>MongoDB的复制工具称为副本集（ replica set），它可提供自动故障转移和数据冗余</p><p>（3）高扩展性</p><p>MongoDB提供了水平可扩展性作为其核心功能的一部分。</p><p>分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p><p>（4）丰富的查询支持</p><p>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p><p>（5）其他特点</p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（四）:了解NLP的卷积神经网络</title>
      <link href="/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A13/"/>
      <url>/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A13/</url>
      
        <content type="html"><![CDATA[<h3>了解NLP的卷积神经网络</h3><p>当我们听到卷积神经网络（CNN）时，我们通常会想到计算机视觉。CNN负责图像分类的重大突破，并且是当今大多数计算机视觉系统的核心，从Facebook的自动照片标记到自动驾驶汽车。</p><p>最近，我们也开始将CNN应用于自然语言处理中的问题，并得到了一些有趣的结果。在这篇文章中，我将尝试总结CNN是什么，以及它们如何在NLP中使用。对于计算机视觉用例来说，CNN背后的直觉更容易理解，所以我将从那里开始，然后慢慢转向NLP。</p><h4>什么是卷积？</h4><p>对我来说，理解<em>卷积</em>的最简单方法是将其视为应用于矩阵的滑动窗口函数。这很拗口，但看可视化就很清楚了：</p><p><img src="https://dennybritz.com/img/Convolution_schematic.gif" alt=""></p><p>带 3×3 滤波器的卷积，来源：<a href="http://deeplearning.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/">http://deeplearning.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/</a></p><p>想象一下，左边的矩阵表示一个黑白图像。每个条目对应一个像素，0 表示黑色，1 表示白色（灰度图像通常在 0 到 255 之间）。滑动窗口称为内核、过滤器<em>或</em>特征检测器。在这里，我们使用 3×3 过滤器，将其值逐个乘以原始矩阵，然后将它们相加。为了获得完整的卷积，我们通过在整个矩阵上滑动过滤器来为每个元素执行此操作。</p><p>您可能想知道您实际上可以用它做什么。以下是一些直观的例子。</p><h4 id="将每个像素与其相邻值求平均值会使图像模糊："><a href="#将每个像素与其相邻值求平均值会使图像模糊：" class="headerlink" title="将每个像素与其相邻值求平均值会使图像模糊："></a>将每个像素与其相邻值求平均值会使图像模糊：</h4><p><img src="https://docs.gimp.org/en/images/filters/examples/convolution-blur.png" alt=""></p><p><img src="https://docs.gimp.org/en/images/filters/examples/generic-taj-convmatrix-blur.jpg" alt=""></p><h4 id="取像素与其相邻像素之间的差异可检测边缘："><a href="#取像素与其相邻像素之间的差异可检测边缘：" class="headerlink" title="取像素与其相邻像素之间的差异可检测边缘："></a>取像素与其相邻像素之间的差异可检测边缘：</h4><p>（要直观地理解这一点，请考虑图像中平滑的部分会发生什么，其中像素颜色等于其相邻颜色的颜色：添加取消，结果值为 0 或黑色。如果强度有锋利的边缘，例如从白色到黑色的过渡，你会得到很大的差异和由此产生的白色值）</p><p><img src="https://docs.gimp.org/en/images/filters/examples/convolution-edge-detect1.png" alt=""></p><p><img src="https://docs.gimp.org/en/images/filters/examples/generic-taj-convmatrix-edge-detect.jpg" alt=""></p><h3 id="什么是卷积神经网络？"><a href="#什么是卷积神经网络？" class="headerlink" title="什么是卷积神经网络？#"></a>什么是卷积神经网络？<a href="https://dennybritz.com/posts/wildml/understanding-convolutional-neural-networks-for-nlp/#what-areconvolutional-neural-networks">#</a></h3><p>现在你知道什么是卷积了。但是CNN呢？CNN本质上是几层卷积，其中非线性<em>激活函数</em>（如<a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks">ReLU</a>)或<a href="https://reference.wolfram.com/language/ref/Tanh.html">tanh</a>）应用于结果。在传统的前馈神经网络中，我们将每个输入神经元连接到下一层的每个输出神经元。这也称为全连接层或仿射层。在CNN中，我们改为在输入层上使用卷积来计算输出。这会导致本地连接，其中输入的每个区域都连接到输出中的一个神经元。每个图层应用不同的过滤器，通常为数百或数千个，如上所示，并组合其结果。还有一些东西叫做池化（子采样）层，但我稍后会谈到这一点。在训练阶段，<strong>CNN</strong> 会根据您要执行的任务自动<strong>学习其过滤器的值</strong>。例如，图像分类 CNN 可以学习从第一层中的原始像素检测边缘，然后使用边缘检测第二层中的简单形状，然后使用这些形状来阻止更高级别的特征，例如较高层中的面部形状。最后一层是使用这些高级功能的分类器。</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-07-at-7.26.20-AM.png" alt=""></p><p>这种计算有两个方面值得关注：<strong>位置不变性和**</strong>组合性<em>*。假设您要对图像中是否存在大象进行分类。因为你在整个图像上滑动滤镜，所以你并不真正关心大象出现</em>在哪里<em>。在实践中，</em>池化<em>还可以为您提供平移、旋转和缩放的不变性，但稍后会详细介绍。第二个关键方面是（局部）组成性。每个过滤器</em>将*较低级别要素的局部修补程序组成为更高级别表示形式。这就是为什么CNN在计算机视觉中如此强大的原因。从像素构建边缘、从边缘构建形状以及从形状构建更复杂的对象，这很直观。</p><h4 id="那么，这些如何适用于NLP？"><a href="#那么，这些如何适用于NLP？" class="headerlink" title="那么，这些如何适用于NLP？"></a>那么，这些如何适用于NLP？</h4><p>大多数NLP任务的输入不是图像像素，而是表示为矩阵的句子或文档。矩阵的每一行对应于一个标记，通常是一个单词，但它可以是字符。也就是说，每一行都是表示一个单词的向量。通常，这些向量是<em>词嵌入</em>（低维表示），如<a href="https://code.google.com/p/word2vec/">word2vec</a>或<a href="http://nlp.stanford.edu/projects/glove/">GloVe</a>，但它们也可能是将单词索引为词汇表的单热向量。对于使用 10 维嵌入的 100 个单词的句子，我们将有一个 10×100 矩阵作为我们的输入。这就是我们的“形象”。</p><p>在视觉中，我们的过滤器在图像的局部斑块上滑动，但在NLP中，我们通常使用在矩阵（单词）的整行上滑动的过滤器。因此，过滤器的“宽度”通常与输入矩阵的宽度相同。高度或<em>区域大小</em>可能会有所不同，但一次超过 2-5 个单词的滑动窗口是典型的。综上所述，NLP 的卷积神经网络可能如下所示（花几分钟时间尝试理解这张图片以及如何计算维度。您现在可以忽略池化，稍后我们将解释）：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-12.05.40-PM.png" alt=""></p><p>用于句子分类的卷积神经网络 （CNN） 架构图示。在这里，我们描述了三个过滤器区域大小：2、3 和 4，每个都有 2 个过滤器。每个过滤器对句子矩阵执行卷积并生成（可变长度）特征图。然后对每个图执行 1-max 池化，即记录每个特征图中的最大数量。因此，从所有六个映射生成一个单变量特征向量，并将这 6 个特征连接起来形成倒数第二层的特征向量。然后，最终的softmax层接收此特征向量作为输入，并使用它来对句子进行分类;这里我们假设二元分类，因此描述了两种可能的输出状态。资料来源：hang， Y.， &amp; Wallace， B. （2015）.用于句子分类的卷积神经网络的敏感性分析.</p><p>我们对计算机视觉的直觉呢？位置不变性和局部组合性对于图像来说很直观，但对于NLP来说就不那么重要了。你可能非常关心句子中出现单词的位置。彼此接近的像素可能在语义上相关（同一对象的一部分），但对于单词并不总是如此。在许多语言中，短语的某些部分可以用其他几个单词分隔。构图方面也不明显。显然，单词以某些方式组成，例如修饰名词的形容词，但这究竟是如何工作的，更高层次的表示实际上“意味着”并不像计算机视觉案例那样明显。</p><p>考虑到这一切，CNN似乎不适合NLP任务。<a href="https://dennybritz.com/posts/wildml/recurrent-neural-networks-tutorial-part-1/">递归神经网络</a>更直观。它们类似于我们处理语言的方式，或者至少是我们认为我们处理语言的方式：从左到右依次阅读。幸运的是，这并不意味着CNN不起作用。<a href="https://en.wikipedia.org/wiki/All_models_are_wrong">所有模型都是错误的，但有些模型是有用的</a>。事实证明，应用于NLP问题的CNN表现得非常好。简单的<a href="https://en.wikipedia.org/wiki/Bag-of-words_model">Bag of Words模型</a>显然过于简单，假设不正确，但多年来一直是标准方法，并产生了相当好的结果。</p><p>CNN的一个重要论点是它们速度很快。非常快。卷积是计算机图形学的核心部分，在 GPU 上的硬件级别实现。与<a href="https://en.wikipedia.org/wiki/N-gram">n-grams</a>相比，CNN在表示方面也很<em>有效</em>。对于大量词汇，计算超过 3 克的任何东西很快就会变得昂贵。甚至谷歌也没有提供超过5克的任何东西。卷积过滤器会自动学习良好的表示，而无需表示整个词汇表。使用大于 5 的过滤器是完全合理的。我喜欢认为第一层中的许多学习过滤器捕获的特征与 n 元语法非常相似（但不限于），但以更紧凑的方式表示它们。</p><h3 id="CNN-Hyperparameters"><a href="#CNN-Hyperparameters" class="headerlink" title="CNN Hyperparameters"></a>CNN Hyperparameters</h3><p>在解释如何将CNN应用于NLP任务之前，让我们看一下构建CNN时需要做出的一些选择。希望这将帮助您更好地了解该领域的文献。</p><h4 id="Narrow-vs-Wide-convolution"><a href="#Narrow-vs-Wide-convolution" class="headerlink" title="Narrow vs. Wide convolution"></a>Narrow vs. Wide convolution</h4><p>当我在上面解释卷积时，我忽略了我们如何应用过滤器的一些细节。在矩阵中心应用 3×3 滤波器工作正常，但边缘呢？如何将过滤器应用于顶部和左侧没有任何相邻元素的矩阵的第一个元素？您可以使用<em>零填充</em>。所有落在矩阵之外的元素都被视为零。通过执行此操作，您可以将过滤器应用于输入矩阵的每个元素，并获得更大或相同大小的输出。添加零填充也称为宽卷积<strong>，</strong>不使用零填充将是<em>窄卷积</em>。1D 中的示例如下所示：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-9.47.41-AM.png" alt=""></p><p>窄卷积与宽卷积。滤波器尺寸 5，输入尺寸 7。来源：用于句子建模的卷积神经网络（2014）</p><p>您可以看到，当您有一个相对于输入大小较大的过滤器时，卷积有多宽是有用的，甚至是必要的。在上面，窄卷积产生大小的输出(7−5)+1=3(7−5)+1=3，以及大小的宽卷积输出(7+2∗4−5)+1=11(7+2∗4−5)+1=11. 更一般地说，输出大小的公式为</p><script type="math/tex; mode=display">n_out=(n_{in}+2*n_padding-n_{filter})+1</script><h4 id="Stride-Size"><a href="#Stride-Size" class="headerlink" title="Stride Size"></a>Stride Size</h4><p>卷积的另一个超参数是<em>步幅大小</em>，它通过您希望在每一步移动过滤器的程度来定义。在上述所有示例中，步幅均为 1，并且过滤器的连续应用重叠。步幅越大，滤波器的应用越少，输出尺寸越小。<a href="http://cs231n.github.io/convolutional-networks/">Stanford cs231 website</a>以下内容显示了应用于一维输入的步幅大小 1 和 2：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-10.18.08-AM.png" alt=""></p><p>卷积步幅大小。左：步幅大小 1。右：步幅大小 2。来源： <a href="http://cs231n.github.io/convolutional-networks/">http://cs231n.github.io/convolutional-networks/</a></p><p>在文献中，我们通常看到步幅大小为 1，但更大的步幅大小可能允许您构建一个行为类似于<a href="https://en.wikipedia.org/wiki/Recursive_neural_network">递归神经网络</a>的模型，即看起来像一棵树。</p><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>卷积神经网络的一个关键方面是<em>池化层，</em>通常在卷积层之后应用。池化层对其输入进行子采样。最常见的方法是将其池化以应用�一个�<em>马·</em>对每个筛选器的结果进行操作。您不一定需要在完整矩阵上池化，也可以在窗口上池化。例如，下面显示了 2×2 窗口的最大池化。在 NLP 中，我们通常对整个输出应用池化，每个滤波器只产生一个数字：</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-05-at-2.18.38-PM.png" alt=""></p><p>CNN 中的最大池化。来源： <a href="http://cs231n.github.io/convolutional-networks/#pool">http://cs231n.github.io/convolutional-networks/#pool</a></p><p>为什么要池化？有几个原因。池化的一个属性是它提供固定大小的输出矩阵，这通常是分类所必需的。例如，如果您有 1，000 个筛选器，并且对每个筛选器应用最大池化，则无论筛选器的大小或输入的大小如何，都将获得 1000 维输出。这允许您使用可变大小的句子和可变大小的过滤器，但始终获得相同的输出维度以馈送到分类器中。</p><p>池化也会降低输出维度，但（希望）保留最突出的信息。您可以将每个过滤器视为检测特定特征，例如检测句子是否包含否定词，例如“不惊人”。如果此短语出现在句子中的某处，则对该区域应用筛选器的结果将产生较大的值，但在其他区域中将产生较小的值。通过执行 max 运算，您可以保留有关特征是否出现在句子中的信息，但您将丢失有关其确切显示位置的信息。但是，这些关于地点的信息真的没有用吗？是的，它是，它有点类似于一袋n-gram模型正在做的事情。您正在丢失有关局部性的全局信息（句子中发生某些事情的位置），但您保留了过滤器捕获的本地信息，例如“不惊人”与“惊人不惊人”非常不同。</p><p>在想象识别中，池化还为平移（移位）和旋转提供了基本的不变性。在某个区域上进行池化时，即使将图像移动或旋转几个像素，输出也将大致保持不变，因为无论如何，最大操作都会选择相同的值。</p><h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>我们需要了解的最后一个概念是<em>渠道</em>。通道是输入数据的不同“视图”。例如，在图像识别中，您通常具有RGB（红色，绿色，蓝色）通道。您可以跨通道应用卷积，权重不同或相等。在NLP中，你也可以想象有各种各样的通道：你可以为不同的单词嵌入（例如<a href="https://code.google.com/p/word2vec/">word2vec</a>和<a href="http://nlp.stanford.edu/projects/glove/">GloVe</a>）提供一个单独的通道，或者你可以有一个通道来表示用不同的语言表示的同一个句子，或者用不同的方式表达。</p><h3 id="卷积神经网络应用于NLP"><a href="#卷积神经网络应用于NLP" class="headerlink" title="卷积神经网络应用于NLP"></a>卷积神经网络应用于NLP</h3><p>现在让我们看看CNN在自然语言处理中的一些应用。我会尝试总结一些研究结果。我总是会错过许多有趣的应用程序，但我希望至少涵盖一些更受欢迎的结果。</p><p>最适合CNN似乎是分类任务，例如情绪分析，垃圾邮件检测或主题分类。卷积和池化操作会丢失有关单词本地顺序的信息，因此 PoS 标记或实体提取中的序列标记更难适应纯 CNN 架构（尽管并非不可能，您可以向输入添加位置特征）。</p><p>[1] 在各种分类数据集上评估 CNN 架构，主要由情感分析和主题分类任务组成。CNN架构在数据集上实现了非常好的性能，并在少数数据集上实现了最先进的性能。令人惊讶的是，本文中使用的网络非常简单，这就是它强大的原因。输入层是由连接的 <a href="https://code.google.com/p/word2vec/">word2vec</a> 词嵌入组成的句子。接下来是具有多个过滤器的卷积层，然后是最大池化层，最后是softmax分类器。该论文还以静态和动态词嵌入的形式尝试了两种不同的通道，其中一个通道在训练期间进行调整，另一个则不调整。之前在 [2] 中提出了类似但稍微复杂的架构。[6] 在此网络架构中添加了一个执行“语义聚类”的附加层。</p><p><img src="https://dennybritz.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-06-at-8.03.47-AM.png" alt=""></p><p>[4] 从头开始训练 CNN，无需像 word2vec 或 GloVe 这样的预先训练的词向量。它将卷积直接应用于独热向量。作者还为输入数据提出了一种节省空间的词袋状表示，减少了网络需要学习的参数数量。在[5]中，作者用额外的无监督“区域嵌入”扩展了模型，该嵌入是使用CNN预测文本区域上下文来学习的。这些论文中的方法似乎适用于长篇文本（如电影评论），但它们在短文本（如推文）上的表现尚不清楚。直观地说，对短文本使用预先训练的单词嵌入比对长文本使用它们会产生更大的收益是有道理的。</p><p>构建CNN架构意味着有许多超参数可供选择，其中一些我在上面介绍过：输入响应（word2vec，GloVe，one-hot），卷积过滤器的数量和大小，池化策略（最大值，平均值）和激活函数（ReLU，tanh）。[7] 对 CNN 架构中不同超参数的影响进行了实证评估，调查了它们对多次运行的性能和方差的影响。如果您希望实现自己的CNN进行文本分类，那么使用本文的结果作为起点将是一个好主意。一些突出的结果是，最大池化总是胜过平均池化，理想的过滤器大小很重要但取决于任务，并且正则化似乎在所考虑的NLP任务中没有太大的不同。这项研究的一个警告是，所有数据集在文档长度方面都非常相似，因此相同的准则可能不适用于看起来有很大差异的数据。</p><p>[8] 探索用于关系提取和关系分类任务的 CNN。除了词向量之外，作者还使用词与感兴趣实体的相对位置作为卷积层的输入。此模型假定给定实体的位置，并且每个示例输入都包含一个关系。[9]和[10]探索了类似的模型。</p><p>CNN在NLP中的另一个有趣的用例可以在[11]和[12]中找到，来自Microsoft Research。这些论文描述了如何学习可用于信息检索的句子的语义有意义的表示。论文中给出的示例包括根据用户当前正在阅读的内容向用户推荐可能感兴趣的文档。句子表示基于搜索引擎日志数据进行训练。</p><p>大多数CNN架构以一种或另一种方式学习单词和句子的嵌入（低维表示），作为其训练过程的一部分。并非所有论文都关注训练的这一方面或研究学习嵌入的意义。[13]提出了一个CNN架构来预测Facebook帖子的主题标签，同时为单词和句子生成有意义的嵌入。然后，这些学习的嵌入成功地应用于另一项任务 - 向用户推荐可能感兴趣的文档，并根据点击流数据进行训练。</p><h4 id="Character-Level-CNNs"><a href="#Character-Level-CNNs" class="headerlink" title="Character-Level CNNs"></a>Character-Level CNNs</h4><p>到目前为止，所有提出的模型都是基于文字的。但也有人研究将CNN直接应用于角色。[14] 学习字符级嵌入，将它们与预先训练的词嵌入连接起来，并使用 CNN 进行词性标记。[15][16] 探索了使用 CNN 直接从角色中学习，而无需任何预先训练的嵌入。值得注意的是，作者使用了一个相对深度的网络，共有9层，并将其应用于情感分析和文本分类任务。结果表明，直接从字符级输入中学习在大型数据集（数百万个示例）上效果非常好，但在较小的数据集（数十万个示例）上表现不佳。[17] 探索了字符级卷积在语言建模中的应用，在每个时间步使用字符级 CNN 的输出作为 LSTM 的输入。相同的模型应用于各种语言。</p><p>令人惊讶的是，基本上上述所有论文都是在过去1-2年内发表的。显然，CNN之前在NLP方面已经有过出色的工作，就像从<a href="http://arxiv.org/abs/1103.0398">Scratch开始的自然语言处理（几乎）</a>一样，但是新结果和最新系统发布的步伐显然正在加快</p><p>參考链接：</p><p><a href="https://dennybritz.com/posts/wildml/understanding-convolutional-neural-networks-for-nlp/">Understanding Convolutional Neural Networks for NLP · Denny’s Blog (dennybritz.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（五）:基于余弦相似的搜索算法</title>
      <link href="/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A15/"/>
      <url>/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A15/</url>
      
        <content type="html"><![CDATA[<h3>基于余弦相似的搜索算法</h3><p>给一个例子：</p><p><a href="https://postimg.cc/p9WSKJRj"><img src="https://i.postimg.cc/1zwZhvdv/VRUP-2-IEP-G-5-L-2-C-VMO.png" alt="VRUP-2-IEP-G-5-L-2-C-VMO.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于大数据方法的豆瓣电影短评分类、预测与搜索（五）:Transformer模型</title>
      <link href="/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A14/"/>
      <url>/2022/11/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A14/</url>
      
        <content type="html"><![CDATA[<p>Transformer是一个利用注意力机制来提高模型训练速度的模型。关于注意力机制可以参看<a href="https://zhuanlan.zhihu.com/p/52119092">这篇文章</a>，trasnformer可以说是完全基于自注意力机制的一个深度学习模型，因为它适用于并行化计算，和它本身模型的复杂程度导致它在精度和性能上都要高于之前流行的RNN循环神经网络。</p><p>那什么是transformer呢？</p><p>你可以简单理解为它是一个黑盒子，当我们在做文本翻译任务是，我输入进去一个中文，经过这个黑盒子之后，输出来翻译过后的英文。</p><p><img src="https://pic4.zhimg.com/80/v2-1a4f5b236563d6307acb58cc5a95b2b7_720w.webp" alt=""></p><p>那么在这个黑盒子里面都有什么呢？</p><p>里面主要有两部分组成：Encoder 和 Decoder</p><p><img src="https://pic2.zhimg.com/80/v2-8bf3b3ac8836ef1a9f16e1669fb29511_720w.webp" alt=""></p><p>当我输入一个文本的时候，该文本数据会先经过一个叫Encoders的模块，对该文本进行编码，然后将编码后的数据再传入一个叫Decoders的模块进行解码，解码后就得到了翻译后的文本，对应的我们称Encoders为编码器，Decoders为解码器。</p><p>那么编码器和解码器里边又都是些什么呢？</p><p>细心的同学可能已经发现了，上图中的Decoders后边加了个s，那就代表有多个编码器了呗，没错，这个编码模块里边，有很多小的编码器，一般情况下，Encoders里边有6个小编码器，同样的，Decoders里边有6个小解码器。</p><p><img src="https://pic4.zhimg.com/80/v2-739d9498e0a36296240741be909d35f7_720w.webp" alt=""></p><p>我们看到，在编码部分，每一个的小编码器的输入是前一个小编码器的输出，而每一个小解码器的输入不光是它的前一个解码器的输出，还包括了整个编码部分的输出。</p><p>那么你可能又该问了，那每一个小编码器里边又是什么呢？</p><p>我们放大一个encoder，发现里边的结构是一个自注意力机制加上一个前馈神经网络。</p><p><img src="https://pic1.zhimg.com/80/v2-8c63aaf7e71b94fdb5d6df89abdaf118_720w.webp" alt=""></p><p>我们先来看下self-attention是什么样子的。</p><p>我们通过几个步骤来解释：</p><p>1、首先，self-attention的输入就是词向量，即整个模型的最初的输入是词向量的形式。那自注意力机制呢，顾名思义就是自己和自己计算一遍注意力，即对每一个输入的词向量，我们需要构建self-attention的输入。在这里，transformer首先将词向量乘上三个矩阵，得到三个新的向量，之所以乘上三个矩阵参数而不是直接用原本的词向量是因为这样增加更多的参数，提高模型效果。对于输入X1(机器)，乘上三个矩阵后分别得到Q1,K1,V1，同样的，对于输入X2(学习)，也乘上三个不同的矩阵得到Q2,K2,V2。</p><p><img src="https://pic3.zhimg.com/80/v2-15142b393f03a309c926754f00307d46_720w.webp" alt=""></p><p>2、那接下来就要计算注意力得分了，这个得分是通过计算Q与各个单词的K向量的点积得到的。我们以X1为例，分别将Q1和K1、K2进行点积运算，假设分别得到得分112和96。</p><p><img src="https://pic2.zhimg.com/80/v2-42ccd93ac7540619b02ef03faef21c15_720w.webp" alt=""></p><p>3、将得分分别除以一个特定数值8（K向量的维度的平方根，通常K向量的维度是64）这能让梯度更加稳定，则得到结果如下：</p><p><img src="https://pic3.zhimg.com/80/v2-8a98e66c20fb25e96e1f690309ae6166_720w.webp" alt=""></p><p>4、将上述结果进行softmax运算得到，softmax主要将分数标准化，使他们都是正数并且加起来等于1。</p><p><img src="https://pic3.zhimg.com/80/v2-1701b674a3e09ae91301d6cd9727f912_720w.webp" alt=""></p><p>5、将V向量乘上softmax的结果，这个思想主要是为了保持我们想要关注的单词的值不变，而掩盖掉那些不相关的单词（例如将他们乘上很小的数字）</p><p><img src="https://pic2.zhimg.com/80/v2-c18a30a6b8738af5cd1b5c0e2080e695_720w.webp" alt=""></p><p>6、将带权重的各个V向量加起来，至此，产生在这个位置上（第一个单词）的self-attention层的输出，其余位置的self-attention输出也是同样的计算方式。</p><p><img src="https://pic3.zhimg.com/80/v2-3577071e71ccfa49a4f60f4a5187f0ce_720w.webp" alt=""><br> 将上述的过程总结为一个公式就可以用下图表示：</p><p><img src="https://pic4.zhimg.com/80/v2-0190eb46d1c46efc04926821e69fd377_720w.webp" alt=""></p><p>self-attention层到这里就结束了吗？</p><p>还没有，论文为了进一步细化自注意力机制层，增加了“多头注意力机制”的概念，这从两个方面提高了自注意力层的性能。</p><p>第一个方面，他扩展了模型关注不同位置的能力，这对翻译一下句子特别有用，因为我们想知道“it”是指代的哪个单词。</p><p><img src="https://pic1.zhimg.com/80/v2-dc386abf38141384c43918689b0bbb64_720w.webp" alt=""></p><p>第二个方面，他给了自注意力层多个“表示子空间”。对于多头自注意力机制，我们不止有一组Q/K/V权重矩阵，而是有多组（论文中使用8组），所以每个编码器/解码器使用8个“头”（可以理解为8个互不干扰自的注意力机制运算），每一组的Q/K/V都不相同。然后，得到8个不同的权重矩阵Z，每个权重矩阵被用来将输入向量投射到不同的表示子空间。</p><p>经过多头注意力机制后，就会得到多个权重矩阵Z，我们将多个Z进行拼接就得到了self-attention层的输出：</p><p><img src="https://pic2.zhimg.com/80/v2-1be30f537678c89b2768ed31ff5bb491_720w.webp" alt=""></p><p>上述我们经过了self-attention层，我们得到了self-attention的输出，self-attention的输出即是前馈神经网络层的输入，然后前馈神经网络的输入只需要一个矩阵就可以了，不需要八个矩阵，所以我们需要把这8个矩阵压缩成一个，我们怎么做呢？只需要把这些矩阵拼接起来然后用一个额外的权重矩阵与之相乘即可。</p><p><img src="https://pic4.zhimg.com/80/v2-7394f6eb418b403588b0ca5a6751749f_720w.webp" alt=""></p><p>最终的Z就作为前馈神经网络的输入。</p><p>接下来就进入了小编码器里边的前馈神经网模块了，关于前馈神经网络，网上已经有很多资料，在这里就不做过多讲解了，只需要知道，前馈神经网络的输入是self-attention的输出，即上图的Z,是一个矩阵，矩阵的维度是（序列长度×D词向量），之后前馈神经网络的输出也是同样的维度。</p><p>以上就是一个小编码器的内部构造了，一个大的编码部分就是将这个过程重复了6次，最终得到整个编码部分的输出。</p><p>然后再transformer中使用了6个encoder，为了解决梯度消失的问题，在Encoders和Decoder中都是用了残差神经网络的结构，即每一个前馈神经网络的输入不光包含上述self-attention的输出Z，还包含最原始的输入。</p><p>上述说到的encoder是对输入（机器学习）进行编码，使用的是自注意力机制+前馈神经网络的结构，同样的，在decoder中使用的也是同样的结构。也是首先对输出（machine learning）计算自注意力得分，不同的地方在于，进行过自注意力机制后，将self-attention的输出再与Decoders模块的输出计算一遍注意力机制得分，之后，再进入前馈神经网络模块。</p><p><img src="https://pic4.zhimg.com/v2-5e32534b9a651289cb3eb2b409d5996b_r.jpg" alt=""></p><p>以上，就讲完了Transformer编码和解码两大模块，那么我们回归最初的问题，将“机器学习”翻译成“machine learing”，解码器输出本来是一个浮点型的向量，怎么转化成“machine learing”这两个词呢？</p><p>是个工作是最后的线性层接上一个softmax，其中线性层是一个简单的全连接神经网络，它将解码器产生的向量投影到一个更高维度的向量（logits）上，假设我们模型的词汇表是10000个词，那么logits就有10000个维度，每个维度对应一个惟一的词的得分。之后的softmax层将这些分数转换为概率。选择概率最大的维度，并对应地生成与之关联的单词作为此时间步的输出就是最终的输出啦！！</p><p>假设词汇表维度是6，那么输出最大概率词汇的过程如下：</p><p><img src="https://pic4.zhimg.com/80/v2-6d0a0d38ab824914942121d1ae78cd0b_720w.webp" alt=""></p><p>以上就是Transformer的框架了，但是还有最后一个问题，我们都是到RNN中的每个输入是时序的，是又先后顺序的，但是Transformer整个框架下来并没有考虑顺序信息，这就需要提到另一个概念了：“位置编码”。</p><p>Transformer中确实没有考虑顺序信息，那怎么办呢，我们可以在输入中做手脚，把输入变得有位置信息不就行了，那怎么把词向量输入变成携带位置信息的输入呢？</p><p>我们可以给每个词向量加上一个有顺序特征的向量，发现sin和cos函数能够很好的表达这种特征，所以通常位置向量用以下公式来表示：</p><p><img src="https://pic1.zhimg.com/80/v2-a671b951ef42d09c349db12c35175998_720w.webp" alt=""></p><p><img src="https://pic1.zhimg.com/80/v2-c17ebc4594bd0c0d01fab289abde5ec4_720w.webp" alt=""></p><p>最后祭出这张经典的图，最初看这张图的时候可能难以理解，希望大家在深入理解Transformer后再看这张图能够有更深刻的认识。</p><p><img src="https://pic1.zhimg.com/80/v2-1d9129c9c0d5367591bd093f79155e40_720w.webp" alt=""></p><p><img src="https://pic4.zhimg.com/v2-8fbde14eac35db43cfe1734d4714a7db_r.jpg" alt=""></p><p>參考文獻：<a href="https://zhuanlan.zhihu.com/p/82312421">十分钟理解Transformer - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建一个神经元</title>
      <link href="/2022/11/15/CNN%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%AD%A6%E4%B9%A01/"/>
      <url>/2022/11/15/CNN%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h3><font face='楷体'>实现方法</font></h3><h5><font face='楷体'>神经元（Neurons）:它是神经网络的基本单元。神经元先获得输入，然后执行某些数学运算后，再产生一个输出。比如一个2输入神经元的例子：</font></h5><p><img src="https://picx.zhimg.com/80/v2-5550feac69724dcbc145574525ae42f6_720w.webp?source=1940ef5c" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验二：词频统计与可视化</title>
      <link href="/2022/10/31/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA3/"/>
      <url>/2022/10/31/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA3/</url>
      
        <content type="html"><![CDATA[<p><h1 align='center'>实验二：词频统计与可视化</h1><br> <h5 align='center'> Design by W.H Huang | Direct by Prof Feng</h5></p><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><p>通过本次实验，你应该：</p><ul><li>熟悉 <em>hadoop</em>+ <em>Spark</em>下编程环境</li><li>掌握基于<em>Spark</em>的基本<em>MAP REDUCE</em> 操作</li><li>掌握基本大数据可视化工具</li><li>独立完成本次青年群体择偶观分析实验</li><li>【新增】远程开发相关知识</li></ul><p>本次实验需小组内分工合作完成两个任务：</p><ol><li><p><em>WordCount</em> 词频统计</p><p>你将会使用到 <em>jieba</em> 分词 &amp; 基于 <em>pySpark</em> 的基本 <em>MAP REDUCE</em> 操作进行词频统计，在指定数据集上大数据分析青年群体择偶观倾向。</p></li><li><p>大数据可视化</p><p>你将使用 <em>echars &amp; WordCloud</em> 两个可视化库来进行大数据可视化，小组独立完成核心代码编写、测试。</p></li></ol><h2 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2 实验准备"></a>2 实验准备</h2><h3 id="2-0-成绩说明"><a href="#2-0-成绩说明" class="headerlink" title="2.0 成绩说明"></a>2.0 成绩说明</h3><p>本次实验，根据各位同学选择的<strong>不同环境搭建方式</strong>，不同的成绩分数说明如下。</p><p>【注】本次实验不要求使用分布式。</p><div class="table-container"><table><thead><tr><th style="text-align:center">实验环境</th><th style="text-align:center">最高分</th></tr></thead><tbody><tr><td style="text-align:center">云服务器</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">VM虚拟机</td><td style="text-align:center">95</td></tr></tbody></table></div><p>在本次实验我们给予学有余力的同学，在完成本次实验的基础上提出了扩展要求。</p><p>【注】加分后总分不超过100分。</p><div class="table-container"><table><thead><tr><th style="text-align:center">扩展要求</th><th style="text-align:center">加分</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">1. 使用分布式完成本次实验</td><td style="text-align:center">+5</td><td style="text-align:center">可参考ex3~ex4</td></tr><tr><td style="text-align:center">2. 扩充原有数据集（100M以上），或基于新的数据集进行实验</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据数据量、质量、难度给分</td></tr><tr><td style="text-align:center">3. 新增更多可视化，如柱状图等</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据可视化工作量给分</td></tr><tr><td style="text-align:center">4. 使用更好的算法分析数据，如应用深度学习模型Bert</td><td style="text-align:center">+10</td><td style="text-align:center">有对比实验最好</td></tr></tbody></table></div><h3 id="2-1-上传文件"><a href="#2-1-上传文件" class="headerlink" title="2.1 上传文件"></a>2.1 上传文件</h3><p>在开始实验前， 首先要将代码及相关资源上传到服务器。该小节将介绍如何使用FTP软件将本地（Windows）文件上传到服务器(Linux)。</p><ol><li><p>下载软件</p><p>FTP工具我们选择<code>Filezilla</code> ，下载地址：<a href="https://pc.qq.com/search.html#!keyword=fielzilla">Filezilla下载</a> </p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/RLvUt4bDNa69X1Y.png" alt="1579960280360"></p><p>点击进行下载安装，安装过程较为简单不再赘述。</p></li><li><p>连接服务器</p><p>依次点击：文件 —&gt; 站点管理器 —&gt;  新站点 </p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/snKEbvuzyc2CXLR.png" alt="1580056871863"></p></li><li><p>上传文件</p><p>如下图所示，左侧为本地文件，右侧为服务器文件目录（默认为 <code>/home/hadoop</code>）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/aWGltFuJnEXmvpV.png" alt="1580057006302"></p><p>上传完毕后，可在服务器上查看文件：</p><p><img src="https://i.loli.net/2020/09/17/c12v7n9fI4h5BSi.png" alt="1580057304136"></p></li></ol><h3 id="2-2-【强烈建议】远程开发"><a href="#2-2-【强烈建议】远程开发" class="headerlink" title="2.2 【强烈建议】远程开发"></a>2.2 【强烈建议】远程开发</h3><blockquote><p>教程支持：@<a href="https://github.com/leexinhao">white_windmills</a> @<a href="https://github.com/Wanghui-Huang">Wanghui-Huang</a> @<a href="https://github.com/ghc2000">ghc2000</a></p><ul><li>云环境：基于华为云，腾讯云/阿里云也可</li><li>操作系统：基于Ubantu，CentOS下也可</li></ul></blockquote><p>在教程<code>ex0</code> &amp; <code>2.1节</code>时，我们介绍了：</p><ul><li><p><code>SSH</code>工具，如<code>Xshell</code> ，可以很方便在<strong>终端命令行操作</strong>远程服务器；</p></li><li><p><code>FTP</code> 工具，如<code>Filezilla</code> ，可以很方便的<strong>上传/下载</strong>数据集和代码等；</p></li></ul><p>但是因为<strong>代码运行环境在远程服务器</strong>上，我们只能这么进行代码编写、调试：</p><ol><li><code>Filezilla</code>上传数据集等资源；</li><li><code>Xshell</code>连接服务器命令行操作，使用<code>vim</code> 编写代码，关键地方<code>print</code>；</li><li>编写好后命令行下执行 <code>python code.py</code> ，观察代码<code>print</code>输出 &amp; 调试。</li></ol><p>显然<strong>这样做效率是很低下</strong>的。或者你还想到：</p><ol><li>VNC登陆云服务器，安装桌面、IDE等；</li><li>在VNC中云桌面编写代码。</li></ol><p>但这种做法经过实际尝试也是不建议的：</p><ul><li><strong>资源问题</strong>：安装桌面要<strong>消耗服务器很大的资源</strong>，对于本来就<strong>资源不足</strong>的丐版云服务器雪上加霜；</li><li><strong>操作问题</strong>：VNC桌面登陆，复制、粘贴等基本操作都很麻烦，不太方便；</li><li><strong>网络问题</strong>：实际操作下，网络延迟有时比较大，加上启动桌面很耗资源，经常会卡成PPT。</li></ul><p>因此对于实际开发来说，我们还是<strong>更希望能使用本地IDE去调试远程代码，而不是使用vim或者直接远程服务器安装IDE</strong>。</p><p>那么，<strong>如何在本地电脑使用IDE去调试远程机器上的代码</strong>？</p><ul><li>现在我们可以在VSCode/Pycharm 进行远程开发相关配置；</li><li>VSCode/Pycharm 等IDE通常还<strong>集成了终端环境</strong>，方便我们操作服务器。</li></ul><p>正式开始前，我们先<strong>检查一下SSH安装情况</strong>。</p><ol><li><p>查看是否安装了ssh-server服务</p><p>非云系统默认只安装ssh-client服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep ssh</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20210709104708181.png" alt="image-20210709104708181" style="zoom:80%;" /></p><p>华为云等云厂商一般还会默认安装ssh-server服务，如果没有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>确认ssh-server启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221133305362.png" alt="image-20211221133305362"></p><p>如果看到<code>sshd</code>，说明ssh-server已经成功启动。</p><p>特别的，我们设置一下<strong>允许密码登陆root用户</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>注释配置文件中的<code>PermitRootLogin without-password</code>，即前面加一个<code>#</code>号</li><li>增加<code>PermitRootLogin yes</code> 一行</li></ul><p>最后重启服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh stop</span><br><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-1-VSCode远程开发实践"><a href="#2-2-1-VSCode远程开发实践" class="headerlink" title="2.2.1 VSCode远程开发实践"></a>2.2.1 VSCode远程开发实践</h4><ol><li><p>安装Remote-SSH插件</p><p>左侧Extension图标 —-&gt; 输入 <code>Remote-SSH</code> —-&gt;安装即可。注意，需要<strong>远程和本地都进行安装</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163014391.png" alt="image-20211206163014391"></p></li><li><p>配置Remote-SSH插件</p><p>如图所示选择<code>.ssh/config</code> 文件进行配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206163445062.png" alt="image-20211206163445062"></p><p>打开文件后，需要设置以下字段：</p><ul><li>Host：自定义即可</li><li>HostName：云主机<strong>公网IP</strong></li><li>User：登陆的用户，选择root</li><li>IdentityFile：免密登录私钥地址，如果没有配置则每次远程登录需要输入密码</li></ul><p>以下为示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">roy-cpp</span></span><br><span class="line">  <span class="string">HostName</span> <span class="number">121.36</span><span class="number">.59</span><span class="number">.23</span> <span class="comment"># 云主机公网IP</span></span><br><span class="line">  <span class="string">User</span>  <span class="string">root</span></span><br><span class="line">  <span class="string">IdentityFile</span> <span class="string">D:/huawei_rsa/id_rsa</span> <span class="comment"># 这行可删除</span></span><br></pre></td></tr></table></figure></li><li><p>登陆测试</p><p>点击下图按钮进行登陆：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211206164334870.png" alt="image-20211206164334870"></p><p>输入密码后，便可以看到远程服务器已经成功连接。</p></li><li><p>远程开发实践</p><p>连接上后就和我们本地使用VSCode没有什么区别：</p><ul><li><p><strong>打开远程文件</strong>：File—-&gt;Open Folder—-&gt;指定文件夹路径，类似打开本地文件；</p></li><li><p><strong>使用终端</strong>：在VSCode下方<code>Terminal</code>一栏可进行命令行操作，可认为是一个ssh连接的界面，你可以在上面进行之前<code>Xshell</code>等软件的所有操作；</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211222132204902.png" alt="image-20211222132204902"></p></li><li><p><strong>远程debug</strong>：使用<code>python</code>插件，注意<u>远端&amp;本地</u>都要安装。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135337775.png" alt="image-20211221135337775"></p></li></ul></li></ol><h4 id="2-2-2-Pycharm远程开发实践"><a href="#2-2-2-Pycharm远程开发实践" class="headerlink" title="2.2.2 Pycharm远程开发实践"></a>2.2.2 Pycharm远程开发实践</h4><blockquote><p>在Pycharm中此功能需要用<strong>专业版</strong>，正版的话直接去官网学生申请即可（我们重大的邮箱没法申请，需要拍学生证申请）。</p></blockquote><ol><li><p>SSH配置</p><p>打开File-&gt;Settings-&gt;SSH Configurations，进行如下配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135547820.png" alt="image-20211221135547820"></p><p>输入完成后，点击Test Connection，测试一下连接状态</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135637429.png" alt="image-20211221135637429"></p></li><li><p>新建SSH Session</p><p>点击：Tools—-&gt;Start SSH Session…—-&gt;Edit credentials，现在可以进行对服务器的命令行操作（可以视作之前的ssh窗口）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221135824733.png" alt="image-20211221135824733"></p><p>仅仅使用命令行是肯定不够的，pycharm提供了很多更便捷的工具。</p></li><li><p>配置远端python解释器</p><p>点击：File—-&gt;Settings—-&gt;Project:…—&gt;Project Interpreter，添加python解释器：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140024771.png" alt="image-20211221140024771"></p><p>选择SSH Interpreter，选择刚刚配置好的服务器：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140058246.png" alt="image-20211221140058246"></p><p>选择服务器中你需要的解释器，以及项目文件的映射路径，勾选自动同步等配置：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140124800.png" alt="image-20211221140124800"></p><p>配置完成后就和本地解释器的使用差不多了：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140151969.png" alt="image-20211221140151969"></p><p>特别的如果需要修改映射路径可以在：tools-&gt;Deployment-&gt;Configurations，下进行修改。</p></li><li><p>打开远端目录</p><p>通过：tools—&gt;Deployment—&gt;Configurations—&gt;Browse Remote Host，打开远端目录文件树。</p><p>之后就可以操作远程目录的文件：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140412518.png" alt="image-20211221140412518"></p></li><li><p>问题解决</p><blockquote><p>[<strong>ERROR#1</strong>] 远端解释器连接失败。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140524288.png" alt="image-20211221140524288"></p></blockquote><p>一般是因为解释器路径写错了，很多系统默认装的是python3，修改解释器路径即可：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221140625493.png" alt="image-20211221140625493"></p><blockquote><p>[<strong>ERROR#2</strong>] 华为云的openEuler系统ssh连不上。</p></blockquote><p>可能是服务器设置问题，需要修改/etc/ssh/sshd_config文件：</p><p>首先，运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>接着，我们要做如下修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AllowAgentForwarding <span class="built_in">yes</span></span><br><span class="line">AllowTcpForwarding <span class="built_in">yes</span></span><br><span class="line">GatewayPorts <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-3-扩展阅读：C-远程开发实践"><a href="#2-2-3-扩展阅读：C-远程开发实践" class="headerlink" title="2.2.3 扩展阅读：C++远程开发实践"></a>2.2.3 扩展阅读：C++远程开发实践</h4><blockquote><p>最近在学C++，想配置C++远程开发环境？最好还能调试代码？</p></blockquote><p>请参考：<a href="https://hwh.zone/p/18652/">C++从零开始（一）：环境搭建（上）之VSCode远程开发</a></p><h3 id="2-3-安装相关库"><a href="#2-3-安装相关库" class="headerlink" title="2.3 安装相关库"></a>2.3 安装相关库</h3><blockquote><p>:warning: 注意，<strong>本实验需要你安装桌面环境</strong>：请参考<code>ex0:2.1.2 可视化界面</code> 。</p></blockquote><p>先更新<code>pip</code> ，否则可能会出现安装失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install --upgrade pip  </span><br></pre></td></tr></table></figure><p>如果以下调用yum命令出错，请将以下两个文件的第一行改为<code>python2/2.7</code>。相关讨论可见：<a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/23">issue#23</a> 。</p><ol><li><p>修改urlgrabber-ext-down</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/libexec/urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211222000428258.png" alt="image-20211222000428258"></p></li><li><p>修改yum</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211222000511787.png" alt="image-20211222000511787"></p></li></ol><p>下面开始正式安装本次实验所需的库文件。</p><ul><li><p>安装字体文件</p><p>本次实验，需要wqy-microhei.ttc文件，但在<code>/usr/share/fonts</code> 可能并不存在该文件。需要自行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install wqy-microhei-fonts</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>jieba</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install jieba -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>wordcloud</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install wordcloud -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>pyecharts</code> </p><blockquote><p>需要指定安装1.7.0版本，否则下面代码API调用接口不正确。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts==1.7.0</span><br><span class="line">sudo pip3 install snapshot-selenium</span><br></pre></td></tr></table></figure></li><li><p>安装驱动（易错）</p><blockquote><p>具体讨论可参考：@<a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/30">issue#30</a> @<a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/21">issue#21</a></p></blockquote><p><code>pyechars</code> 模块保存图片需要安装相应<strong>chromedriver和google-chrome</strong> ，并且<strong>版本号要一一对应</strong>。</p><ul><li><p>安装google-chrome</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/CentOS-Base.repo   http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">sudo curl https://intoli.com/install-google-chrome.sh | bash </span><br><span class="line">ldd /opt/google/chrome/chrome | grep <span class="string">&quot;not found&quot;</span></span><br><span class="line"></span><br><span class="line">google-chrome --no-sandbox --headless --disable-gpu --screenshot https://www.baidu.com/</span><br></pre></td></tr></table></figure></li><li><p>安装chromedrive</p><p>chromedrive版本要和google-chrome对应，所以我们先查看google-chrome版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome-stable --version</span><br></pre></td></tr></table></figure><p>记录版本号后，去<a href="https://npm.taobao.org/mirrors/chromedriver/">https://npm.taobao.org/mirrors/chromedriver/</a> 下载对应的驱动。下载方式：</p><ul><li><p>推荐： <code>wget  下载链接</code> 形式 ，例如下载95版本的chromedriver</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O chromedriver_linux64.zip https://npm.taobao.org/mirrors/chromedriver/107.0.5304.62/chromedriver_linux64.zip</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>笨一点：本地机器下载后，使用FTP工具上传到服务器</p></li></ul><p>下载后，在下载的<strong>压缩文件所在的路径</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先删除之前的chromedriver</span></span><br><span class="line">sudo <span class="built_in">rm</span> -f /usr/bin/chromedriver</span><br><span class="line">sudo <span class="built_in">rm</span> -f /usr/local/bin/chromedriver</span><br><span class="line">sudo <span class="built_in">rm</span> -f /usr/local/share/chromedriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.unzip 解压</span></span><br><span class="line"><span class="comment"># 解压出文件chromedriver</span></span><br><span class="line">unzip chromedriver_linux64.zip    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.赋予777权限</span></span><br><span class="line"><span class="built_in">chmod</span> 777 chromedriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.mv 移动到/usr/bin/路径</span></span><br><span class="line">sudo <span class="built_in">mv</span>  chromedriver /usr/bin/</span><br></pre></td></tr></table></figure><h3 id="2-4-设置日志级别"><a href="#2-4-设置日志级别" class="headerlink" title="2.4 设置日志级别"></a>2.4 设置日志级别</h3><blockquote><p>由于<code>spark</code> 在运行时会打印非常多的日志，为了便于调试观察，我们设置日志级别为 <code>WARN</code> 。</p></blockquote><p>以下为全局设置日志级别方式，你也可在代码中临时设置 <code>sc.setLogLevel(&quot;WARN&quot;)</code>  （详见<code>ex3.pdf</code>）。</p><ol><li><p>切换到<code>conf</code> 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/conf</span><br></pre></td></tr></table></figure></li><li><p>设置配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> log4j2.properties.template log4j.properties</span><br><span class="line">vim log4j2.properties</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">status = error</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">property</span>.LOG_HOME=/output/logs</span><br><span class="line">   <span class="built_in">property</span>.BACKUP_HOME=backup</span><br><span class="line">   <span class="built_in">property</span>.SERVER_NAME=buddie-Service</span><br><span class="line">   <span class="built_in">property</span>.EVERY_FILE_SIZE=10M</span><br><span class="line">   <span class="built_in">property</span>.OUTPUT_LOG_LEVEL=INFO</span><br><span class="line">   <span class="built_in">property</span>.FILE_MAX=<span class="number">10</span></span><br><span class="line">   </span><br><span class="line">   appender.console.<span class="built_in">type</span> = Console</span><br><span class="line">   appender.console.name = STDOUT</span><br><span class="line">   appender.console.layout.<span class="built_in">type</span> = PatternLayout</span><br><span class="line">   appender.console.layout.pattern = %m%n</span><br><span class="line">   </span><br><span class="line">   appender.rolling.<span class="built_in">type</span>=RollingFile</span><br><span class="line">   appender.rolling.name=RollingFileAll</span><br><span class="line">   appender.rolling.<span class="built_in">filter</span>.threshold.level = trace</span><br><span class="line">   appender.rolling.<span class="built_in">filter</span>.threshold.<span class="built_in">type</span> = ThresholdFilter</span><br><span class="line">   appender.rolling.fileName=$&#123;LOG_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_<span class="built_in">all</span>.log</span><br><span class="line">   appender.rolling.filePattern=$&#123;LOG_HOME&#125;/dev_$&#123;BACKUP_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_<span class="built_in">all</span>.%d&#123;yyyy-MM-dd-HH&#125;.log</span><br><span class="line">   appender.rolling.layout.<span class="built_in">type</span>=PatternLayout</span><br><span class="line">   appender.rolling.layout.pattern=%d %p %C&#123;<span class="number">1.</span>&#125; [%t] %m%n</span><br><span class="line">   appender.rolling.policies.<span class="built_in">type</span>=Policies</span><br><span class="line">   appender.rolling.policies.time.<span class="built_in">type</span>=TimeBasedTriggeringPolicy</span><br><span class="line">   appender.rolling.policies.time.interval=<span class="number">2</span></span><br><span class="line">   appender.rolling.policies.time.modulate=true</span><br><span class="line">   appender.rolling.policies.size.<span class="built_in">type</span>=SizeBasedTriggeringPolicy</span><br><span class="line">   appender.rolling.policies.size.size=$&#123;EVERY_FILE_SIZE&#125;</span><br><span class="line">   appender.rolling.strategy.<span class="built_in">type</span>=DefaultRolloverStrategy</span><br><span class="line">   </span><br><span class="line">   appender.error.<span class="built_in">type</span>=RollingFile</span><br><span class="line">   appender.error.name=RollingFileError</span><br><span class="line">   appender.error.<span class="built_in">filter</span>.threshold.level = error</span><br><span class="line">   appender.error.<span class="built_in">filter</span>.threshold.<span class="built_in">type</span> = ThresholdFilter</span><br><span class="line">   appender.error.fileName=$&#123;LOG_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_error.log</span><br><span class="line">   appender.error.filePattern=$&#123;LOG_HOME&#125;/dev_$&#123;BACKUP_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_error.%d&#123;yyyy-MM-dd-HH&#125;.log</span><br><span class="line">   appender.error.layout.<span class="built_in">type</span>=PatternLayout</span><br><span class="line">   appender.error.layout.pattern=%d %p %C&#123;<span class="number">1.</span>&#125; [%t] %m%n</span><br><span class="line">   appender.error.policies.<span class="built_in">type</span>=Policies</span><br><span class="line">   appender.error.policies.time.<span class="built_in">type</span>=TimeBasedTriggeringPolicy</span><br><span class="line">   appender.error.policies.time.interval=<span class="number">2</span></span><br><span class="line">   appender.error.policies.time.modulate=true</span><br><span class="line">   appender.error.policies.size.<span class="built_in">type</span>=SizeBasedTriggeringPolicy</span><br><span class="line">   appender.error.policies.size.size=$&#123;EVERY_FILE_SIZE&#125;</span><br><span class="line">   appender.error.strategy.<span class="built_in">type</span>=DefaultRolloverStrategy</span><br><span class="line">   </span><br><span class="line">   appender.charge.<span class="built_in">type</span>=RollingFile</span><br><span class="line">   appender.charge.name=RollingFileCharge</span><br><span class="line">   appender.charge.<span class="built_in">filter</span>.threshold.level = trace</span><br><span class="line">   appender.charge.<span class="built_in">filter</span>.threshold.<span class="built_in">type</span> = ThresholdFilter</span><br><span class="line">   appender.charge.fileName=$&#123;LOG_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_charge.log</span><br><span class="line">   appender.charge.filePattern=$&#123;LOG_HOME&#125;/dev_$&#123;BACKUP_HOME&#125;/dev_$&#123;SERVER_NAME&#125;_charge.%d&#123;yyyy-MM-dd-HH&#125;.log</span><br><span class="line">   appender.charge.layout.<span class="built_in">type</span>=PatternLayout</span><br><span class="line">   appender.charge.layout.pattern=%d %p %C&#123;<span class="number">1.</span>&#125; [%t] %m%n</span><br><span class="line">   appender.charge.policies.<span class="built_in">type</span>=Policies</span><br><span class="line">   appender.charge.policies.time.<span class="built_in">type</span>=TimeBasedTriggeringPolicy</span><br><span class="line">   appender.charge.policies.time.interval=<span class="number">2</span></span><br><span class="line">   appender.charge.policies.time.modulate=true</span><br><span class="line">   appender.charge.policies.size.<span class="built_in">type</span>=SizeBasedTriggeringPolicy</span><br><span class="line">   appender.charge.policies.size.size=$&#123;EVERY_FILE_SIZE&#125;</span><br><span class="line">   appender.charge.strategy.<span class="built_in">type</span>=DefaultRolloverStrategy</span><br><span class="line">   </span><br><span class="line">   logger.activity.name = buddie.activity</span><br><span class="line">   logger.activity.level = debug</span><br><span class="line">   logger.activity.additivity = false</span><br><span class="line">   logger.activity.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   logger.activity.appenderRef.error.ref = RollingFileError</span><br><span class="line">   logger.activity.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   </span><br><span class="line">   logger.login.name = buddie.login</span><br><span class="line">   logger.login.level = debug</span><br><span class="line">   logger.login.additivity = false</span><br><span class="line">   logger.login.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   logger.login.appenderRef.error.ref = RollingFileError</span><br><span class="line">   logger.login.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   </span><br><span class="line">   logger.charge.name = buddie.charge</span><br><span class="line">   logger.charge.level = trace</span><br><span class="line">   logger.charge.additivity = false</span><br><span class="line">   logger.charge.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   logger.charge.appenderRef.error.ref = RollingFileError</span><br><span class="line">   logger.charge.appenderRef.charge.ref = RollingFileCharge</span><br><span class="line">   logger.charge.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   </span><br><span class="line">   rootLogger.level = info</span><br><span class="line">   rootLogger.appenderRef.stdout.ref = STDOUT</span><br><span class="line">   rootLogger.appenderRef.<span class="built_in">all</span>.ref = RollingFileAll</span><br><span class="line">   rootLogger.appenderRef.error.ref = RollingFileError</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><p>   <img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/3ZNGEld1BuSQihL.png" alt="1580093095312"></p><h2 id="3-实验流程"><a href="#3-实验流程" class="headerlink" title="3 实验流程"></a>3 实验流程</h2><h3 id="（已弃用）3-0-命令行下完成实验"><a href="#（已弃用）3-0-命令行下完成实验" class="headerlink" title="（已弃用）3.0 命令行下完成实验"></a>（已弃用）3.0 命令行下完成实验</h3><blockquote><p>:warning: <strong>该小节编写、调试代码方式已被弃用，采用远程开发模式</strong> :warning: </p><p><code>2021-12-20</code>：建议大家使用<strong>远程开发</strong>，进行代码编写，实验调试等。远程开发教程请参考：2.2节 【强烈建议-远程开发】。</p></blockquote><p>在实验开始之前，我们建议你按照以下流程完成实验：</p><ol><li><strong>命令行</strong> 下完成代码 <strong>单元测试</strong></li><li>单元测试无误，将代码填充在相应给出的<code>py</code> 文件函数中</li><li><code>spark-submit</code> 方式提交代码</li></ol><blockquote><p>:slightly_smiling_face: 如何在命令行下完成单元测试？</p></blockquote><ol><li><p>启动 <code>pyspark</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">bin/pyspark</span><br></pre></td></tr></table></figure><blockquote><p>:warning:  后续实验都是在集群环境下（本次实验不需要），启动<code>pyspark</code>应该按以下方式：</p><ul><li><p>启动集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动hadoop集群</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/hadoop  </span><br><span class="line">sbin/start-all.sh</span><br><span class="line"><span class="comment"># 启动spark集群</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">sbin/start-master.sh</span><br><span class="line">sbin/start-slaves.sh</span><br></pre></td></tr></table></figure></li><li><p>启动<code>pyspark</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/pyspark --master spark://master:7077</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>命令行下单元测试</p><p>例如，本次实验要求你完成<code>jiebaCut</code>函数编写：</p><blockquote><p>完成下列指定位置编码，使得<code>str</code> 为所有答案拼接而成的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jiebaCut</span>(<span class="params">answers_filePath</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    结巴分词</span></span><br><span class="line"><span class="string">    :param answers_filePath: answers.txt路径</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取answers.txt</span></span><br><span class="line">    answersRdd = sc.textFile(answers_filePath) <span class="comment"># answersRdd每一个元素对应answers.txt每一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 利用SpardRDD reduce()函数,合并所有回答</span></span><br><span class="line">    <span class="comment"># 【现在你应该完成下面函数编码】</span></span><br><span class="line">    <span class="built_in">str</span> = answersRdd.reduce(<span class="keyword">lambda</span> )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># jieba分词</span></span><br><span class="line">    words_list = jieba.lcut(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> words_list</span><br></pre></td></tr></table></figure><p>:warning: 命令行模式下，不用设置 <code>SparkContext、SparkSession</code>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf = SparkConf().setAppName(<span class="string">&quot;ex2&quot;</span>).setMaster(<span class="string">&quot;local&quot;</span>)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br></pre></td></tr></table></figure><p>会自动生成实例<code>sc</code>，可直接使用！</p></blockquote><p>首先定义<code>answers_filePath</code> ，查询此前代码指定按照如下方式进行拼接：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/ONIJoVzw9EcGWqf.png" alt="1580526312394"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; answers_filePath = <span class="string">&#x27;file:///home/hadoop/Experiment/Ex2_WordCount/src/answers.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>按照流程读入文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; answersRdd = sc.textFile(answers_filePath)</span><br><span class="line">&gt;&gt;&gt; answersRdd.take(10)  <span class="comment"># 展示前10行数据验证</span></span><br></pre></td></tr></table></figure><p>现在你可以尝试在命令行下 <strong>实时交互</strong> 完成  <code>str = answersRdd.reduce(lambda )</code> 这行代码完整编写。</p><p>例如，你可以如此进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; answersRdd.reduce(lambda a,b: a+b)</span><br><span class="line"><span class="string">&#x27;★★★更新于4个月以后★7月14日晚★★★写这个答案时，刚刚过完春节，在家被催婚心烦意乱，随手刷到，一时兴起...&#x27;</span></span><br></pre></td></tr></table></figure><p>会实时显示交互结果，验证是否编码正确。</p></li><li><p>提交代码</p><p>在命令行下单元测试后，便可以填写在相应<code>py</code> 文件中。</p><p>最后通过 <code>spark-submit</code>  方式提交代码。相应如何提交，在实验后有详细介绍，这里不再赘述。</p></li></ol><h3 id="3-1-数据集介绍"><a href="#3-1-数据集介绍" class="headerlink" title="3.1  数据集介绍"></a>3.1  数据集介绍</h3><blockquote><p>本次实验数据集来源于2019级研究生@<strong><em>W.H. Huang</em></strong>，数据集包含了知乎全站 <strong>择偶观</strong> 相关问题下所有 <em><u>答案 &amp;作者&amp;年龄&amp;地区等信息</u></em> 。原<strong>完整</strong>数据存储于<code>mysql</code>数据库，出于简化实验数据部署等目的，本次实验<strong>仅使用其中部分数据</strong>以<code>txt</code>文本形式展示。</p></blockquote><p>数据集 <code>answers.txt</code> 每一行代表一个完整回答，一共有3W条回答，如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/emVwLuQxP7DHIi9.png" alt="1580057443238"></p><p>每一条回答均已去除图片、视频URL、HTML标签等。</p><h3 id="3-2-WordCount-py"><a href="#3-2-WordCount-py" class="headerlink" title="3.2 WordCount.py"></a>3.2 WordCount.py</h3><h4 id="3-2-1-完成编码"><a href="#3-2-1-完成编码" class="headerlink" title="3.2.1 完成编码"></a>3.2.1 完成编码</h4><p>你现在应该独立完成<code>WordCount.py</code> 编码，可在服务器上查看：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/AHPiBwYqOWoVeM5.png" alt="1580059797013"></p><p><code>WordCount.py</code> 有<code>3</code>个函数，它们的作用如下：</p><ul><li><code>getStopWords</code> ：读取<code>stop_words.txt</code> 所有停用词，返回一个 <code>python List</code></li><li><code>jiebaCut</code> : 将所有答案合并，并进行分词，返回一个 <code>python List</code></li><li><code>wordcout</code> : 核心函数，利用<code>SparkRdd</code> 完成词频统计</li></ul><h5 id="jiebaCut"><a href="#jiebaCut" class="headerlink" title="jiebaCut"></a><code>jiebaCut</code></h5><p>完成下列指定位置编码，使得<code>str</code> 为所有答案拼接而成的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jiebaCut</span>(<span class="params">answers_filePath</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    结巴分词</span></span><br><span class="line"><span class="string">    :param answers_filePath: answers.txt路径</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取answers.txt</span></span><br><span class="line">    answersRdd = sc.textFile(answers_filePath) <span class="comment"># answersRdd每一个元素对应answers.txt每一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 利用SpardRDD reduce()函数,合并所有回答</span></span><br><span class="line">    <span class="comment"># 【现在你应该完成下面函数编码】</span></span><br><span class="line">     <span class="built_in">str</span> = answersRdd.reduce(<span class="keyword">lambda</span>  )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># jieba分词</span></span><br><span class="line">    words_list = jieba.lcut(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> words_list</span><br></pre></td></tr></table></figure><h5 id="wordcout"><a href="#wordcout" class="headerlink" title="wordcout"></a><code>wordcout</code></h5><p>完成下面指定位置编码，使得<code>resRdd</code> 包含所有词频统计结果，且降序排列。</p><p>打印<code>resRdd</code> 前十个元素应该为如下结果，<code>resRdd.take(10)</code> :</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/TCVPya3An1iYRG9.png" alt="1580060016321"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordcount</span>(<span class="params">isvisualize=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对所有答案进行</span></span><br><span class="line"><span class="string">    :param visualize: 是否进行可视化</span></span><br><span class="line"><span class="string">    :return: 将序排序结果RDD</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取停用词表</span></span><br><span class="line">    stopwords = getStopWords(SRCPATH + <span class="string">&#x27;stop_words.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结巴分词</span></span><br><span class="line">    words_list = jiebaCut(<span class="string">&quot;file://&quot;</span> + SRCPATH + <span class="string">&quot;answers.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 词频统计</span></span><br><span class="line">    wordsRdd = sc.parallelize(words_list)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># wordcount：去除停用词等同时对最后结果按词频进行排序</span></span><br><span class="line">    <span class="comment"># 完成SparkRDD操作进行词频统计</span></span><br><span class="line">    <span class="comment"># 提示：你应该依次使用</span></span><br><span class="line">    <span class="comment">#      1.filter函数进行停用词过滤&amp;去除长度=1的词汇</span></span><br><span class="line">    <span class="comment">#      2.map进行映射，如[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;a&#x27;] --&gt; [(&#x27;a&#x27;,1),(&#x27;b&#x27;,1),(&#x27;a&#x27;,1)] </span></span><br><span class="line">    <span class="comment">#      3.reduceByKey相同key进行合并 [(&#x27;a&#x27;,2),(&#x27;b&#x27;,1)] </span></span><br><span class="line">    <span class="comment">#      4.sortBy进行排序，注意应该是降序排序</span></span><br><span class="line">    <span class="comment">#【现在你应该完成下面函数编码】</span></span><br><span class="line">    resRdd = wordsRdd.<span class="built_in">filter</span>(<span class="keyword">lambda</span> word: ) \</span><br><span class="line">                     .<span class="built_in">filter</span>(<span class="keyword">lambda</span> word: ) \</span><br><span class="line">                     .<span class="built_in">map</span>(<span class="keyword">lambda</span> word: ) \</span><br><span class="line">                     .reduceByKey(<span class="keyword">lambda</span> a, b: ) \</span><br><span class="line">                     .sortBy(ascending=<span class="literal">False</span>, numPartitions=<span class="literal">None</span>,keyfunc=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])\ </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化展示</span></span><br><span class="line">    <span class="keyword">if</span> isvisualize:</span><br><span class="line">        v = visualize()</span><br><span class="line">        <span class="comment"># 饼状图可视化</span></span><br><span class="line">        pieDic = v.rdd2dic(resRdd,<span class="number">10</span>)</span><br><span class="line">        v.drawPie(pieDic)</span><br><span class="line">        <span class="comment"># 词云可视化</span></span><br><span class="line">        wwDic = v.rdd2dic(resRdd,<span class="number">50</span>)</span><br><span class="line">        v.drawWorcCloud(wwDic)</span><br><span class="line">    <span class="keyword">return</span>  resRdd</span><br></pre></td></tr></table></figure><h4 id="3-2-2-提交代码"><a href="#3-2-2-提交代码" class="headerlink" title="3.2.2 提交代码"></a>3.2.2 提交代码</h4><p>此时主函数代码，设置可视化为<code>False</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行词频统计，不进行可视化</span></span><br><span class="line">    resRdd = wordcount(isvisualize=False)</span><br><span class="line">    <span class="built_in">print</span>(resRdd.take(10))  <span class="comment"># 查看前10个</span></span><br></pre></td></tr></table></figure><ol><li><p>切换到<code>spark</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br></pre></td></tr></table></figure></li><li><p>提交代码（单机模式）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit /home/hadoop/Experiment/Ex2_WordCount/WordCount.py</span><br></pre></td></tr></table></figure><blockquote><p>:warning: 如果启动了集群需要先关闭，因为<strong>本次实验并非在集群环境下运行</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure></blockquote></li><li><p>查看结果</p><p>你应该得到如下结果：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/gQeIUcVjBlaiHoN.png" alt="1580543879036"></p></li></ol><h3 id="3-3-visualize-py"><a href="#3-3-visualize-py" class="headerlink" title="3.3 visualize.py"></a>3.3 visualize.py</h3><p>在本节你应该完成对<code>visualize.py</code> 核心代码编写。</p><h4 id="3-3-1-完成编码"><a href="#3-3-1-完成编码" class="headerlink" title="3.3.1 完成编码"></a>3.3.1 完成编码</h4><p>可在服务器上查看<code>visualize.py</code> 文件如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/hNYsGkQwReicIoE.png" alt="1580060759868"></p><p><code>visualize.py</code> 一共有<code>3</code>个函数，它们的作用如下：</p><ul><li><code>rdd2dic</code> ： 将<code>resRdd</code>转换为<code>python Dic</code>，并截取指定长度<code>topK</code></li><li><code>drawWorcCloud</code> ：进行词云可视化，同时保存结果</li><li><code>drawPie</code> ： 进行饼图可视化，同时保存结果</li></ul><h5 id="rdd2dic"><a href="#rdd2dic" class="headerlink" title="rdd2dic"></a><code>rdd2dic</code></h5><p>完成下面指定位置编码，将<code>resRDD</code>转换为<code>python Dic</code> ，并截取指定长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rdd2dic</span>(<span class="params">self,resRdd,topK</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将RDD转换为Dic，并截取指定长度topK</span></span><br><span class="line"><span class="string">    :param resRdd: 词频统计降序排序结果RDD</span></span><br><span class="line"><span class="string">    :param topK: 截取的指定长度</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 提示：SparkRdd有函数可直接转换</span></span><br><span class="line">    <span class="comment">#【现在你应该完成下面函数编码】</span></span><br><span class="line">    </span><br><span class="line">    resDic =              </span><br><span class="line">    <span class="comment"># 截取字典前K个</span></span><br><span class="line">    K = <span class="number">0</span></span><br><span class="line">    wordDicK = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> resDic.items():</span><br><span class="line">        <span class="comment"># 完成循环截取字典</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> wordDicK</span><br></pre></td></tr></table></figure><h4 id="3-3-2-提交代码"><a href="#3-3-2-提交代码" class="headerlink" title="3.3.2 提交代码"></a>3.3.2 提交代码</h4><p>此时主函数代码，设置可视化为<code>True</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行词频统计，并可视化</span></span><br><span class="line">    resRdd = wordcount(isvisualize=True)</span><br></pre></td></tr></table></figure><ol><li><p>切换到<code>spark</code>目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br></pre></td></tr></table></figure></li><li><p>提交代码</p><blockquote><p>依旧强调，非特殊说明不要在root用户执行代码，可能会出现以下错误：</p><p>“ERROR:zygote_host_impl_linux.cc (90)] Running as root without —no-sandbox is not supported.“</p><p>本次操作是在hadoop用户下。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit /home/hadoop/Experiment/Ex2_WordCount/WordCount.py</span><br></pre></td></tr></table></figure></li><li><p>问题解决</p><ul><li><p><strong>[ERROR#1] selenium. common. exception. webdriver exception: message: chrome not reachable</strong></p><p>通常是因为chromedriver程序占用了端口，控制台登陆重启服务器即可。相关讨论可见 <a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/5">issue#5 @lympassion</a></p></li><li><p><strong>[ERROR#2]  Operation not permitted</strong></p><blockquote><p>感谢<a href="https://github.com/a-fly-fly-bird">a-fly-fly-bird</a> 同学提供的解决方案。</p></blockquote><ol><li><p><strong>jieba.cache操作不足</strong> ：PermissionError: [Errno 1] Operation not permitted: ‘/tmp/tmpg255ml7f’ -&gt; ‘/tmp/jieba.cache’</p><p>这是因为 jieba 默认情况下在 /tmp 下存储缓存文件，然而不是 root 用户，权限不够。解决办法是修改默认缓存文件的目录，把缓存文件放在用户的目录下面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/lib/python3.6/site-packages/jieba/__init__.py</span><br></pre></td></tr></table></figure><p>将self.tmp_dir 赋值为用户目录下的任意目录，如下图：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/140518379-b7c93055-df45-4409-8e96-4f1ebfcbd7f5.png" alt="image"></p></li><li><p><strong>render.html权限不够</strong> ：Permission denied: ‘render.html’</p><p>修改render.html权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 render.html</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>[ERROR#3]  运行chromedriver生成echarts图片报错</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/140520039-07bcc908-5d52-47ee-a2a4-03b62eb210a9.png" alt="image"></p><p>重新安装snapshot-selenium即可解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 uninstall snapshot-selenium</span><br><span class="line">pip3 install snapshot-selenium</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看结果</p><p>查看目录 <code>/home/hadoop/Experiment/Ex2_WordCount/results</code> ：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/tusdOxpvHlhFCYT.png" alt="1580061469320"></p><p>可以看出：<code>身高、家庭、性格、父母、学历</code> 等是青年群体择偶最在意的几个特质。</p></li></ol><h2 id="4-扩展实验"><a href="#4-扩展实验" class="headerlink" title="4 扩展实验"></a>4 扩展实验</h2><p>根据第2节：在本次实验我们给予学有余力的同学，在完成本次实验的基础上提出了扩展要求。</p><p>【注】加分后总分不超过100分。</p><div class="table-container"><table><thead><tr><th style="text-align:center">扩展要求</th><th style="text-align:center">加分</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">1. 使用分布式完成本次实验</td><td style="text-align:center">+5</td><td style="text-align:center">可参考ex3~ex4</td></tr><tr><td style="text-align:center">2. 扩充原有数据集（100M以上），或基于新的数据集进行实验</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据数据量、质量、难度给分</td></tr><tr><td style="text-align:center">3. 新增更多可视化，如柱状图等</td><td style="text-align:center">+5~+10</td><td style="text-align:center">根据可视化工作量给分</td></tr><tr><td style="text-align:center">4.使用更好的算法分析数据，如应用深度学习模型Bert</td><td style="text-align:center">+10</td><td style="text-align:center">有对比实验更好</td></tr></tbody></table></div><p>当然，<strong>如果你有更好的idea</strong>来完善更新本次实验，请联系老师或助教，我们还会考虑为你申请本年度的优秀课设（每一年都有同学通过该方式获得优秀课设）。</p><p>详情你可参考：<a href="https://github.com/Wanghui-Huang/CQU_bigdata">CQU_bigdata-开源贡献</a>。</p><h2 id="5-实验小结"><a href="#5-实验小结" class="headerlink" title="5 实验小结"></a>5 实验小结</h2><p>本次实验中你使用Hadoop&amp;Spark编写了自己第一个项目，相信你一定有所收获。当然，你还体验了下远程开发的快感。</p><p>接下来的实验，你将会进一步学习在分布式集群下进行大数据分析，如：在集群执行任务、<code>hdfs</code>的使用等。同时你也将开始了解基本机器学习算法在大数据分析的应用，这将包括 <code>Kmeans</code>、<code>SVM</code> 等经典机器学习算法。</p><p>我们将尽量设计有趣、生动的实例来帮助你理解。最后，恭喜你完成第一个在基于<code>Spark</code>平台的大数据分析小项目，希望你从中获得了不少乐趣 :) 。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux学习 </tag>
            
            <tag> 大数据导论 </tag>
            
            <tag> 华为云学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Brigram模型用于预测</title>
      <link href="/2022/10/21/NLP%E5%AD%A6%E4%B9%A01/"/>
      <url>/2022/10/21/NLP%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h5><font face='楷体'>    1、    基于训练语料，训练一个基于字的Bigram语言模型。当用户输入某个字序列，程序可以自动推荐该序列的后一个字（依次列出概率最大的5个可能字选项），根据提示用户选择某个字后，程序可以继续推荐下一个字的列表。例如：输入“长江大”，程序猜测下一个可能的字为“桥”、“河”、“学”、“道”等。<br>    要求：（1）要求至少使用一种平滑方法。（2）提交电子文档一份（word），内含两部分内容：程序源码文本，程序运行结果截图（至少包含三个测试语句运行结果）；（3）同时提交源程序文件（可采用任意语言开发）。<br><font face='楷体' color=red>    在这里我使用的是美团评论的数据集，具体地址找不到了。主要是为我们国创项目来学一些比较新的东西，然后基于老师的作业来做的一些东西。希望大家只是借鉴，要有自己的灵感，也欢迎交流！后续会周更</font>    </font></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#构建数据库，并将最终数据库保存为一个npy文件！</span></span><br><span class="line"><span class="number">2.</span>doubleWords = &#123;&#125;  </span><br><span class="line"><span class="number">3.</span><span class="keyword">def</span> <span class="title function_">train02</span>(<span class="params">filename</span>):  </span><br><span class="line"><span class="number">4.</span>    doubleWords_pre=&#123;&#125;  </span><br><span class="line"><span class="number">5.</span>    f=<span class="built_in">open</span>(filename,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line"><span class="number">6.</span>    <span class="comment">#一共有多少个句子  </span></span><br><span class="line"><span class="number">7.</span>    num=<span class="number">0</span>  </span><br><span class="line"><span class="number">8.</span>    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():  </span><br><span class="line"><span class="number">9.</span>        <span class="comment"># 匹配所有中文形成一个list包,按符号分割出所有的字符  </span></span><br><span class="line"><span class="number">10.</span>        line1 = re.findall(<span class="string">&#x27;[\u4e00-\u9fa5]+&#x27;</span>, line)  </span><br><span class="line"><span class="number">11.</span>        <span class="keyword">for</span> words <span class="keyword">in</span> line1:  </span><br><span class="line"><span class="number">12.</span>            <span class="comment">#存前一个字符  </span></span><br><span class="line"><span class="number">13.</span>            words1=<span class="string">&#x27;B&#x27;</span>+words+<span class="string">&#x27;E&#x27;</span>  </span><br><span class="line"><span class="number">14.</span>            pre=<span class="string">&#x27; &#x27;</span>  </span><br><span class="line"><span class="number">15.</span>            <span class="comment">#计算一个字的频数和两个字连续出现的频数  </span></span><br><span class="line"><span class="number">16.</span>            <span class="keyword">for</span> word <span class="keyword">in</span> words1:  </span><br><span class="line"><span class="number">17.</span>                <span class="keyword">if</span> pre != <span class="string">&#x27; &#x27;</span>:  </span><br><span class="line"><span class="number">18.</span>                    <span class="keyword">if</span> pre <span class="keyword">in</span> doubleWords_pre:  </span><br><span class="line"><span class="number">19.</span>                        <span class="keyword">if</span> word <span class="keyword">in</span> doubleWords_pre[pre]:  </span><br><span class="line"><span class="number">20.</span>                            doubleWords_pre[pre][word]+=<span class="number">1</span>  </span><br><span class="line"><span class="number">21.</span>                        <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">22.</span>                            doubleWords_pre[pre][word]=<span class="number">1</span>  </span><br><span class="line"><span class="number">23.</span>                    <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">24.</span>                        doubleWords_pre[pre]=&#123;&#125;  </span><br><span class="line"><span class="number">25.</span>                pre=word  </span><br><span class="line"><span class="number">26.</span>            num+=<span class="number">1</span>  </span><br><span class="line"><span class="number">27.</span>    f.close()  </span><br><span class="line"><span class="number">28.</span>    <span class="comment"># 保存初始概率文件  </span></span><br><span class="line"><span class="number">29.</span>    np.save(<span class="string">&quot;data/doubleWords_pre&quot;</span>, doubleWords_pre)  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#采用平滑处理方法+二元文法  </span></span><br><span class="line"><span class="number">2.</span><span class="keyword">def</span> <span class="title function_">fun1</span>(<span class="params">worda ,wordb</span>):  </span><br><span class="line"><span class="number">3.</span>    <span class="keyword">if</span> worda <span class="keyword">in</span> doubleWords:  </span><br><span class="line"><span class="number">4.</span>        <span class="keyword">if</span> wordb <span class="keyword">in</span> doubleWords[worda]:  </span><br><span class="line"><span class="number">5.</span>            <span class="built_in">sum</span>=<span class="number">0</span>  </span><br><span class="line"><span class="number">6.</span>        <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">7.</span>            doubleWords[worda][wordb]=<span class="number">0</span>  </span><br><span class="line"><span class="number">8.</span>    <span class="keyword">else</span>:  </span><br><span class="line"><span class="number">9.</span>        doubleWords[worda]=&#123;&#125;  </span><br><span class="line"><span class="number">10.</span>        doubleWords[worda][wordb]=<span class="number">0</span>  </span><br><span class="line"><span class="number">11.</span>    fenzi=doubleWords[worda][wordb]+<span class="number">1</span>  </span><br><span class="line"><span class="number">12.</span>    fenmu=<span class="number">0</span>  </span><br><span class="line"><span class="number">13.</span>    <span class="keyword">for</span> key <span class="keyword">in</span> doubleWords[worda]:  </span><br><span class="line"><span class="number">14.</span>        fenmu=fenmu+doubleWords[worda][key]+<span class="number">1</span>  </span><br><span class="line"><span class="number">15.</span>    doubleWords[worda][wordb]+=<span class="number">1</span>  </span><br><span class="line"><span class="number">16.</span>    <span class="keyword">return</span> (fenzi/fenmu)  </span><br><span class="line"><span class="number">17.</span>  </span><br><span class="line"><span class="number">18.</span><span class="comment">#采用二元文法计算概率,需要自己加&#x27;B&#x27;和&#x27;E&#x27;:  </span></span><br><span class="line"><span class="number">19.</span><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">word</span>):  </span><br><span class="line"><span class="number">20.</span>    <span class="built_in">sum</span>=<span class="number">1.0</span>  </span><br><span class="line"><span class="number">21.</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)-<span class="number">1</span>) :  </span><br><span class="line"><span class="number">22.</span>        <span class="built_in">sum</span>=<span class="built_in">sum</span>*fun1(word[i],word[i+<span class="number">1</span>])  </span><br><span class="line"><span class="number">23.</span>    <span class="keyword">return</span> <span class="built_in">sum</span>  </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">#预测结果  </span></span><br><span class="line"><span class="number">2.</span><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">word</span>):  </span><br><span class="line"><span class="number">3.</span>    preRes=&#123;&#125;  </span><br><span class="line"><span class="number">4.</span>    <span class="built_in">str</span>=word[<span class="built_in">len</span>(word)-<span class="number">1</span>]  </span><br><span class="line"><span class="number">5.</span>    s = <span class="built_in">sum</span>(doubleWords[<span class="built_in">str</span>].values())  </span><br><span class="line"><span class="number">6.</span>    <span class="keyword">for</span> key <span class="keyword">in</span> doubleWords[<span class="built_in">str</span>]:  </span><br><span class="line"><span class="number">7.</span>        <span class="keyword">if</span> key==<span class="string">&#x27;E&#x27;</span>:<span class="keyword">continue</span>  </span><br><span class="line"><span class="number">8.</span>        str1=<span class="built_in">str</span>+key+<span class="string">&#x27;E&#x27;</span>  </span><br><span class="line"><span class="number">9.</span>        preRes[key]=fun(str1)  </span><br><span class="line"><span class="number">10.</span>    <span class="keyword">return</span> preRes  </span><br><span class="line"><span class="number">11.</span>  </span><br><span class="line"><span class="number">12.</span><span class="comment">#将预测结果排序，选取前五个  </span></span><br><span class="line"><span class="number">13.</span><span class="keyword">def</span> <span class="title function_">Paixu</span>(<span class="params">word</span>):  </span><br><span class="line"><span class="number">14.</span>    Result=[]  </span><br><span class="line"><span class="number">15.</span>    preRes=predict(word)  </span><br><span class="line"><span class="number">16.</span>    preRes = <span class="built_in">sorted</span>(preRes.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)  </span><br><span class="line">   <span class="comment">#这考虑了语料库不足的情况！</span></span><br><span class="line"><span class="number">17.</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="number">5</span>,<span class="built_in">len</span>(preRes)):  </span><br><span class="line"><span class="number">18.</span>        Result.append(preRes[i][<span class="number">0</span>])  </span><br><span class="line"><span class="number">19.</span>    <span class="keyword">return</span> Result  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 国创贾旺旺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国创own </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器远程连接失败处理</title>
      <link href="/2022/10/16/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
      <url>/2022/10/16/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h5>    某天晚上突然遇到这个问题，远程连接怎么也连接不上，后来查了很多资料，终于发现了问题所在。具体如下</h5><h5>   我们在华为云网页打开使用VPN登录，并在命令行下输入如下命令：</h5><p><img src="https://s2.loli.net/2022/10/16/KexFyUlzfgn3VLa.png" alt="183df258fb3634b8ebc27f.png"></p><h5>   这个时候我们会发现如上问题，network和NetworkManager都没开。   <br>而NetworkManager 是一个为系统提供检测和配置功能以便自动连接到网络的程序。NetworkManager 的功能对无线和有线网络都很有用。对于无线网络，NetworkManager 偏好已知的无线网络，并能切换到最可靠的网络。能感知 NetworkManager 的应用程序可以切换在线和离线模式。这个可能是导致我们出现问题的最大弊端之一</h5><h5>    解决方法，请输入如下命令即可</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
            <tag> 华为云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文分词任务</title>
      <link href="/2022/10/08/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/10/08/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/08/DNTcU91LxlM3ufY.jpg" alt="扫描全能王 2022-10-08 13.40_1.jpg"></p><p><img src="https://s2.loli.net/2022/10/08/gpir1bytBIfQPo4.jpg" alt="扫描全能王 2022-10-08 13.40_2.jpg"></p><p><img src="https://s2.loli.net/2022/10/08/HPuGD1B6lb5rAKn.jpg" alt="扫描全能王 2022-10-08 13.40_3.jpg"></p><p><img src="https://s2.loli.net/2022/10/08/LbIEGTyAmeMhS2U.jpg" alt="扫描全能王 2022-10-08 13.40_4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Numpy存字典类型文件时再调用改文件时可能出现的问题</title>
      <link href="/2022/10/06/python/"/>
      <url>/2022/10/06/python/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">example_dict = &#123;(<span class="number">1</span>, <span class="number">0</span>): <span class="number">1</span>, (<span class="number">1</span>, <span class="number">1</span>): <span class="number">2</span>, (<span class="number">2</span>, <span class="number">0</span>): <span class="number">3</span>, (<span class="number">2</span>, <span class="number">1</span>): <span class="number">4</span>&#125;</span><br><span class="line">np.save(<span class="string">&#x27;filename&#x27;</span>, example_dict)</span><br><span class="line"></span><br><span class="line">loaded_dict = np.load(<span class="string">&#x27;filename.npy&#x27;</span>, allow_pickle=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(loaded_dict) <span class="comment"># Works just fine, prints out the example dict</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(loaded_arrs)) <span class="comment"># Outputs &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(loaded_dict.shape) <span class="comment"># Outputs ()</span></span><br><span class="line"><span class="built_in">print</span>(loaded_dict[(<span class="number">1</span>, <span class="number">0</span>)]) <span class="comment"># Does not work, Error below</span></span><br></pre></td></tr></table></figure><h4>    输出如下:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;(<span class="number">1</span>, <span class="number">0</span>): <span class="number">1</span>, (<span class="number">1</span>, <span class="number">1</span>): <span class="number">2</span>, (<span class="number">2</span>, <span class="number">0</span>): <span class="number">3</span>, (<span class="number">2</span>, <span class="number">1</span>): <span class="number">4</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line">()</span><br><span class="line">IndexError: too many indices <span class="keyword">for</span> array</span><br></pre></td></tr></table></figure><h4>    没错没错！就是这个问题卡了我一个小时，我真的是无语了，理解原理一个小时，写代码一个小时，查bug查了一个小时:写下这个问题提醒自己</h4><h4>   不要小瞧这个问题，我在运用HMM模型进行拼音转汉字的时候，它没有报错，但最后的输出真的痛彻我心扉。一个句子翻译的乱七八糟的，精度0.1都不到，最好的一个0.25</h4><h4> 下面是我们的解决办法:<br>  loaded_dict是一个numpy.ndarray，而不是字典。我们可以使用.item（）方法访问字典，</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loaded_dict.item()[(<span class="number">1</span>, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure><h4>如果要访问所有可以使用的词典值:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> loaded_dict.item().items():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wsl2 Linux子系统搭建</title>
      <link href="/2022/10/05/wsl2/"/>
      <url>/2022/10/05/wsl2/</url>
      
        <content type="html"><![CDATA[<h5><font face="楷体">1.使用WSL的优点:<br>(1)与在虚拟机下使用 Linux 相比，WSL 占用资源更少，更加流畅<br>(2)WSL 可以对 Windows 文件系统下的文件直接进行读写，文件传输更方便；<br>(3)剪贴板互通，可以直接在 Windows 下其它地方复制文本内容，粘贴到 WSL；    </font></h5><h5><font face="楷体">2.开启WSL支持:<br>使用管理员权限的Shell才能安装WSL。<br>(1)按下   Win+X，找到 Windows PowerShell (管理员)，并复制执行命令。    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure><h5><font face="楷体">以上命令会激活 WSL 服务，然后需要重启系统<br>重启之后，Win + R，输入 appwiz.cpl，左上角找到“启动或关闭 Windows 功能”，会看到这个选项处于选中状态。(备注)<br>备注:<br>其实吧，上面的命令就相当于手动去勾选这个功能。直接命令执行效率可能更高些。    </font></h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA2MTIyMDQwLnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">3.安装WSL发行版<br>在 Windows 应用商店搜索 ubuntu选择自己喜欢的版本，安装即可。<br>这里我选择的是 Ubuntu 18.04 LTS，之后的所有内容也是基于 WSL Ubuntu 编写。    </font></h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA2MTIyNzQzLnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">下载，安装之后，第一次打开会初始化一会<br>然后设置个用户名，密码    </font></h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA3MTk0NjQxLnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">4.apt换源<br>Debian / Ubuntu 的官方源在国内访问很慢，咱们更换为清华大学 TUNA 的软件源镜像。<br>(1)执行下面的命令，备份apt安装源    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h5><font face="楷体">(2)vim 编辑 sources.list     </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list </span><br></pre></td></tr></table></figure><h5><font face="楷体">将 sources.list 中的内容替换如下:(选择对应Ubuntu版本的，我这是Ubuntu 18.04 LTS)如果是其他版本的ubuntu，自行访问<a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" title="点击可跳转">清华大学开源软件镜像站</a>去查找对应版本的镜像配置    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><h5><font face="楷体">5.更新软件    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h5><font face="楷体">6.配置SSH服务器<br>    WSL 上的 SSH 服务器没有自动配置，需要手动重新安装，首先可以运行以下命令来检查    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh stop</span><br><span class="line">sudo /usr/sbin/sshd -d</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA3MTk0NjUwLnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">如果输出信息包括以上信息，即找不到 key，重新安装 openssh-server 就可以解决问题    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt purge openssh-server</span><br><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><h5><font face="楷体">然后需要配置 /etc/ssh/sshd_config，用 sudo 权限运行 vim 修改如下三个关键字    </font></h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA3MTk0NjU3LnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">7.重启ssh服务器即可,然后就可以使用 SSH 工具进行连接啦，本地直接 localhost 即可<br>    </font></h5><h5><font face="楷体">8.WSL2配置<br>WSL2优点:<br>(1).WSL2 附带了一个真实的 Linux 4.19 内核，能够带来完整的系统调用兼容性，并且能够直接借助自动更新进行升级维护，无需更新整个Windows Linux的子系统。<br>(2)同时，WSL2将比第一代的WSL1版本运行速度更快，提升了文件系统的I/O性能和与Linux的兼容性，且可本机直接运行 Docker 容器等<br>    <br>通过cmd查看目前WSL版本如下    </font></h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA3MTk0NzA5LnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">在安装WSL2之前必须启动“虚拟机平台”可选功能.<br> 以管理员身份打开PowerShell并运行如下命令，然后重新启动计算机    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><h5><font face="楷体">在 Powershell 中运行以下命令，将 WSL 2 设置为默认版本：    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.WSL 提供了版本转换工具，将 wsl1 转为 wsl2，</span></span><br><span class="line"><span class="comment"># 注意转换时间可能较长，耐心等待，如果时间太久没反应，时不时按下 Enter 看看有没有更新,注意是对应版本</span></span><br><span class="line">wsl --set-version Ubuntu-18.04 2</span><br><span class="line"><span class="comment"># 2.将 WSL2 设置为默认版本</span></span><br><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><h5><font face="楷体">现在我们运行wsl -l -v，看到 VERSION 已经是 2 了！<br>再次恭喜，我们已经成功将 WSL 1 升级为 WSL 2 了！！！<br>一个真正的 Linux 内核的系统已经在你的 Windows 里了！<br>    </font></h5><h5><font face="楷体">9.在WSL2子系统Ubuntu中安装Docker-CE，注意换平台了是在Ubuntu中安装    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -skSL https://mirror.azure.cn/repo/install-docker-ce.sh | sh -s -- --mirror AzureChinaCloud</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20veXVhbnNhaXNhaS9pbWFnZXJvb21zL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNjA3MTk1MTMxLnBuZw?x-oss-process=image/format,png" alt=""></p><h5><font face="楷体">10.启动Docker，查看Docker版本    </font></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br><span class="line">sudo docker version</span><br></pre></td></tr></table></figure><h5><font face="楷体">    11.远程连接VSCODE,这个不讲了，看一篇<a href="https://zhuanlan.zhihu.com/p/95678121" target="_blank" title="点击可跳转">参考文献</a>叭    </font></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看自己Ubuntuip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hostname -I</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/05/SPgjadXlrWeoBhH.png" alt="B8RY1__IJTAZYCA7__14RZI.png"></p><h5><font face="楷体">12.在陈泱宇学长的指导下，我们换一种新的方式，不需要密码登录。可以避免被别人破坏的风险，更加安全<br>(1)在扩展中搜索remote development并安装，会同时安装会同时安装上Remote_SSH、Remote_Containers、Remote_WSL    </font></h5><p><img src="https://s2.loli.net/2022/10/05/9qoS3df7HQmZXGD.png" alt=""></p><h5><font face="楷体">(2)使用快捷键Ctrl+Shift+P<br> New Window：使用WSL打开新的窗口；<br>Reopen Folder in WSL：将当前目录在WSL中打开；<br>New Window Using Distro：选择一个已安装的WSL发行版打开新窗口<br>    </font></h5><p><img src="https://s2.loli.net/2022/10/05/QbDle6cIfjVWwdo.png" alt=""></p><h5><font face="楷体">连接成功后，会在左下角看到按钮变成了:    </font></h5><p><img src="https://s2.loli.net/2022/10/05/kNDdH94o6SOK3qt.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统实验 </tag>
            
            <tag> Linux学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习:对数几率回归简写</title>
      <link href="/2022/09/23/%E5%9B%9E%E5%BD%92/"/>
      <url>/2022/09/23/%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1><center>一个简单的对数回归实例</center></h1><hr><h5>问题: 求西瓜数据集3.0上对数几率回归的结果</h5><p><img src="https://s2.loli.net/2022/09/23/hFdGcyO3q4oxnTm.png" alt="1663926623801.png"></p><h5>LogisticsRegression类</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#逻辑回归模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogisticsRegression</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化逻辑回归模型</span></span><br><span class="line"><span class="string">        θ向量</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.theta = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#定义sigmoid函数    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param x: 转换前的输入</span></span><br><span class="line"><span class="string">        :return: 转换后的概率</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用梯度下降法，不断更新θ值，训练模型具体过程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GD</span>(<span class="params">self,x,y,eta=<span class="number">1e-3</span>,Niters=<span class="number">1e4</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param x: 训练集特征数据，类型为ndarray</span></span><br><span class="line"><span class="string">        :param y: 训练集标签，类型为ndarray</span></span><br><span class="line"><span class="string">        :param eta: 学习率，类型为float</span></span><br><span class="line"><span class="string">        :param n_iters: 训练轮数，类型为int，默认值为10000</span></span><br><span class="line"><span class="string">        :return: 模型参数，类型为ndarray</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.theta = np.zeros(x.shape[<span class="number">1</span>])<span class="comment">#给theta赋初值，原始值都为0</span></span><br><span class="line">        Iiter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Iiter &lt; Niters:</span><br><span class="line">            gradient = (self.sigmoid(x.dot(self.theta))-y).dot(x)<span class="comment">#求当出当前梯度</span></span><br><span class="line">            self.theta = self.theta -eta*gradient                <span class="comment">#更新theta</span></span><br><span class="line">            Iiter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        :param x: 测试集特征数据，类型为ndarray</span></span><br><span class="line"><span class="string">        :return: 测试结果</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>        </span><br><span class="line">        a = self.sigmoid(x.dot(self.theta))<span class="comment">#通过sigmoid函数，将预测值变为概率值</span></span><br><span class="line">        <span class="comment">#当概率值大于0.5时，则置1，反之，置0</span></span><br><span class="line">        <span class="keyword">return</span> np.array(a &gt;= <span class="number">0.5</span>, dtype=<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">label, predict</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    :param label: 测试集标签数据，类型为ndarray</span></span><br><span class="line"><span class="string">    :param predict: 预测标签数据，类型为ndarray</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    label=label.astype(np.<span class="built_in">int</span>)                  <span class="comment">#将label转换为numpy.int类型</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(label == predict)            <span class="comment">#该函数求的是平均值</span></span><br></pre></td></tr></table></figure><h5>模型训练</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from LogisticsRegression import *</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">#读取数据，csv文件中最后一列为标签值，其他列都为特征值（这里带入自己的数据即可，注意每个变量代表的含义）</span><br><span class="line">data = pd.read_excel(&#x27;西瓜.xlsx&#x27;)</span><br><span class="line"></span><br><span class="line">#提取特征值和标签值</span><br><span class="line">X = data.iloc[:,1::-1]</span><br><span class="line">y = data.iloc[:,-1]</span><br><span class="line"></span><br><span class="line">#对数据进行标准化</span><br><span class="line">#mean/std可以查一查csdn</span><br><span class="line">X = (X-np.mean(X,axis=0))/np.std(X,axis=0)</span><br><span class="line">#对特征值加一列x0，x0的所有值为1，相当于偏离值b的系数,西瓜书上有</span><br><span class="line">X = np.hstack([np.ones(shape=(len(X),1)),X])</span><br><span class="line"></span><br><span class="line">#划分训练集与测试集，参数test_size设为0.2，random_state设为42</span><br><span class="line">#这里借用了机器学习的处理</span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(X,y,test_size = 0.2,random_state = 42)</span><br><span class="line">#建立模型，并训练模型</span><br><span class="line">Lr = LogisticsRegression()</span><br><span class="line">Lr.GD(x_train,y_train)</span><br><span class="line">#输出的是w1，w2，b三个参数</span><br><span class="line">print(&quot;w1,w2,b=&quot;,Lr.theta)</span><br><span class="line">#用测试数据集进行预测</span><br><span class="line">predict = Lr.predict(x_test)</span><br><span class="line">print(&quot;预测集:&quot;,predict)</span><br><span class="line">print(&quot;真值:&quot;,np.array(y_test))</span><br><span class="line">#评估预测的准确率</span><br><span class="line">score = score(y_test,predict)</span><br><span class="line">print(&quot;准确率:&quot;,score)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5>运行结果如下：</h5>![1663928663541.png](https://s2.loli.net/2022/09/23/iANbJHxmt3FLG21.png)<h5>    由于数据量比较少，我们的模型还是不错的。<br>    我只是为了完成作业。剩下的等后续实验再补录。</h5>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验一：环境搭建</title>
      <link href="/2022/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA2/"/>
      <url>/2022/09/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1  实验目的"></a>1  实验目的</h2><blockquote><p>本次实验预估耗时较长，因此将给出所有详细步骤，如若不能及时完成可在课后完成。</p></blockquote><p>通过本次实验，你应该完成以下部分：</p><ul><li>组内合作完成 <code>Hadoop &amp; Spark</code>单机版环境搭建</li><li>组内合作完成 <code>Hadoop &amp; Spark</code>分布式环境搭建</li></ul><p>最终需搭建相关详细环境如下：</p><ul><li>操作系统：<code>centOS 7.6.64</code>  </li><li>图形界面：<code>GNOME</code></li><li>语言环境：<code>python 3.6.8</code> </li><li>相关软件：<code>Hadoop  2.8.5</code> 、<code>Spark 2.4.4</code></li></ul><h2 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2 实验准备"></a>2 实验准备</h2><p>本次实验将详细介绍三种方式来搭建 <code>Hadoop &amp; Sapak</code>分布式环境 ：</p><ul><li>云服务器分布式搭建</li><li>伪分布式搭建</li><li>多台机器分布式搭建</li></ul><p>考虑到大家<code>IP</code>是动态分配（<code>DHCP</code>）, 没有使用固定IP。使用第三种方式 <em>多台实际机器搭建</em> 不方便。因此推荐大家使用前两种方式：云服务器分布式搭建、伪分布式搭建进行环境搭建。</p><h2 id="3-云服务器分布式搭建"><a href="#3-云服务器分布式搭建" class="headerlink" title="3 云服务器分布式搭建"></a>3 云服务器分布式搭建</h2><blockquote><p>出于最简化演示目的，本次搭建将采用两台云服务器进行<em>Hadoop+Spark</em> 详细搭建记录。</p><p>:slightly_smiling_face: 如果小组成员&gt;2，分布式搭建过程大同小异聪明如你应该知道怎么做。</p></blockquote><p>首先记录下小组组员各自服务器的 <u>内网IP&amp;公网IP</u> ，例如我的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">主机名</th><th style="text-align:center">内网IP</th><th style="text-align:center">外网IP</th></tr></thead><tbody><tr><td style="text-align:center">master</td><td style="text-align:center">172.30.0.7</td><td style="text-align:center">129.28.154.240</td></tr><tr><td style="text-align:center">slave01</td><td style="text-align:center">172.16.0.4</td><td style="text-align:center">134.175.210.3</td></tr></tbody></table></div><h3 id="3-1-Spark单机版搭建"><a href="#3-1-Spark单机版搭建" class="headerlink" title="3.1 Spark单机版搭建"></a>3.1 Spark单机版搭建</h3><blockquote><p>:warning: 请注意，<code>3.1.1</code> 部分需在小组成员在<strong>所有</strong>云服务器上完成。<code>3.1.2~3.1.4</code> 小节只需在<strong>一</strong>台云服务器完成即可（作为master节点那台服务器）。</p></blockquote><p>在进行Hadoop、Spark环境搭建前，我们需要进行一些准备工作。</p><h4 id="3-1-1-准备工作"><a href="#3-1-1-准备工作" class="headerlink" title="3.1.1 准备工作"></a>3.1.1 准备工作</h4><h5 id="1-配置用户"><a href="#1-配置用户" class="headerlink" title="1 配置用户"></a>1 配置用户</h5><p>该小节主要是创建<code>Hadoop</code> 用户。</p><ol><li><p>创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m hadoop -s /bin/bash          </span><br></pre></td></tr></table></figure><p>同时设置用户密码：（如 123456）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd hadoop</span><br></pre></td></tr></table></figure></li><li><p>配置权限</p><p>为了方便，给用户 <code>hadoop</code> 等同<code>root</code> 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo            <span class="comment"># 执行 visudo命令进入vim编辑</span></span><br></pre></td></tr></table></figure><p>找到如下位置，添加红框那一行配置权限：</p><p><img src="https://i.loli.net/2020/09/17/1owVFrmRuLg2MCP.png" alt="1575371320579"></p></li><li><p>切换用户</p><p>配置完成后，我们切换到hadoop用户下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su hadoop   <span class="comment"># 注意，不要使用root用户，以下全部切换到hadoop用户下操作</span></span><br></pre></td></tr></table></figure><p>:warning: 如非特殊说明，接下来所有命令都是Hadoop用户下完成！</p></li></ol><h5 id="2-配置SSH"><a href="#2-配置SSH" class="headerlink" title="2 配置SSH"></a>2 配置SSH</h5><blockquote><p>为什么要配置ssh？</p></blockquote><p>因为集群、单节点模式都需要用到 ssh登陆。同时每次登陆ssh都要输入密码是件蛮麻烦的事 ，我可以通过生成公钥配置来面密码登陆。</p><ol><li><p>生成密钥</p><p>为了生成 ~/.ssh 目录，我们直接通过执行下面命令会直接生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost   # 按提示输入yes，然后键入hadoop密码</span><br></pre></td></tr></table></figure><p>然后开始生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/          <span class="comment"># 切换目录到ssh下</span></span><br><span class="line">ssh-keygen -t rsa   <span class="comment"># 生成密钥</span></span><br></pre></td></tr></table></figure><p>生成密钥过程会有三个提示，不用管全部回车。</p></li><li><p>授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys  <span class="comment"># 加入授权</span></span><br></pre></td></tr></table></figure></li><li><p>修改权限</p><p>如果不修改文件<code>authorized_keys</code>权限为<code>600</code>，会出现访问拒绝情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ./authorized_keys    <span class="comment"># 修改文件权限</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost   <span class="comment"># ssh登陆</span></span><br></pre></td></tr></table></figure><p>不用输入密码，直接登陆成功则说明配置正确。</p><p><img src="https://i.loli.net/2020/09/17/k5xYOtBjz3yZVmJ.png" alt="1579770536641"></p></li></ol><h5 id="3-配置yum源"><a href="#3-配置yum源" class="headerlink" title="3 配置yum源"></a>3 配置yum源</h5><p>官方网站下载实在太慢，我们可以先配置一下阿里源来进行下载。</p><ol><li><p>切换到<code>yum</code> 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br></pre></td></tr></table></figure></li><li><p>备份下原repo文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> CentOS-Base.repo CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure></li><li><p>配置清华云repo文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/yum.repos.d/CentOS-Base.repo <span class="comment">#sudo 扩大权限</span></span><br><span class="line">i            <span class="comment">#修改文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件具体内容如下</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Updates</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/updates/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Extras</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/extras/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Plus</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="variable">$releasever</span>/centosplus/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>防止权限不足使用<code>sudo</code> 命令。</p></li><li><p>生成缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">   yum makecache</span><br></pre></td></tr></table></figure></li><li><p>升级yum更新包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-配置Java环境"><a href="#4-配置Java环境" class="headerlink" title="4 配置Java环境"></a>4 配置Java环境</h5><blockquote><p>最开始下载的是 <code>1.7</code>版本的JDK，后面出现的问题，重新下载 <code>1.8</code> 版本 JDK。</p></blockquote><p><em>hadoop2</em> 基于 <em>java</em> 运行环境，所以我们先要配置<em>java</em> 运行环境。</p><ol><li><p>安装 JDK </p><p>执行下面命令，经过实际测试前面几分钟一直显示镜像错误不可用。它会进行自己尝试别的源，等待一会儿就可以下载成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install java-1.8.0-openjdk java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure><p>:warning: 此时默认安装位置是  <code>/usr/lib/jvm/java-1.8.0-openjdk</code> </p><p>其实，查找安装路径，可以通过以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql java-1.8.0-openjdk-devel | grep <span class="string">&#x27;/bin/javac&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>rpm -ql &lt;RPM包名&gt;</code> ：查询指定RPM包包含的文件</li><li><code>grep &lt;字符串&gt;</code> ： 搜索包含指定字符的文件</li></ul></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc  <span class="comment"># vim编辑配置文件</span></span><br></pre></td></tr></table></figure><p>在文件最后面添加如下单独一行（指向 JDK 的安装位置），并保存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/1nXsHtKukCy4oAB.png" alt="1575379864251"></p><p>最后是环境变量生效，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc </span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span>     <span class="comment"># 检验变量值</span></span><br></pre></td></tr></table></figure><p>正常会输出 <code>2.</code>环境变量JDK配置路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>正确配置会输出java版本号。</p></li></ol><h5 id="5-安装python"><a href="#5-安装python" class="headerlink" title="5 安装python"></a>5 安装python</h5><blockquote><p>这里清华yum更新包中python已经为python3</p></blockquote><ol><li><p>yum查找python3</p><p>查找仓库存在的python3安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list python3</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/On2ues5Xpwl4TqG.png" alt="1575423838102"></p></li><li><p>yum 安装python3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python3.x86_64</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-1-2-hadoop-安装"><a href="#3-1-2-hadoop-安装" class="headerlink" title="3.1.2 hadoop 安装"></a>3.1.2 hadoop 安装</h4><blockquote><p>本文使用 <code>wget</code> 命令来下载 <code>hadoop</code> ：<a href="https://blog.csdn.net/qq_27870421/article/details/91951402">了解更多wget</a></p></blockquote><p>使用的是<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.10.1/">清华镜像站</a> , 下载 <code>hadoop</code> ：</p><p><img src="https://i.loli.net/2020/09/17/xsJyQa2oA3zfPWV.png" alt="1575378514451"></p><ol><li><p>下载</p><blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O hadoop-2.10.1.tar.gz https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.10.1/hadoop-2.10.1.tar.gz</span><br></pre></td></tr></table></figure><ul><li><code>wget -O &lt;指定下载文件名&gt; &lt;下载地址&gt;</code> </li></ul></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf hadoop-2.10.1.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p>把下载好的文件 <code>hadoop-2.10.1.tar.gz</code> 解压到 <code>/usr/local</code> 目录下</p></li><li><p>修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/   <span class="comment"># 切换到解压目录下</span></span><br><span class="line">sudo <span class="built_in">mv</span> ./hadoop-2.10.1/ ./hadoop      <span class="comment"># 将加压的文件hadoop-2.10.1重命名为hadoop</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R hadoop:hadoop ./hadoop  <span class="comment"># 修改文件权限</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop     <span class="comment"># 切换到hadoop目录下</span></span><br><span class="line">./bin/hadoop version     <span class="comment"># 输出hadoop版本号</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/vNQkbpg6eLBiGjW.png" alt="1579771673582"></p></li></ol><h4 id="3-1-3-spark安装"><a href="#3-1-3-spark安装" class="headerlink" title="3.1.3 spark安装"></a>3.1.3 spark安装</h4><p>在前我们已经安装了 <em>hadoop</em> ，现在我们来开始进行<em>spark</em> 安装。</p><blockquote><p>这次下载根据官网推荐使用的清华源。</p></blockquote><ol><li><p>下载</p><p>建议到官网下载地址：<a href="http://spark.apache.org/downloads.html">官网下载</a></p><p><img src="https://i.loli.net/2020/09/17/qGSENlCM2t1dmfU.png" alt="1575381612542"></p><ul><li>这样选择的版本可以使用于大部分 <code>hadoop</code>版本,但需要时间上，我下了3个小时</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O spark-3.3.1-bin-without-hadoop.tgz https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.3.1/spark-3.3.1-bin-without-hadoop.tgz </span><br></pre></td></tr></table></figure></li><li><p>解压</p><p>同前解压到 <code>/usr/local</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf spark-3.3.1-bin-without-hadoop.tgz -C /usr/local</span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local   <span class="comment"># 切换到解压目录</span></span><br><span class="line">sudo <span class="built_in">mv</span> ./spark-3.3.1-bin-without-hadoop ./spark  <span class="comment"># 重命名解压文件</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R hadoop:hadoop ./spark  <span class="comment"># 设置用户hadoop为目录spark拥有者</span></span><br></pre></td></tr></table></figure></li><li><p>配置spark环境</p><p>先切换到 <code>/usr/local/spark</code> ，（为了防止没权限，下面用<code>sudo</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line"><span class="built_in">cp</span> ./conf/spark-env.sh.template ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>编辑 <code>spark-env.sh</code> 文件 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>在第一行添加下面配置信息，使得Spark可以从Hadoop读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在<code>.bashrc</code>文件中添加如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-<span class="number">1.8</span><span class="number">.0</span>-openjdk  <span class="comment"># 之前配置的java环境变量</span></span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop    <span class="comment"># hadoop安装位置</span></span><br><span class="line">export SPARK_HOME=/usr/local/spark   </span><br><span class="line">export PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-<span class="number">0.10</span><span class="number">.7</span>-src.<span class="built_in">zip</span>:$PYTHONPATH           </span><br><span class="line">export PYSPARK_PYTHON=python3           <span class="comment"># 设置pyspark运行的python版本</span></span><br><span class="line">export PATH=$HADOOP_HOME/<span class="built_in">bin</span>:$SPARK_HOME/<span class="built_in">bin</span>:$PATH</span><br></pre></td></tr></table></figure><p>最后为了使得环境变量生效，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>测试是否运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">bin/run-example SparkPi</span><br></pre></td></tr></table></figure><p>执行会输出很多信息，也可以选择执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/run-example SparkPi 2&gt;&amp;1 | grep <span class="string">&quot;Pi is&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/DAvbtMa3HKoE1FW.png" alt="1579771989587"></p></li></ol><h4 id="3-1-4-测试"><a href="#3-1-4-测试" class="headerlink" title="3.1.4 测试"></a>3.1.4 测试</h4><ol><li><p>启动pyspark</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">bin/pyspark</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/KxHIT9dvgiA2EMc.png" alt="1579772051676"></p></li><li><p>简单测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 * 2 + 5</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">exit</span>()   <span class="comment">#退出</span></span><br></pre></td></tr></table></figure><p>使用<code>exit()</code> 命令可退出。</p></li></ol><h3 id="3-2-Hadoop-Spark-分布式环境搭建"><a href="#3-2-Hadoop-Spark-分布式环境搭建" class="headerlink" title="3.2 Hadoop+Spark 分布式环境搭建"></a>3.2 Hadoop+Spark 分布式环境搭建</h3><h4 id="3-2-1-准备工作"><a href="#3-2-1-准备工作" class="headerlink" title="3.2.1 准备工作"></a>3.2.1 准备工作</h4><h5 id="1-修改主机名"><a href="#1-修改主机名" class="headerlink" title="1 修改主机名"></a>1 修改主机名</h5><p>两台服务器一台作为master，一台作为slave。为了以示区分，我们分别修改它们的主机名：</p><ul><li><p>在master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br><span class="line">sudo reboot <span class="comment">#不要忘了</span></span><br></pre></td></tr></table></figure><p>编辑修改为：<code>master</code></p></li><li><p>在 slave01</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br><span class="line">sudo reboot  <span class="comment">#不要忘了</span></span><br></pre></td></tr></table></figure></li></ul><p>  编辑修改为：<code>slave01</code> </p><p>最后使用命令 <code>sudo reboot</code>重启，便会生效。</p><h5 id="2-修改host"><a href="#2-修改host" class="headerlink" title="2 修改host"></a>2 修改host</h5><blockquote><p>修改hosts目的：<em>可以使用云服务器名字访问，而不直接使用IP地址</em>  </p></blockquote><p>首先上自己的云服务器，记录下三台服务器的 <em>内网IP&amp;公网IP</em> </p><div class="table-container"><table><thead><tr><th style="text-align:center">主机名</th><th style="text-align:center">内网IP</th><th style="text-align:center">外网IP</th></tr></thead><tbody><tr><td style="text-align:center">master</td><td style="text-align:center">172.30.0.7</td><td style="text-align:center">129.28.154.240</td></tr><tr><td style="text-align:center">slave01</td><td style="text-align:center">172.16.0.4</td><td style="text-align:center">134.175.210.3</td></tr></tbody></table></div><blockquote><p>:warning: 警告，下面有个史前大坑。因为云服务器默认访问本身是用<strong>内网</strong>IP地址</p></blockquote><ul><li><p>在master上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su hadoop</span><br><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>编辑hosts文件如下（以前的全部删除，改成下面这样）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">172.30.0.7 master         <span class="comment"># master必须用内网IP</span></span><br><span class="line">134.175.210.3 slave01     <span class="comment"># slave01用外网IP </span></span><br></pre></td></tr></table></figure></li><li><p>在 slave01上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su hadoop</span><br><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">129.28.154.240 master      <span class="comment"># master必须用外网IP</span></span><br><span class="line">172.16.0.4     slave01     <span class="comment"># slave01用内网IP </span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3-SSH互相免密"><a href="#3-SSH互相免密" class="headerlink" title="3 SSH互相免密"></a>3 SSH互相免密</h5><p>在之前我们搭建Spark单机版环境时，我们配置ssh可以 <em>无密码</em> 本地连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost   <span class="comment"># 保证两台服务器都可以本地无密码登陆</span></span><br></pre></td></tr></table></figure><p>现在我们还要让 <em><u>master主机免密码登陆 slave01、slave02</u></em> 。因此我们要将master主机的<code>id_rsa.pub</code> 分别传递给两台slave主机。</p><ol><li><p>在<code>master</code>上scp传递公钥</p><p>第一次传要输入slave01@hadoop用户密码，例如之前设置为123456</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ~/.ssh/id_rsa.pub hadoop@slave01:/home/hadoop/  </span><br></pre></td></tr></table></figure></li><li><p>在slave01上加入验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /home/hadoop/   <span class="comment"># 查看master传送过来的 id_rsa.pub文件</span></span><br></pre></td></tr></table></figure><p>将master公钥加入免验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /home/hadoop/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="built_in">rm</span> /home/hadoop/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>现在我们切换到master主机上，尝试能否免密登陆：</p><p><img src="https://i.loli.net/2020/09/17/juoL6nWYecFq4mb.png" alt="1579772937348"></p><p>验证可以免密登陆后切换回master主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh master   <span class="comment"># 要输入master@hadoop用户密码</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-2-Hadoop集群配置"><a href="#3-2-2-Hadoop集群配置" class="headerlink" title="3.2.2 Hadoop集群配置"></a>3.2.2 Hadoop集群配置</h4><p>原本我们需要同时在master和slave节点安装配置Hadoop集群，但是我们也可以通过仅配置master节点Hadoop，然后将整个配置好的Hadoop文件传递给各个子节点。</p><h5 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h5><p>我们需要修改master主机上hadoop配置文件。</p><ol><li><p>切换目录</p><p>配置文件在 <code>/usr/local/hadoop/etc/hadoop</code> 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/Rc24lL8NXra3TPd.png" alt="1579834732792"></p></li><li><p>修改文件 <code>slaves</code> </p><p>master主机作为<code>NameNode</code> ，而 slave01 作为 <code>DataNode</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim slaves</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave01</span><br></pre></td></tr></table></figure></li><li><p>修改文件 <code>core-site.xml</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;Abase <span class="keyword">for</span> other temporary directories.&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/J9oOg5HMI3puALh.png" alt="1575551770594"></p></li><li><p>修改<code>hdfs-site.xml</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;master:9001&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.namenode.http-address&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;master:50070&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>mapred-site.xml.template</code> </p><p>:warning: 首先复制它产生一个新复制文件并命名为：<code>mapred-site.xml</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure><p>然后修改文件 <code>vim mapred-site.xml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>yarn-site.xml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim yarn-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">         &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">         &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;master&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line"> &lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h5><blockquote><p>当然你也可以尝试在slave节点上重复一遍master节点上的配置，而非通过传送文件。（建议方法二，省事）</p></blockquote><p><strong>:black_flag: 方法1：</strong>通过scp将上述变动文件发送至slave（可以大幅度减少传送时间）</p><ol><li><p>传送已修改的配置文件</p><p>在master上节点上，使用如下命令将yarn-site.xml等发送到从机上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on master</span></span><br><span class="line">scp /usr/local/hadoop/etc/hadoop/core-site.xml hadoop@slave01:/usr/local/hadoop/etc/hadoop/</span><br><span class="line">scp /usr/local/hadoop/etc/hadoop/hdfs-site.xml hadoop@slave01:/usr/local/hadoop/etc/hadoop/</span><br><span class="line">scp /usr/local/hadoop/etc/hadoop/mapred-site.xml hadoop@slave01:/usr/local/hadoop/etc/hadoop/</span><br><span class="line">scp /usr/local/hadoop/etc/hadoop/yarn-site.xml hadoop@slave01:/usr/local/hadoop/etc/hadoop/</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>检查文件变更</p><p>通过cat命令检查slave上的相关文件是否变更。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">on slave</span></span><br><span class="line">cat /usr/local/hadoop/etc/hadoop/core-site.xml    # 确认文件是否传送正确</span><br></pre></td></tr></table></figure><p>输出中含有上一步中修改后的信息，则确认正确。比如，<code>core-site.xml</code>文件输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Put site-specific property overrides <span class="keyword">in</span> this file. --&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">&lt;description&gt;Abase <span class="keyword">for</span> other temporary directories.&lt;/description&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>:black_flag: 方法2：</strong> 压缩拷贝整个hadoop目录</p><ul><li><p>在master节点上执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line"><span class="built_in">rm</span> -rf ./hadoop/tmp      <span class="comment"># 删除临时文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf ./hadoop/logs/*   <span class="comment"># 删除日志文件</span></span><br><span class="line"><span class="comment"># 压缩./hadoop文件，并重名为hadoop.master.tar.gz</span></span><br><span class="line">tar -zcf ~/hadoop.master.tar.gz ./hadoop</span><br></pre></td></tr></table></figure><p>将压缩好的文件传递给 slave01：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">scp ./hadoop.master.tar.gz slave01:/home/hadoop</span><br></pre></td></tr></table></figure><p>:slightly_smiling_face: 传递速度有点慢，大概要半小时。等待时间你可以先撰写部分实验报告，或者尝试浏览接下来实验步骤。</p></li><li><p>在slave01节点上</p><p>（如果有）删除原有hadoop文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/hadoop/</span><br></pre></td></tr></table></figure><p>解压传过来的文件到指定目录 <code>/usr/local</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf /home/hadoop/hadoop.master.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p>设置解压出来的hadoop文件夹权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R hadoop /usr/local/hadoop</span><br></pre></td></tr></table></figure></li></ul><h5 id="集群启动测试"><a href="#集群启动测试" class="headerlink" title="集群启动测试"></a>集群启动测试</h5><ol><li><p>master上启动集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">bin/hdfs namenode -format   <span class="comment"># 注意，仅在第一次启动集群时使用该命令格式化！</span></span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p>在master上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>master节点出现以下<strong>4</strong>个进程则配置成功：</p><p><img src="https://i.loli.net/2020/09/17/I7bEn4WANZqfouc.png" alt="1579789502573"></p></li><li><p>在 slave01上 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>slave节点出现以下<strong>3</strong>个进程则配置成功：</p><p><img src="https://i.loli.net/2020/09/17/mrMWl8jneGbqD7a.png" alt="1579789532062"></p></li></ul></li></ol><h5 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h5><blockquote><p><code>Q1</code>:  <code>slave</code>节点没有 <code>DataNode</code> 进程  /  <code>master</code>节点没有 <code>namenode</code> 进程 ？</p></blockquote><p>这个问题一般是由于在启动集群多次执行格式化命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>导致<code>hodoop</code>目录下 <code>tmp/dfs/name/current</code>文件下的<code>VERSION</code>中的<code>namespaceId</code>不一致。</p><p>首先我们 <em>在master节点上</em>  停止集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop  <span class="comment"># 切换到你的hadoop目录下</span></span><br><span class="line">sbin/stop-all.sh      <span class="comment"># 关闭集群</span></span><br></pre></td></tr></table></figure><ul><li><p><em><u>slave节点删除 <code>tmp</code></u></em> </p><p>删除<em>slave</em>节点的临时 <em>tmp</em> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local        <span class="comment"># 切换到hadoop目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf ./hadoop/tmp </span><br></pre></td></tr></table></figure><p>删除 <code>tmp</code> 文件 , 如法炮制在 <em>其它节点</em> 进行一样的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf ./hadoop/tmp   <span class="comment"># 后面格式化会重新生成，大胆删除</span></span><br></pre></td></tr></table></figure></li><li><p><em>在master节点删除 <code>tmp</code></em> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local </span><br><span class="line"><span class="built_in">rm</span> -rf ./hadoop/tmp </span><br></pre></td></tr></table></figure></li><li><p>重新启动集群</p><p>在<em>master</em>节点执行以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">bin/hdfs namenode -format   <span class="comment"># 重新格式化</span></span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li><li><p>验证</p><p>在 <em>master</em> 节点执行以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">jps </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/TgCwopQcUYxa54H.png" alt="1575945505887"></p><p>在子节点再次输入 <code>jps</code> 命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">jps </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/esb6kfArEa254jy.png" alt="1575942873563"></p><p><em>ok~</em> </p></li></ul><blockquote><p><code>Q2</code>：启动集群后发现，<code>Slave</code> 节点没有 <code>NodeManager</code>进程</p><p><img src="https://i.loli.net/2020/09/17/J7YEdwC5gSWVUOj.png" alt="1580466394703"></p><p>:warning: 建议先尝试 <code>Q1</code> 方法，一般能解决大部分问题。</p></blockquote><p>启动集群时可以知道，启动 <code>slave01</code> 节点 <code>notemanager</code> 进程相关日志在（最后不是<code>.out</code>是<code>.log</code>） ：</p><p><code>/usr/local/hadoop/logs/yarn-hadoop-nodemanager-slave01.log</code></p><p><img src="https://i.loli.net/2020/09/17/N2pIQ84Y5D9bOWt.png" alt="1580466585098"></p><ol><li><p>查看日志</p><p>在 <code>slave01</code> 节点下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/hadoop/logs/yarn-hadoop-nodemanager-slave01.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>日志太多，我们在<code>命令模式</code>下，输入 <code>:$</code> ，直接跳到最后一行：</p><p><img src="https://i.loli.net/2020/09/17/g9ZVbnItWhFvwN1.png" alt="1580467310994"></p><ul><li>很显然，显示端口<code>8040</code>被占用</li></ul></li><li><p>查看谁占用<code>8040</code>端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tln | grep 8040</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/mTpuMOrYUaKovCw.png" alt="1580467453929"></p><p>果然<code>8040</code> 端口已经被占用</p></li><li><p>释放端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i :8040  <span class="comment"># 查询占用8040端口进程pid</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/LDlM1CctV5jTNxR.png" alt="1580467535705"></p><p>杀死相应进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">kill</span> -9 16961</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>重新启动集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">sbin/stop-all.sh</span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>再次输入 <code>jps</code>命令，发现 <code>slave01</code> 节点 <code>NodeManager</code> 进程已经出现！</p><p><img src="https://i.loli.net/2020/09/17/vMEQkPGg5hwRjFl.png" alt="1580467671457"></p></li></ol><h4 id="3-2-3-Spark集群配置"><a href="#3-2-3-Spark集群配置" class="headerlink" title="3.2.3 Spark集群配置"></a>3.2.3 Spark集群配置</h4><blockquote><p>以下步骤都建立在是我们三台云服务器已经搭建好Spark单机版环境 &amp; hadoop集群。</p></blockquote><h5 id="Spark配置"><a href="#Spark配置" class="headerlink" title="Spark配置"></a>Spark配置</h5><ol><li><p>切换配置目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/conf</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>slaves</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> slaves.template slaves  <span class="comment"># 先把模板文件复制重命名</span></span><br></pre></td></tr></table></figure><p>开始编辑 <code>vim slaves</code>，将默认内容 <code>localhost</code> 替换为以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slave01</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>spark-env.sh</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure><p>开始编辑，添加下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_IP=172.30.0.7   <span class="comment"># 注意，使用的master内网IP!!</span></span><br></pre></td></tr></table></figure></li><li><p>复制Spark文件到各个slave节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line">tar -zcf ~/spark.master.tar.gz ./spark</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">scp ./spark.master.tar.gz slave01:/home/hadoop</span><br></pre></td></tr></table></figure></li><li><p>节点替换文件</p><p>以下操作是在 slave节点上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/spark/          <span class="comment"># 删除节点原有Spark文件（如果有）</span></span><br><span class="line">sudo tar -zxf /home/hadoop/spark.master.tar.gz -C /usr/local  <span class="comment"># 解压到local</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R hadoop /usr/local/spark  <span class="comment"># 设置spark文件权限拥有者是hadoop</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="启动Spark集群"><a href="#启动Spark集群" class="headerlink" title="启动Spark集群"></a>启动Spark集群</h5><p>在master主机上执行以下操作</p><ol><li><p>先启动hadoop集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/</span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li><li><p>启动master节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/</span><br><span class="line">sbin/start-master.sh</span><br></pre></td></tr></table></figure><p>master上运行 <code>jps</code> 命令可以看到：</p><p><img src="https://i.loli.net/2020/09/17/zPYUGCycEblL58d.png" alt="1579791236779"></p></li><li><p>启动所有slave节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-slaves.sh</span><br><span class="line"><span class="comment">#建议使用下面这个</span></span><br><span class="line">sbin/start-slave.sh spark://&lt;master内网ip&gt;:7077  <span class="comment"># 指定master内网ip启动slaves节点</span></span><br></pre></td></tr></table></figure><p>slave节点上运行 <code>jps</code> 命令可以看到：</p><p><img src="https://i.loli.net/2020/09/17/pNAYXGgeoVTqHKE.png" alt="1579791260120"></p></li><li><p>web UI查看</p><p>打开腾讯云控制台，选择<code>VNC</code>登陆服务器，在浏览器上输入：<code>master:8080</code> 。</p><p>如果出现下面界面则表示 <em>Hadoop+Spark</em> 分布式环境搭建成功！</p><p><img src="https://i.loli.net/2020/09/17/d5FtHEDyn9wUmrq.png" alt="1579791486348"></p><blockquote><p>:warning: 如果前面一切正常，Web UI 却无法正常正常显示worker。</p><p>查看slave节点相关<code>spark</code>日志发现报错：无法访问<code>&lt;master外网ip&gt;:7070</code> ，多次连接失败。请尝试：</p><ul><li><p>关闭集群，重启启动集群，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-master.sh  <span class="comment"># 先启动master</span></span><br><span class="line">sbin/start-slave.sh spark://&lt;master内网ip&gt;:7077  <span class="comment"># 指定master内网ip启动slaves节点</span></span><br></pre></td></tr></table></figure></li><li><p>如果依旧不行，考虑：登陆控制台 —&gt; 创建安全组（选择<strong>放通所有端口</strong>） —&gt; 将master加入刚创建的安全组</p></li><li>重新按第一步启动集群，一般都可以正常显示了</li></ul><p>相关的一些的讨论也可参考： <a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/3">issue#3 @trevery</a> </p></blockquote><p>:tada: :tada:  聪明如你终于做到这步了，第一个实验完结，撒花 :tada:  :tada: </p><h2 id="4-伪分布式搭建"><a href="#4-伪分布式搭建" class="headerlink" title="4 伪分布式搭建"></a>4 伪分布式搭建</h2></li></ol><blockquote><p>:slightly_smiling_face: 选择伪分布式搭建的同学，<strong>每一个组员</strong>都需要在各自服务器上<strong>独立完成</strong>环境搭建。</p></blockquote><h3 id="4-1-Spark单机版搭建​"><a href="#4-1-Spark单机版搭建​" class="headerlink" title="4.1 Spark单机版搭建​"></a>4.1 Spark单机版搭建​</h3><p>在进行Hadoop、Spark环境搭建前，我们需要进行一些准备工作。</p><h4 id="4-1-1-准备工作"><a href="#4-1-1-准备工作" class="headerlink" title="4.1.1 准备工作"></a>4.1.1 准备工作</h4><h5 id="1-配置用户-1"><a href="#1-配置用户-1" class="headerlink" title="1 配置用户"></a>1 配置用户</h5><p>该小节主要是创建<code>Hadoop</code> 用户。</p><ol><li><p>创建用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m hadoop -s /bin/bash          </span><br></pre></td></tr></table></figure><p>同时设置用户密码：（如 123456）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd hadoop</span><br></pre></td></tr></table></figure></li><li><p>配置权限</p><p>为了方便，给用户 <code>hadoop</code> 等同<code>root</code> 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo            <span class="comment"># 执行 visudo命令进入vim编辑</span></span><br></pre></td></tr></table></figure><p>找到如下位置，添加红框那一行配置权限：</p><p><img src="https://i.loli.net/2020/09/17/1owVFrmRuLg2MCP.png" alt="1575371320579"></p></li><li><p>切换用户</p><p>配置完成好，我们切换到hadoop用户下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su hadoop</span><br></pre></td></tr></table></figure><p>:warning: 如非特殊说明，接下来所有命令都是Hadoop用户下完成！</p></li></ol><h5 id="2-配置SSH-1"><a href="#2-配置SSH-1" class="headerlink" title="2 配置SSH"></a>2 配置SSH</h5><blockquote><p>为什么要配置ssh？</p></blockquote><p>因为集群、单节点模式都需要用到 ssh登陆。同时每次登陆ssh都要输入密码是件蛮麻烦的事 ，我可以通过生成公钥配置来面密码登陆。</p><ol><li><p>生成密钥</p><p>为了生成 ~/.ssh 目录，我们直接通过执行下面命令会直接生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost   # 按提示输入yes，然后键入hadoop密码</span><br></pre></td></tr></table></figure><p>然后开始生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/          <span class="comment"># 切换目录到ssh下</span></span><br><span class="line">ssh-keygen -t rsa   <span class="comment"># 生成密钥</span></span><br></pre></td></tr></table></figure><p>生成密钥过程会有三个提示，不用管全部回车。</p></li><li><p>授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys  <span class="comment"># 加入授权</span></span><br></pre></td></tr></table></figure></li><li><p>修改权限</p><p>如果不修改文件<code>authorized_keys</code>权限为<code>600</code>，会出现访问拒绝情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ./authorized_keys    <span class="comment"># 修改文件权限</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost   <span class="comment"># ssh登陆</span></span><br></pre></td></tr></table></figure><p>不用输入密码，直接登陆成功则说明配置正确。</p><p><img src="https://i.loli.net/2020/09/17/6r8LH5fJxDCKljA.png" alt="1579835835458"></p></li></ol><h5 id="3-配置yum源-1"><a href="#3-配置yum源-1" class="headerlink" title="3 配置yum源"></a>3 配置yum源</h5><p>官方网站下载实在太慢，我们可以先配置一下阿里源来进行下载。</p><ol><li><p>切换到<code>yum</code> 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br></pre></td></tr></table></figure></li><li><p>备份下原repo文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> CentOS-Base.repo CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure></li><li><p>下载阿里云repo文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/CentOS-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p>防止权限不足使用<code>sudo</code> 命令。</p></li><li><p>设置为默认repo文件</p><p>就是把阿里云repo文件名修改为 <code>CentOS-Base.repo</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span>  CentOS-7.repo CentOS-Base.repo  <span class="comment"># 输入y</span></span><br></pre></td></tr></table></figure></li><li><p>生成缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-配置Java环境-1"><a href="#4-配置Java环境-1" class="headerlink" title="4 配置Java环境"></a>4 配置Java环境</h5><blockquote><p>最开始下载的是 <code>1.7</code>版本的JDK，后面出现的问题，重新下载 <code>1.8</code> 版本 JDK。</p></blockquote><p><em>hadoop2</em> 基于 <em>java</em> 运行环境，所以我们先要配置<em>java</em> 运行环境。</p><ol><li><p>安装 JDK </p><p>执行下面命令，经过实际测试前面几分钟一直显示镜像错误不可用。它会进行自己尝试别的源，等待一会儿就可以下载成功了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install java-1.8.0-openjdk java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure><p>:warning: 此时默认安装位置是  <code>/usr/lib/jvm/java-1.8.0-openjdk</code> </p><p>其实，查找安装路径，可以通过以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql java-1.8.0-openjdk-devel | grep <span class="string">&#x27;/bin/javac&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>rpm -ql &lt;RPM包名&gt;</code> ：查询指定RPM包包含的文件</li><li><code>grep &lt;字符串&gt;</code> ： 搜索包含指定字符的文件</li></ul></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc  <span class="comment"># vim编辑配置文件</span></span><br></pre></td></tr></table></figure><p>在文件最后面添加如下单独一行（指向 JDK 的安装位置），并保存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/1nXsHtKukCy4oAB.png" alt="1575379864251"></p><p>最后是环境变量生效，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc </span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span>     <span class="comment"># 检验变量值</span></span><br></pre></td></tr></table></figure><p>正常会输出 <code>2.</code>环境变量JDK配置路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>正确配置会输出java版本号。</p></li></ol><h5 id="5-安装python-1"><a href="#5-安装python-1" class="headerlink" title="5 安装python"></a>5 安装python</h5><blockquote><p>CentOS自带python2版本过低，我们进行python3安装。</p></blockquote><ol><li><p>yum查找python3</p><p>查找仓库存在的python3安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list python3</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/On2ues5Xpwl4TqG.png" alt="1575423838102"></p></li><li><p>yum 安装python3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python3.x86_64</span><br></pre></td></tr></table></figure><p>如果最开始会显示没有，等一会自动切换阿里源就可以进行安装了,<em><u>同时还会安装相关依赖</u></em>  。</p></li></ol><h4 id="4-1-2-hadoop-安装"><a href="#4-1-2-hadoop-安装" class="headerlink" title="4.1.2 hadoop 安装"></a>4.1.2 hadoop 安装</h4><blockquote><p>本文使用 <code>wget</code> 命令来下载 <code>hadoop</code> ：<a href="https://blog.csdn.net/qq_27870421/article/details/91951402">了解更多wget</a></p></blockquote><p>使用的是<a href="https://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.8.5/hadoop-2.8.5.tar.gz">北理工镜像站</a> , 下载 <code>hadoop</code> ：</p><p><img src="https://i.loli.net/2020/09/17/xsJyQa2oA3zfPWV.png" alt="1575378514451"></p><ol><li><p>下载</p><blockquote><p>为防止证书验证出现的下载错误，加上 <code>--no-check-certificate</code> ，相关讨论可见 <a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/1">issue#1</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O hadoop-2.8.5.tar.gz https://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.8.5/hadoop-2.8.5.tar.gz  --no-check-certificate </span><br></pre></td></tr></table></figure><ul><li><code>wget -O &lt;指定下载文件名&gt; &lt;下载地址&gt;</code> </li></ul></li><li><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf hadoop-2.8.5.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p>把下载好的文件 <code>hadoop-2.8.5.tar.gz</code> 解压到 <code>/usr/local</code> 目录下</p></li><li><p>修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/   <span class="comment"># 切换到解压目录下</span></span><br><span class="line">sudo <span class="built_in">mv</span> ./hadoop-2.8.5/ ./hadoop      <span class="comment"># 将加压的文件hadoop-2.8.5重命名为hadoop</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R hadoop:hadoop ./hadoop  <span class="comment"># 修改文件权限</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop     <span class="comment"># 切换到hadoop目录下</span></span><br><span class="line">./bin/hadoop version     <span class="comment"># 输出hadoop版本号</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/aBCDimKzuh7YNgF.png" alt="1579836302968"></p></li></ol><h4 id="4-1-3-spark安装"><a href="#4-1-3-spark安装" class="headerlink" title="4.1.3 spark安装"></a>4.1.3 spark安装</h4><p>在前我们已经安装了 <em>hadoop</em> ，现在我们来开始进行<em>spark</em> 安装。</p><blockquote><p>这次下载根据官网推荐使用的清华源。</p></blockquote><ol><li><p>下载</p><p>官网下载地址：<a href="http://spark.apache.org/downloads.html">官网下载</a></p><p><img src="https://i.loli.net/2020/09/17/qGSENlCM2t1dmfU.png" alt="1575381612542"></p><ul><li>这样选择的版本可以使用于大部分 <code>hadoop</code>版本</li></ul><p>点击上述链接，根据跳转的页面提示选择清华源下载：</p><blockquote><p>注意，版本号可能发生变化，建议打开上述官网链接查看当前存在的版本。如我查看到只支持<code>2.4.7</code>版本（2020/09/17），那么需修改下面版本号：<code>2.4.4--&gt;2.4.7</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O spark-2.4.7-bin-without-hadoop.tgz http://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.7/spark-2.4.7-bin-without-hadoop.tgz  <span class="comment"># 版本号发生变化记得替换，下同</span></span><br></pre></td></tr></table></figure></li><li><p>解压</p><p>同前解压到 <code>/usr/local</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxf spark-2.4.7-bin-without-hadoop.tgz -C /usr/local</span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local   <span class="comment"># 切换到解压目录</span></span><br><span class="line">sudo <span class="built_in">mv</span> ./spark-2.4.7-bin-without-hadoop ./spark  <span class="comment"># 重命名解压文件</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R hadoop:hadoop ./spark  <span class="comment"># 设置用户hadoop为目录spark拥有者</span></span><br></pre></td></tr></table></figure></li><li><p>配置spark环境</p><p>先切换到 <code>/usr/local/spark</code> ，（为了防止没权限，下面用<code>sudo</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line"><span class="built_in">cp</span> ./conf/spark-env.sh.template ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>编辑 <code>spark-env.sh</code> 文件 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./conf/spark-env.sh</span><br></pre></td></tr></table></figure><p>在第一行添加下面配置信息，使得Spark可以从Hadoop读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在<code>.bashrc</code>文件中添加如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-<span class="number">1.8</span><span class="number">.0</span>-openjdk  <span class="comment"># 之前配置的java环境变量</span></span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop    <span class="comment"># hadoop安装位置</span></span><br><span class="line">export SPARK_HOME=/usr/local/spark   </span><br><span class="line">export PYTHONPATH=$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-<span class="number">0.10</span><span class="number">.7</span>-src.<span class="built_in">zip</span>:$PYTHONPATH           </span><br><span class="line">export PYSPARK_PYTHON=python3           <span class="comment"># 设置pyspark运行的python版本</span></span><br><span class="line">export PATH=$HADOOP_HOME/<span class="built_in">bin</span>:$SPARK_HOME/<span class="built_in">bin</span>:$PATH</span><br></pre></td></tr></table></figure><p>最后为了使得环境变量生效，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>测试是否运行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">bin/run-example SparkPi</span><br></pre></td></tr></table></figure><p>执行会输出很多信息，也可以选择执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/run-example SparkPi 2&gt;&amp;1 | grep <span class="string">&quot;Pi is&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/AMbZF57pjz3O6CG.png" alt="1579836510461"></p></li></ol><h4 id="4-1-4-测试"><a href="#4-1-4-测试" class="headerlink" title="4.1.4 测试"></a>4.1.4 测试</h4><ol><li><p>启动pyspark</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark</span><br><span class="line">bin/pyspark</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/NMeQqgzDLPExaYh.png" alt="1579836544818"></p></li><li><p>简单测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 * 2 + 5</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/RcAnCuaJ2oQZ4zE.png" alt="1579772128608"></p><p>使用<code>exit()</code> 命令可退出。</p></li></ol><h3 id="4-2-Hadoop-Spark-分布式环境搭建"><a href="#4-2-Hadoop-Spark-分布式环境搭建" class="headerlink" title="4.2 Hadoop+Spark 分布式环境搭建"></a>4.2 Hadoop+Spark 分布式环境搭建</h3><h4 id="4-2-1-Hadoop集群配置"><a href="#4-2-1-Hadoop集群配置" class="headerlink" title="4.2.1 Hadoop集群配置"></a>4.2.1 Hadoop集群配置</h4><h5 id="Hadoop文件配置"><a href="#Hadoop文件配置" class="headerlink" title="Hadoop文件配置"></a>Hadoop文件配置</h5><p>我们需要修改hadoop配置文件。</p><ol><li><p>切换目录</p><p>配置文件在 <code>/usr/local/hadoop/etc/hadoop</code> 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/17/Rc24lL8NXra3TPd.png" alt="1579834721166"></p></li><li><p>修改文件 <code>core-site.xml</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;Abase <span class="keyword">for</span> other temporary directories.&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://0.0.0.0:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>:warning: 实际测试必须要 <code>hdfs://0.0.0.0:9000</code> 才能使用 <code>hdfs</code> 服务。</p><p>:warning: 有可能依旧报错：<code>Error JAVA_HOME is not set and could not be found</code> -</p><ul><li><p>配置<code>hadoop-env.sh</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/etc/hadoop</span><br><span class="line">vim hadoop-env.sh</span><br></pre></td></tr></table></figure><p>配置 <code>JAVA_HOME</code> 路径如下：</p><p><img src="https://i.loli.net/2020/09/17/cKnaINYuBWP9r3L.png" alt="1580121482205"></p></li></ul></li><li><p>修改<code>hdfs-site.xml</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hdfs-site.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="集群启动测试-1"><a href="#集群启动测试-1" class="headerlink" title="集群启动测试"></a>集群启动测试</h5><ol><li><p>启动集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop</span><br><span class="line">bin/hdfs namenode -format   <span class="comment"># 注意，仅在第一次启动集群时使用该命令格式化！</span></span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>出现以下<strong>6</strong>个进程则配置成功：</p><p><img src="https://i.loli.net/2020/09/17/SIWcvN47ugkRntT.png" alt="1579836734674"></p></li></ol><h4 id="4-2-2-Spark集群配置"><a href="#4-2-2-Spark集群配置" class="headerlink" title="4.2.2 Spark集群配置"></a>4.2.2 Spark集群配置</h4><h5 id="Spark配置-1"><a href="#Spark配置-1" class="headerlink" title="Spark配置"></a>Spark配置</h5><ol><li><p>切换配置目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/conf</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>spark-env.sh</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure><p>开始编辑，添加下面内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/local/hadoop/etc/hadoop</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_IP=localhost</span><br></pre></td></tr></table></figure></li></ol><h5 id="启动Spark集群-1"><a href="#启动Spark集群-1" class="headerlink" title="启动Spark集群"></a>启动Spark集群</h5><p>执行以下操作</p><ol><li><p>先启动hadoop集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/</span><br><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></li><li><p>启动spark集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/</span><br><span class="line">sbin/start-all.sh </span><br></pre></td></tr></table></figure><p>运行 <code>jps</code> 命令可以看到：</p><p><img src="https://i.loli.net/2020/09/17/QzF5DBbinGjL7xm.png" alt="1579851551123"></p></li><li><p>web UI查看</p><p>打开腾讯云控制台，选择<code>VNC</code>登陆服务器，在浏览器上输入：<code>master:8080</code> 。</p><p>如果出现下面界面则表示 <em>Hadoop+Spark</em> 分布式环境搭建成功！</p><p><img src="https://i.loli.net/2020/09/17/d5FtHEDyn9wUmrq.png" alt="1579791486348"></p><blockquote><p>:warning: 如果前面一切正常，Web UI 却无法正常正常显示worker。</p><p>查看slave节点相关<code>spark</code>日志发现报错：无法访问<code>&lt;master外网ip&gt;:7070</code> ，多次连接失败。请尝试：</p><ul><li><p>关闭集群，重启启动集群，执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-master.sh  <span class="comment"># 先启动master</span></span><br><span class="line">sbin/start-slave.sh spark://&lt;master内网ip&gt;:7077  <span class="comment"># 指定master内网ip启动slaves节点</span></span><br></pre></td></tr></table></figure></li><li><p>如果依旧不行，考虑：登陆控制台 —&gt; 创建安全组（选择<strong>放通所有端口</strong>） —&gt; 将master加入刚创建的安全组</p></li><li>重新按第一步启动集群，一般都可以正常显示了</li></ul><p>相关的一些的讨论也可参考： <a href="https://github.com/Wanghui-Huang/CQU_bigdata/issues/3">issue#3 @trevery</a> </p></blockquote><p>:tada: :tada:  聪明如你终于做到这步了，第一个实验完结，撒花 :tada:  :tada: </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux学习 </tag>
            
            <tag> 大数据导论 </tag>
            
            <tag> 华为云学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验零：Linux 初识</title>
      <link href="/2022/09/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA1/"/>
      <url>/2022/09/10/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E8%AE%BA1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h1><blockquote><p>:cloud_with_lightning: 本次实验并非系统介绍Linux系统理论知识，注重<strong>实操</strong> ，而且是<strong>针对后续实验需要用到Linux相关知识</strong>，而特别设计的实验。</p></blockquote><p>通过本次实验，你应该：</p><ul><li><p>安装Linux系统环境，了解云服务器相关知识；</p></li><li><p>掌握Linux基本知识，如：<code>vim</code> 的操作使用、Linux系统常用命令、用户与权限相关知识等；</p></li><li>相关工具<code>FTP</code>、<code>SSH</code> 等使用。</li></ul><p>或许你是第一次接触Linux，相信会给你带来不一样的体验。接下来让我们正式进入实验环节吧。</p><h1 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2 实验准备"></a>2 实验准备</h1><h2 id="2-0-计分说明"><a href="#2-0-计分说明" class="headerlink" title="2.0 计分说明"></a>2.0 计分说明</h2><p>在正式开始接触Linux前，我们需要搭建好Linux平台。</p><p>一般而言，我们有三种方式选择安装Linux系统。在大家正式选择前，先和同学们罗列一下各个选择的利弊。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Linux平台选择</th><th>最高分</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">云服务器</td><td>-</td><td style="text-align:center">1.后续所有相关实验最高分按<strong>100</strong>计算</td><td style="text-align:center">1.<strong>分布式会出现较多的网络、病毒攻击问题</strong> <br>2.会涉及到更多<strong>端口、网络问题</strong>比较难Debug</td><td>推荐</td></tr><tr><td style="text-align:center">虚拟机VM</td><td>-</td><td style="text-align:center">1.后续涉及到分布式实验问题会<strong>少很多</strong>，特别是网络、端口问题 <br/>2.操作相比云服务器<strong>更简单</strong></td><td style="text-align:center">1.最高分按<strong>95</strong>分计算 <br/>2.分布式实验可能会出现<strong>资源不足</strong>问题，需要自行解决</td><td>推荐</td></tr><tr><td style="text-align:center">双系统</td><td>-</td><td style="text-align:center">1.相比虚拟机资源会更足，减少分布式时资源相关问题</td><td style="text-align:center">1.后续教程均基于云服务器或者虚拟机，部分操作会不一样，需要自行修改 <br/>2. <strong>适合动手能力更强的同学</strong>，因此不太推荐</td></tr></tbody></table></div><p>本次实验出于时间考虑只详细介绍 <strong>第一种：云服务器 和 第二种：虚拟机</strong> 方式，课后大家可选择其它方式。</p><p>下面介绍本次实验环境相关准备过程。</p><h2 id="2-1-云上Linux"><a href="#2-1-云上Linux" class="headerlink" title="2.1 云上Linux"></a>2.1 云上Linux</h2><p>云服务器搭建Linux工作流程如下：</p><ol><li>购买华为云弹性云服务器：&lt;<a href="https://console.huaweicloud.com/ecm/?region=cn-east-3#/ecs/createVm">弹性云服务器 - 控制台 (huaweicloud.com)</a>&gt;</li></ol><h3 id="2-1-1-购买弹性云服务器"><a href="#2-1-1-购买弹性云服务器" class="headerlink" title="2.1.1 购买弹性云服务器"></a>2.1.1 购买弹性云服务器</h3><blockquote><p>购买数量为N，N为组员人数。</p><p>[<strong>NEWS</strong>] 学院已经和华为云合作，每位同学都有免费的华为云代金卷，如果条件允许，<strong>建议大家尽量将配置调高一点</strong>：</p><ul><li>比如，内存4G及以上，CPU2核及以上。</li></ul><p><strong>在ex2~ex4可以避免很多不必要的烦扰</strong>，e.g.，机器比较卡顿、资源不足等问题。</p></blockquote><p> 1.配置所需要的弹性云服务器</p><p><h5>基础配置</h5><br><img src="https://img-blog.csdnimg.cn/20210612183314984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtaWxldWk=,size_16,color_FFFFFF,t_70" alt="1"></p><p>（1）计费模式：按需计费</p><p>（2）区域：华南-广州（按需选择）（广州离重庆更近一点，同时要记住自己选的区域）</p><p>（3）可用区：一般选择随机分配（可以提高容灾能力。但如果应用要求网络时延较低，建议将资源创建在同一可用区）</p><p>（4）CPU架构：选择x86计算即可，如有兴趣，可了解鲲鹏计算。</p><p>（5）vCPUs：2核以上，最好四核。内存最好8G。接下来选择规格，就是服务器的型号，不同型号的服务器有不同的功能，你可以根据项目的实际情况选择不同的型号。</p><p><img src="https://img-blog.csdnimg.cn/20210612183418574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtaWxldWk=,size_16,color_FFFFFF,t_70" alt="2"></p><p>（6）接下来选择操作系统和操作系统对应的版本号，如果你选择的是linux操作系统，那么建议你选择Centos操作系统。CentOS操作系统版本为：<code>CentOS 7.6.64</code>（8.0版本会报各种各样错误）。安全防护免费即可。</p><p><img src="https://pic2.zhimg.com/80/v2-67cb53c8ca5f1d0b91e4b8b4cf07f649_720w.jpg" alt=""></p><p>（7）接下来选择系统盘，系统盘的硬盘类型有高效云盘和SSD硬盘（固态硬盘），固态硬盘相对比高效云盘，在各种性能方面都会优于高效云盘，所以价格相对比较贵选择好了硬盘类型，接下来选择硬盘大小。</p><p><img src="https://pic3.zhimg.com/v2-264e928044b57824b5f9a0b9540b326e_r.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-6ffc2e31dc222b9c21cc227f849dfa17_720w.jpg" alt=""></p><p>系统盘可以选的大一些。可以做一些别的操作。</p><p>（8）接下来创建数据盘，如果你的系统盘已经够你用了，那么你没必要在去买数据盘了。如果不够你用你可以创建数据盘，并且选择数据盘数量，每块数据盘的硬盘类型和大小。（所以系统盘可以选择大于100G的，也可以分开）</p><p><img src="https://pic2.zhimg.com/80/v2-0b711de33b6e59f0413205502d072035_720w.png" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-1205e4aa4b54debd1526fbfaf5652cf2_720w.png" alt=""></p><p><h5>网络配置</h5><br>（9）虚拟私有云选择，这里就需要去到控制台，选择（1）对应地区的虚拟私有云</p><p><img src="https://pic4.zhimg.com/80/v2-ebda9d67e0667fbc1d200985f56fa21f_720w.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/80/v2-473ae118441836ff2477976d844861da_720w.jpg" alt=""></p><p>其中VPC所在区和所在可用区，必须和服务器所在区和所在可用区一致。</p><p><img src="https://pic2.zhimg.com/80/v2-a181d5ea88e67d6b9d7cf1f32499cea9_720w.jpg" alt=""></p><p>创建完成之后返回原始页面刷新即可。</p><p>（10）选择宽带，弹性公网iP选择：现在购买，线路选择：全动态BGP，公网宽带选择：按宽带计费，宽带大小根据项目情况自行设定，一般建议刚上线的项目5兆左右即可</p><p><img src="https://pic4.zhimg.com/v2-524e3ec94a46c35e7a6d6fcc5c962ef7_r.jpg" alt=""></p><p><b>注意释放行为打勾。</b></p><p><h5>高级设置</h5><br><img src="https://pic3.zhimg.com/80/v2-e1511e715266a63114bc584b12df1952_720w.jpg" alt=""></p><p>（11）这里我建议直接设置密码，省了很多事情。云备份根据自行情况设置是否需要购买，如果服务器需要备份则可以购买。然后确认配置即可。</p><p>（12）勾选我已阅读并同意《镜像免责声明》并点击立即购买，点击：立即购买。</p><p>综上弹性云服务器购买完成。</p><h3 id="2-1-2-可视化界面"><a href="#2-1-2-可视化界面" class="headerlink" title="2.1.2 可视化界面"></a>2.1.2 可视化界面</h3><p>考虑到此前大部分同学没有接触过Linux，不适应命令行环境。因此该小节将展示如何搭建Linux（<code>CentOS 7</code>）桌面环境。</p><ol><li>选择VNC登录。在弹出的“登录Windows弹性云服务器”窗口中，选择“其他方式”下的VNC方式，单击“立即登录”。</li></ol><p><img src="https://support.huaweicloud.com/usermanual-ecs/zh-cn_image_0219647352.png" alt=""></p><p>登入后依次输入账号，密码：</p><ul><li>初始账号为root，密码是你购买云服务器所设置的。注意密码是看不见的。直接输入即可。</li></ul><p>2.安装图形界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum groupinstall &quot;Server with GUI&quot;</span></span><br><span class="line"></span><br><span class="line">说明：中间需要输入一个 y  代表<span class="built_in">yes</span></span><br><span class="line">如果安装结束后提示</span><br><span class="line">Failed : python -urllibs3.noarch 0:1.10.2-7.e17</span><br><span class="line"></span><br><span class="line">可以执行以下命令：</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> /usr/lib/python2.7/site-packages/urllib3/packages/ssl_match_hostname /usr/lib/python2.7/site-packages/urllib3/packages/ssl_match_hostname.bak</span><br><span class="line"></span><br><span class="line">yum install python-urllib3 -y</span><br></pre></td></tr></table></figure><p>3.安装结束后，执行以下命令设置默认启动级别为graphical.target</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure><p>4.执行以下命令启动graphical.target</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start graphical.target</span><br></pre></td></tr></table></figure><p>5.重启服务器</p><p>6.通过控制台提供的VNC登录方式连接服务器，并按照桌面启动的提示设置语言、时区、用户名及密码等。（具体可参考&lt;<a href="https://support.huaweicloud.com/usermanual-ecs/ecs_03_0136.html">Linux弹性云服务器远程登录（VNC方式）<em>弹性云服务器 ECS</em>用户指南<em>实例</em>登录Linux弹性云服务器_华为云 (huaweicloud.com)</a>&gt;）</p><h3 id="2-1-3-SSH工具—-Xshell"><a href="#2-1-3-SSH工具—-Xshell" class="headerlink" title="2.1.3 SSH工具—-Xshell"></a>2.1.3 SSH工具—-Xshell</h3><p>每次在浏览器连接云服务器终究还是不太方便，我们可以安装<code>SSH</code>工具 如<code>Xshell</code>在<code>Windows</code>界面下用来访问远端不同系统下的服务器，从而达到方便操作远程控制终端的目的。</p><p>以下是安装使用简单教程：</p><ol><li><p>下载<code>Xshell</code></p><p><code>Xshell</code>下载地址：[Xshell腾讯高速下载](</p><p>)    </p><p>安装一直点下一步傻瓜似安装，最后可以看到<code>Xshell</code>界面。</p></li><li><p>连接服务器</p><p>选择<code>文件</code>—<code>新建</code>：</p><p>:slightly_smiling_face: 下图查看公网IP是在<strong>阿里云上实例控制台</strong>，如果是腾讯云也同样登陆<strong>腾讯云控制台</strong>查看即可。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/s3HXLtDo56iOEgB.png" alt="1559037648149"></p><p>按照上图填好信息，再点击<code>用户身份验证</code>，输入登陆账号密码（就是我们在购买云服务器时设置的）：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/po2XzR3fshegQBS.png" alt="1559037973213"></p><p>点击确定。然后在Xshell界面选择：<code>会话管理</code> - <code>阿里云服务器</code> 右击 - 打开，便连接到我们的服务器了。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/SbJ9ur6tzK8CTga.png" alt="1559038420911"></p></li><li><p>测试</p><p>接下来你便可以使用<code>Xshell</code> 而非浏览器登陆，愉快的连接使用我们的Linux服务器了。</p><ul><li>注：如果新建会话连接不了，重新打开Xshell即可解决。</li></ul></li><li><p>修改主机名</p><blockquote><p>为了方便区分，请同学们将主机名修改为自己：<strong>姓名首字母+学号后四位</strong> 。</p><p>如，张三：<code>zs4321</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>按下 <code>i</code> 进入插入模式，删除所有内容，然后编辑你的主机名：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/1FuE6tgQXi7ozLv.png" alt="1580876113648"></p><p>按下<code>ESC</code> 键进入命令模式，输入 <code>:wq!</code>保存并退出</p><p>最后重启服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>等待约1分钟左右，重新连接可发现主机名已经被修改。</p></li></ol><h2 id="2-2-云下Linux"><a href="#2-2-云下Linux" class="headerlink" title="2.2 云下Linux"></a>2.2 云下Linux</h2><p>云下Linux推荐虚拟机进行安装，和我们后续的教程可保持一致。</p><ul><li>虚拟机安装Linux（推荐）</li><li>双系统安装Linux</li></ul><p>出于篇幅和后续实验考虑，这里主要介绍如何使用VMware Workstation虚拟机安装CentOS7（Linux发行版本之一）。</p><h3 id="2-2-1-虚拟机安装CentOS7"><a href="#2-2-1-虚拟机安装CentOS7" class="headerlink" title="2.2.1 虚拟机安装CentOS7"></a>2.2.1 虚拟机安装CentOS7</h3><p>虚拟机安装CentOS7可分为两步：</p><ol><li>安装VMware</li><li>安装CentOS7镜像</li></ol><h4 id="安装VMware"><a href="#安装VMware" class="headerlink" title="安装VMware"></a>安装VMware</h4><ol><li><p>下载VMware Workstation Pro 16 </p><blockquote><p>:key: 密钥激活在 <code>/ex0/src</code> 目录下，请自取。</p><ul><li>也可以试试<code>pro 16</code>永久批量密钥：<code>ZF3R0-FHED2-M80TY-8QYGC-NPKYF</code> 。</li></ul></blockquote><ul><li>win平台下载链接：<a href="https://www.vmware.com/go/getworkstation-win">getworkstation-win</a> </li><li>mac平台免费获取：<a href="https://my.vmware.com/web/vmware/evalcenter?p=fusion-player-personal">点击这里注册VMware Fusion Player账号获得免费许可</a></li><li>linux平台下载链接：<a href="https://www.vmware.com/go/getworkstation-linux">getworkstation-linux</a></li></ul><p>如果链接失效，可自行去<a href="https://www.vmware.com/cn.html">官网</a>下载。</p></li><li><p>安装&amp;激活</p><p>除了<code>安装路径</code> 一直默认选择（也可根据自己喜好）即可，最后输入<code>激活密钥</code> 安装完成。</p></li></ol><h4 id="安装CentOS7镜像"><a href="#安装CentOS7镜像" class="headerlink" title="安装CentOS7镜像"></a>安装CentOS7镜像</h4><ol><li><p>准备centos7镜像</p><p>请下载该镜像到合适目录：<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">阿里云镜像</a></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221115125401.png" alt="image-20211221115125401"></p></li><li><p>创建虚拟机</p><p>以管理员身份运行VMware pro 16 —-&gt;主页—-&gt;创建新的虚拟机：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221115242471.png" alt="image-20211221115242471"></p><p>安装类型选择<strong>典型</strong> —-&gt;选择稍后安装系统：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221115633351.png" alt="image-20211221115633351"></p><p>下一步选择要安装的镜像版本：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221115853903.png" alt="image-20211221115853903"></p><p>然后我们开始点击“下一步”进入虚拟机配置环节。</p></li></ol><ol><li><p>虚拟机配置</p><ul><li><p>命名虚拟机：名称默认即可，路径请自行选择合适路径 </p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221120126721.png" alt="image-20211221120126721"></p><p>开始下一步，进行虚拟机相关配置。</p></li><li><p>磁盘、内存、网络等配置</p><ol><li><p><strong>处理器</strong></p><ul><li>处理器数量：1</li><li>每个处理器内核数：建议2个及以上</li></ul></li><li><p>内存：建议2G及以上</p></li><li><p><strong>网络类型</strong>：选择NAT类型（第二个）</p></li><li><p><strong>I/O控制器类型、选择磁盘类型</strong>：默认即可，下一步</p></li><li><p><strong>磁盘</strong>：创建新的虚拟磁盘 ——&gt; 建议20G及以上</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221120303004.png" alt="image-20211221120303004"></p></li></ol><p>最后点击完成配置。</p></li></ul></li><li><p>正式安装CentOS7</p><ul><li><p>点击编辑虚拟机设置，选择ISO映像文件</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221121115192.png" alt="image-20211221121115192"></p></li><li><p>选择之前我们下载CentOS7镜像</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221121229696.png" alt="image-20211221121229696"></p><p>选择好文件—-&gt;确认，回到主页。</p></li><li><p>开启虚拟机</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221121322024.png" alt="image-20211221121322024"></p></li></ul></li><li><p>配置CentOS7</p><p>进入虚拟机后，依次进行如下配置</p><ul><li><p><strong>安装语言</strong>：中文</p></li><li><p><strong>安装信息摘要</strong>：<strong>带有叹号的需要点击配置</strong></p><ul><li><p>如，<code>安装位置</code> —-&gt; 点击—-&gt; 选择“我要配置分区” —-&gt; 完成 —-&gt; 进入手动分区页面</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3c5888548ecdd3d9fa2910248224321f.png" alt="image"></p><p>选择“点击这自动创建他们” —-&gt; 完成—-&gt;接受更改</p><p><img src="https://img-blog.csdnimg.cn/img_convert/188393c3a52e84d6f3754be94f251a25.png" alt="image"></p></li></ul></li><li><p><strong>叹号消失开始安装</strong></p><ul><li>配置root密码：自定义</li><li>许可证：接受许可证</li></ul><p>最近点击完成配置。</p></li></ul></li><li><p><strong>网络设置</strong></p><p>虚拟机有三种网络连接方式：</p><ul><li>桥接模式：IP与主机完全相同，相当于用一条网线直接连接在一起</li><li><strong>NAT模式</strong>：相当于以自己PC形成的一个局域网，虚拟机和主机都有自己对应的局域网IP</li><li>仅主机模式：虚拟机只能访问主机</li></ul><p>本次我们来进行NAT模式下的网络配置（注意需要管理员权限）。</p><ol><li><p>基本背景知识</p><p>局域网可使用的网段（私网地址段）有三大段：</p><ul><li>A类：10.0.0.0~10.255.255.255</li><li>B类：172.16.0.0~172.31.255.255</li><li>C类：192.168.0.0~192.168.255.255</li></ul></li><li><p>VM中编辑网络</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221122826775.png" alt="image-20211221122826775"></p><ul><li><p><strong>子网设置</strong>：<code>192.168.45.0</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221123334832.png" alt="image-20211221123334832"></p></li><li><p><strong>网关设置</strong>：<code>192.168.45.1</code></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221123450328.png" alt="image-20211221123450328"></p></li><li><p><strong>DHCP设置</strong></p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221123530849.png" alt="image-20211221123530849"></p></li></ul></li><li><p>本机中网络配置</p><p>以上步骤完成后配置本机NAT连接下的IPｖ４，仅需配置其中的VMnet8。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221123637247.png" alt="image-20211221123637247"></p><p>双击VMnet8，点击属性，选择IPv4协议（IP地址尽量不与DHCP配置的区间重复）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221123717083.png" alt="image-20211221123717083"></p></li><li><p>修改ens33文件</p><p>当前NAT子网下的网络还连不了网，需如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><blockquote><p>注意：中间需要空两行。</p></blockquote><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221124025227.png" alt="image-20211221124025227"></p></li></ol></li></ol><h3 id="2-2-1-可视化界面"><a href="#2-2-1-可视化界面" class="headerlink" title="2.2.1 可视化界面"></a>2.2.1 可视化界面</h3><ol><li><p>安装GNOME界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum groupintsall <span class="string">&quot;GOME Desktop&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>用命令启动GNOME</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startx</span><br></pre></td></tr></table></figure></li><li><p>建议：安装粘贴板共享软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install open-vm-tools</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-3-SSH工具：MobaXterm"><a href="#2-2-3-SSH工具：MobaXterm" class="headerlink" title="2.2.3 SSH工具：MobaXterm"></a>2.2.3 SSH工具：MobaXterm</h3><ol><li><p>安装ipconfig查询ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ifconfig</span><br></pre></td></tr></table></figure><p>假如没有相关的安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20201201001156141.png" alt="image-20201201001156141"></p><p>找到安装包安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install net-tools.x86_64</span><br></pre></td></tr></table></figure><p>最后记录ip地址，如下红框所示（后面登陆要用到）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>[注] 这个IP就是ens33文件配置的IPADDR。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221124626888.png" alt="image-20211221124626888"></p></li><li><p>安装MobaXterm</p><p>下载<a href="https://mobaxterm.mobatek.net/download.html">免费版</a> , 默认安装即可。</p></li><li><p>登陆</p><p>选择Session，配置如下：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221125140482.png" alt="image-20211221125140482"></p><p>选择用户为<code>root</code> （我这里是自己新建的<code>hadoop</code> 用户，请修改）。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221125232389.png" alt="image-20211221125232389"></p><p>输入<code>root</code>密码后，即可顺利登陆：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/image-20211221125321672.png" alt="image-20211221125321672"></p><h1 id="3-Linux相关知识"><a href="#3-Linux相关知识" class="headerlink" title="3 Linux相关知识"></a>3 Linux相关知识</h1></li></ol><blockquote><p> 通过本节你将掌握后续实验所必须的Linux相关知识。</p></blockquote><h2 id="3-1-Linux-系统目录结构"><a href="#3-1-Linux-系统目录结构" class="headerlink" title="3.1 Linux 系统目录结构"></a>3.1 Linux 系统目录结构</h2><p>Linux目录结构如下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p><p>我们必须要知道的根目录 <code>/</code> 相关目录作用：</p><ul><li><p><strong>/bin</strong>：binary缩写，保存可执行文件，我们敲的命令都在bin中；</p></li><li><p><strong>/boot</strong>：引导目录，操作系统需要引导启动的都在其下；</p></li><li><p><strong>/etc</strong>：所有的配置文件保存其下，一般以<code>.cof</code>结尾；</p></li><li><p><strong>/home</strong>：所有用户家目录（<strong>root除外</strong>），每个用户都在其下有个对应文件夹保存对应信息；</p></li><li><p><strong>/root</strong>：root用户家目录；</p></li><li><p><strong>/var</strong>：保存一些经常变换的信息，如<strong>服务器网站</strong>信息，<strong>操作系统日志</strong>信息;</p></li><li><p><strong>/tmp</strong>：临时目录，会被隔几天自动删除；</p></li><li><p><strong>/proc</strong>：系统的实时的信息，不存在硬盘，在内存中。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/xpwA3ODReoGH26M.png" alt="1559293203672"></p><h2 id="3-2-文件系统相关操作"><a href="#3-2-文件系统相关操作" class="headerlink" title="3.2 文件系统相关操作"></a>3.2 文件系统相关操作</h2></li></ul><p>以下命令，为了更好实践巩固，请务必亲自验证。</p><ol><li><p><code>ls</code>显示文件</p><p>命令格式：<code>ls &lt;参数(可选)&gt; &lt;目录（可选，默认当前）&gt;</code> </p><p>常用参数解释：</p><ul><li><p><code>ls</code>：显示文件，但不显示隐藏文件</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/sHrKkwPjLUT9aY3.png" alt="1580816737694"></p></li><li><p><code>ls -a</code>：可显示隐藏文件</p></li><li><p><code>ls -l</code>：详细列出文件信息，不显示隐藏文件（加上参数 -a可以）</p></li><li><p><code>ls -R</code>：递归显示目录结构</p></li><li><p><code>ls -ld</code>：显示目录和链接信息</p></li></ul></li><li><p><code>cd</code> 切换目录</p><blockquote><p>常和<code>pwd</code> 命令配合显示当前目录：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/zaDHgVF4UL51lMx.png" alt="1580817000019"></p></blockquote><p>命令格式：<code>cd &lt;参数(可选)&gt; &lt;目录（可选，默认家目录）&gt;</code> </p><p>常用参数解释：</p><ul><li><code>cd .</code>：切换为当前目录</li><li><code>cd ..</code>： 切换到上级目录</li><li><code>cd ~</code> 、<code>cd</code>：切换到当前用户 <strong>家目录</strong><ul><li>家目录：普通用户在<code>/home/用户名</code>下，root用户在<code>/root</code> 下</li></ul></li><li><code>cd -</code> ：切换到上一个工作目录</li></ul></li><li><p><code>touch/mkdir</code> 创建文件/文件夹</p><p>我们通常使用：</p><ul><li><code>touch &lt;文件名&gt;</code>  : 创建文件</li><li><code>mkdir&lt;目录名&gt;</code>：创建目录</li></ul><blockquote><p>实践：我们切换到根目录下创建相应文件夹/文件<code>/test/readme.md</code> </p></blockquote><p>根目录创建文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /test   <span class="comment"># 加了/指定在根目录下，不加/默认在当前目录</span></span><br></pre></td></tr></table></figure><p>创建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /test/readme.md</span><br></pre></td></tr></table></figure><p>我们切换到根目录下进行查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> / </span><br><span class="line"><span class="built_in">ls</span> -R <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/nQb6L3dXimBRzVs.png" alt="1580817855228"></p></li><li><p><code>cp</code>复制文件</p><p>命令格式：<code>cp &lt;参数（可选）&gt; &lt;源文件/文件夹&gt; &lt;目标文件/文件夹（没有会创建&gt;</code> </p><p>常用参数解释：</p><ul><li><code>cp -r</code>：递归复制整个目录树（<strong>复制文件夹时必须加</strong>）</li><li><code>cp -v</code> ：显示详细信息，复制的详细过程</li></ul><blockquote><p>实践：复制<code>/test/readme.md</code>  —&gt; <code>/test/readme1.md</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /test/readme.md /test/readme1.md</span><br></pre></td></tr></table></figure><p>切换到 <code>/test</code> 下查看如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /test</span><br><span class="line"><span class="built_in">ls</span> -l </span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/XopbvLZcNmGkOIC.png" alt="1580818248218"></p></li><li><p><code>mv</code> 移动文件</p><p> 命令格式：<code>mv &lt;参数(可选)&gt; &lt;源文件/文件夹&gt; &lt;目标文件/文件夹（没有会创建&gt;</code></p><p>:warning: 如果是在当前目录移动，则相当是 <strong>重命名</strong> 文件/文件夹！</p><blockquote><p>实践：利用<code>mv</code> 命令重名<code>/test/readme1.md</code> 为 <code>/test/readme2.md</code> </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /test/readme1.md /test/readme2.md</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/flFqT93WBPRciDX.png" alt="1580818517711"></p></li><li><p><code>rm</code>  删除文件</p><p> 命令格式：<code>rm &lt;参数(可选)&gt; &lt;目标文件/文件夹（没有会创建&gt;</code></p><p>常用参数解释：</p><ul><li><code>rm -i</code>：交互式，会提醒你是否删除</li><li><code>rm -r</code>：递归删除所有目录中所有内容（<strong>删除文件夹一定要</strong>）</li><li><code>rm -f</code>：无任何提示，直接删除</li></ul><blockquote><p>实践：删除我们此前创建的 <code>/test</code>  文件夹，并要求交互式提醒。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -ir /test</span><br></pre></td></tr></table></figure><p>请再次查看是否还存在 <code>/test</code> 目录。</p></li></ol><h2 id="3-3-Linux常用命令-技巧"><a href="#3-3-Linux常用命令-技巧" class="headerlink" title="3.3 Linux常用命令/技巧"></a>3.3 Linux常用命令/技巧</h2><h3 id="3-3-1-Linux常用命令"><a href="#3-3-1-Linux常用命令" class="headerlink" title="3.3.1 Linux常用命令"></a>3.3.1 Linux常用命令</h3><ol><li><p><code>useradd</code> 创建用户</p><p>命令格式：<code>useradd &lt;参数&gt;  &lt;新建用户名&gt;</code> </p><p>常用参数解释：</p><ul><li><code>useradd -m</code> ：创建新用户同时还在<code>/home</code> 创建用户同名文件夹</li></ul><blockquote><p>实践：创建用户<code>huihui</code> ，并修改密码为 <code>123456</code> 。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd  -m huihui     <span class="comment"># 创建用户</span></span><br><span class="line">passwd huihui <span class="comment"># 修改密码</span></span><br></pre></td></tr></table></figure><p>:warning: 修改密码时，Linux上不会有任何字符提示输入，输入完毕直接回车就好。</p><p>我们还需把用户 <code>huihui</code> 添加到<code>sudo</code> 配置文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>进入<code>vim</code> 编辑器，按下<code>i</code> 进入插入模式，输入下面红框字符。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/Ja3NHvt5OiysSEZ.png" alt="1580823743819"></p><p>输入完毕，按下 <code>ESC</code> , 然后输入 <code>:wq!</code> 保存文件即可。</p></li><li><p><code>su</code>切换用户</p><p>命令格式：<code>su &lt;用户名（可选，默认root用户）&gt;</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su huihui     <span class="comment"># 切换用户</span></span><br><span class="line"><span class="built_in">id</span>            <span class="comment"># 显示用户信息</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/9Up7fiD6Wmd5HEk.png" alt="1580820517045"></p><p>特别的，我们切换到<code>huihui</code> 用户是个普通用户，有些命令只能在<code>root</code> 用户权限下执行，我们可以在前加上<code>sudo</code> ，例如：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/rQkolcFAfYx8b9t.png" alt="1580820366798"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">touch</span> /test.txt</span><br></pre></td></tr></table></figure><p>会提示输入<code>root</code>用户密码，输入正确命令便可以被正确执行了。</p><p>最后，你可以切换回<code>root</code> 用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su  <span class="comment"># 会要求输入root用户密码</span></span><br></pre></td></tr></table></figure></li><li><p><code>data/cal</code> 日期时间</p><p>命令格式：<code>data &lt;参数（可选）&gt;</code>  ，显示时间</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/jJxiB74tIFw13VD.png" alt="1580820754534"></p><p>命令格式：<code>cal &lt;参数（可选）&gt;</code>   ，显示日历</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/si8La73ZMBXnoNr.png" alt="1580820801463"></p></li><li><p>查看文件</p><ul><li><code>cat &lt;文件名&gt;</code>：<strong>全部显示</strong></li><li><code>more &lt;文件名&gt;</code> ：<strong>部分显示</strong>，回车一直往下查看</li><li><code>less &lt;文件名&gt;</code>：<strong>部分显示</strong>，↑ 、↓ 键进行查看</li><li><code>head &lt;参数（可选）&gt; &lt;文件名&gt;</code>  ：显示文件头部信息<ul><li>参数，<code>-n 3</code> ：指定显示文件头3行</li></ul></li><li><code>tail &lt;参数(可选)&gt; &lt;文件名&gt;</code>：显示文件尾部部分<ul><li>参数，<code>-n 3</code>：显示3行</li><li>参数，<code>-f</code>：一般用于查看日志，命令不退出，不断显示更新的内容</li></ul></li></ul></li><li><p><code>zip/tar</code> 压缩/打包/解压</p><blockquote><p><code>zip</code> 如果没有安装，需要先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum instal zip</span><br></pre></td></tr></table></figure></blockquote><p>[<strong>zip</strong>]命令格式：<code>&lt;zip&gt; &lt;参数（可选）&gt; &lt;目标文件名&gt; &lt;源文件名&gt;</code> </p><ul><li>压缩后源文件会被保留</li></ul><blockquote><p>实践：家目录下创建文件夹 <code>/test</code> ，并对其进行压缩。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su huihui</span><br><span class="line"><span class="built_in">mkdir</span> ~/test</span><br><span class="line">zip ~/test.zip ~/test</span><br></pre></td></tr></table></figure><p>查看家目录下文件：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/HMI1AXaxYslFErL.png" alt="1580821740854"></p><p>[<strong>tar</strong>] 命令格式：<code>&lt;tar&gt; &lt;参数（可选）&gt; &lt;目标文件名&gt; &lt;源文件名&gt;</code> </p><ul><li><code>tar</code> 命令常用户文件 <strong>打包/压缩/解压</strong></li></ul><blockquote><p>实践：打包并压缩目录 <code>~/test</code> 下所有<code>txt文档</code> </p></blockquote><p>创建2个<code>txt</code> 文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/test/1.txt</span><br><span class="line"><span class="built_in">touch</span> ~/test/2.txt</span><br></pre></td></tr></table></figure><p>打包—&gt; 压缩所有文档（<strong>打包只是整理不等于压缩</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 表示打包文件</span></span><br><span class="line"><span class="comment"># -z 表示打包后在调用gzip进行压缩</span></span><br><span class="line"><span class="comment"># -f 必要参数，表示使用档案名字</span></span><br><span class="line"><span class="built_in">cd</span> ~/test</span><br><span class="line">tar -czf  alltxt.tar.gz  *.txt  <span class="comment"># *表示匹配0个或多个字符</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/fgzJLm1MbUE8CIn.png" alt="1580822896903"></p><blockquote><p>实践：解压<code>~/alltxt.tar.gz</code> </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -x 表示解压文件</span></span><br><span class="line"><span class="comment"># -z 表示使用gzip解压，因为解压的文件被gzip压缩过</span></span><br><span class="line"><span class="comment"># -f 必要参数，表示使用档案名字</span></span><br><span class="line"><span class="comment"># -C 指定解压路径，下面指定解压到家目录下</span></span><br><span class="line">tar -xzf ~/test/alltxt.tar.gz -C ~</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/yMDEJApiYSa8s24.png" alt="1580823016123"></p></li><li><p><code>locate/find</code>查找文件</p><blockquote><p><code>locate</code> 命令如果无法使用，请先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  -y install mlocate</span><br></pre></td></tr></table></figure></blockquote><p>[<strong>locate</strong>] 命令格式：<code>locate  &lt;关键字&gt;</code> </p><blockquote><p>实践：查找此前创建的 <code>1.txt</code> 在哪</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo updatedb  <span class="comment"># 先更新下数据库</span></span><br><span class="line">locate 1.txt</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wXW8h1LrOE9RBqp.png" alt="1580824094815"></p><p>[<strong>find</strong>] 命令格式：<code>find &lt;查找位置&gt; &lt; 查找参数&gt; &lt;需要查找的文件&gt;</code></p><p>常用参数解释：</p><ul><li>&lt;查找位置&gt; ： <code>.</code> 表示从当前目录查找；<code>/</code> 表示从根目录全盘查找</li><li>&lt;查找参数&gt;：指定以什么方式查找<ul><li>-<code>name</code>：按文件名查找</li></ul></li><li>&lt;需要查找的文件&gt;：支持正则表达形式</li></ul><blockquote><p>实践：查找此前创建的 <code>1.txt</code> 在哪</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find / -name *.txt</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/xLJnHAbNYiKsjW4.png" alt="1580824728358"></p></li><li><p><code>jobs/fg</code> 作业管理</p><p>很多时候，我们会使用<code>ctrl+z</code> 中断当前命令后台运行。比如，我们输入<code>sudo visudo</code>进入编辑模式：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/TfyJI3U2WQrM79b.png" alt="1580825644578"></p><p>但是，这个时候我们又想切换回中端，于是按下<code>ctrl+z</code> 。</p><p>使用<code>jobs</code> 命令可以查看后台运行的命令：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/yCIzWsj5u73krPQ.png" alt="1580825772209"></p><p>这个时候我们如果还想继续编辑，只需键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> 5  <span class="comment"># 把后台命令前台运行，注意序号可能不是5是1</span></span><br></pre></td></tr></table></figure><p>当然，如果不需要再编辑，可以直接杀死该进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> %5 <span class="comment"># 注意序号可能不是5是1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-2-常用技巧"><a href="#3-3-2-常用技巧" class="headerlink" title="3.3.2 常用技巧"></a>3.3.2 常用技巧</h3><blockquote><p>本节将介绍linux最常用的技巧。</p></blockquote><ol><li><p>TAB自动补全</p><p>TAB可使得我们只需键入 <strong>命令/文件/文件夹</strong> 一部分，便可直接按<code>TAB</code> 键自动补全。</p><p>如果你快速双击两次<code>TAB</code> 还会显示当前可自动补全的全部选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/h</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/xlOLYBaz6q2p1Sw.png" alt="1580825096651"></p></li><li><p>重复命令技巧</p><ul><li><code>↑</code>+<code>回车</code>：执行上一条命令</li><li><code>!字符</code>：重复前一个以指定“字符”开头命令</li><li><code>!num</code>：按照历史序号执行</li><li><code>!?abc</code>：重复之前包含abc的命令</li><li><code>Esc</code>+<code>.</code>：复制上一个命令参数</li></ul></li><li><p>命令搜索</p><ul><li><p><code>history</code>：显示之前命令</p></li><li><p><code>ctrl+r</code> ：键入关键字后，会自动搜索符合的命令</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/T4VtcioqkN2Kwgy.png" alt="1580825340128"></p></li></ul></li><li><p>获取帮助</p><p>非常常见的事，你会经常不记得一个命令的参数、用法。除了立即谷歌/百度/冥思苦想/…，你还可以借助Linux系统自带命令来查看相关命令用法。</p><p>我们将主要解释 <code>help</code> / <code>man</code> 两种相关方法查看命令帮助。</p><ul><li><p><code>help</code> </p><p>几乎所有命令都可以使用  <code>--help</code>参数获取使用方法、参数信息等。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/huxitfzNPJoD3a4.png" alt="1580828331572"></p></li><li><p><code>man</code></p><p><code>man</code>命令是<code>Linux</code> <strong>最为常用</strong> 的帮助命令。</p><p>命令格式：<code>man &lt;参数(可选)&gt; &lt;命令&gt;</code></p><p>常用参数：</p><ul><li><code>-k</code> ：此时<code>&lt;命令&gt;</code> 可以不全，搜索相关相关命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/lWY9IwyShZB6kr8.png" alt="1580828423093"></p><p>:slightly_smiling_face: 快速定位技巧：进入<code>man</code> 文档 —&gt; 输入 <code>/ &lt;keywords&gt;</code> 快速搜索/高亮指定关键字。</p><p>例如输入：<code>/ -a</code> 再回车</p></li></ul></li></ol><h2 id="3-4-vim-基础入门"><a href="#3-4-vim-基础入门" class="headerlink" title="3.4 vim 基础入门"></a>3.4 <code>vim</code> 基础入门</h2><p>后续实验多次需要使用<code>vim</code>文本 编辑功能，请仔细按照下述步骤实操。</p><p><code>vim</code> 编辑器有三种模式：</p><ul><li>命令模型：默认进入时就是命令模型，此模式下只接受命令对文本进行操作</li><li>插入模式：命令模式下按下 <code>i</code>、<code>O</code> 键可进入，此模式下可对文本进行编辑、插入</li><li>EX模式：命令模式下输入 <code>:</code> 便可进入EX模式，用户保存修改或退出<code>vim</code></li></ul><h3 id="3-4-1-vim实践"><a href="#3-4-1-vim实践" class="headerlink" title="3.4.1 vim实践"></a>3.4.1 vim实践</h3><blockquote><p>进入命令模式有两种方式：</p><ul><li>初始进入编辑文件时，默认就是命令模式</li><li>在其它模式下按下 <code>ESC</code> 键便可进入命令模型</li></ul></blockquote><p>常用<strong>命令模式</strong>下命令如下：</p><p><code>vim</code> 启动后默认进入的就是命令模式，只接受命令，如输入：</p><ul><li><code>i</code>：进入插入模式（<kbd>Esc</kbd> 退回到命令模式，下同）</li><li><code>dd</code>：删除整行，还是命令模式</li><li><code>yy</code>：复制鼠标当前行，还是命令模式</li><li><code>p</code>：粘贴复制的行</li><li><code>u</code>：撤销上一个操作</li><li><code>/</code>：查找关键字，按下<kbd>n</kbd>可以不断切换</li></ul><blockquote><p>按下<kbd>:</kbd>可进入EX模式，用户保存修改或者退出<code>vim</code>。</p></blockquote><p>常用<strong>EX模式</strong> 下命令如下：</p><ul><li><code>:q</code> / <code>:q!</code>：退出 /强制退出（比如文件只读修改时）</li><li><code>:w</code>：保存当前文件</li><li><code>:wq</code>==<code>:x</code>  ：保存并退出</li><li><code>:set number</code>：显示行号</li><li><code>:sh</code>：切换回命令行，<kbd>ctrl+d</kbd>&gt;返回vim</li></ul><blockquote><p>实践：在<code>~</code> 目录下创建<code>hello.txt</code> ，使用<code>vim</code> 编辑。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/hello.txt </span><br><span class="line">vim ~/hello.txt </span><br></pre></td></tr></table></figure><ol><li><p>插入模式</p><p>按下 <code>i</code> 键插入模式，输入以下字符</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/dEolbAenUYSmPHq.png" alt="1580827178980"></p></li><li><p>疯狂复制</p><p>按下<code>ESC</code> 键进入命令模式 —-&gt; 光标移动到 <code>hello linux</code> 那行 —&gt; 按下<code>yy</code> 进行复制 —&gt; 按下<code>p</code> 进行多次复制：</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/5TtjMQgvASspz4m.png" alt="1580827311122"></p></li><li><p>显示行号</p><p>按下<code>ESC</code> 键进入命令模式 —-&gt; 输入 <code>:set number</code> —&gt; 显示行号</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/rPbJkzsOt56gYSV.png" alt="1580827739828"></p></li><li><p>保存退出</p><p>按下<code>ESC</code> 键进入命令模式  —&gt; 输入 <code>:wq!</code> —&gt; 退出</p><p>查看是否保存成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n ~/hello.txt   <span class="comment"># 参数n表示同时显示行号</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/ZKAkQHV5M9wlG2p.png" alt="1580827833838"></p></li></ol><h2 id="3-5-用户权限基础"><a href="#3-5-用户权限基础" class="headerlink" title="3.5 用户权限基础"></a>3.5 用户权限基础</h2><h3 id="3-5-1-用户与组"><a href="#3-5-1-用户与组" class="headerlink" title="3.5.1 用户与组"></a>3.5.1 用户与组</h3><p><strong>[用户] 限制使用者或者进程</strong> 可以使用，不可以使用哪些资源 。</p><ul><li><p><strong>用户种类</strong>：root用户（ID: 0）；系统用户（ID:1~499）；普通用户（ID:500以上）</p></li><li><p><strong>用户与组</strong>：每个用户属于一个<strong>主</strong>组，一个或多个<strong>附属</strong>组</p></li><li><p><strong>用户与shell</strong>：每个可登陆用户有一个指定<strong>shell</strong></p></li><li><p><strong>用户相关配置文件</strong>：</p><ul><li><p><code>/etc/passwd</code> ： 保存用户信息</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/ZFdIytj8TGk1L5M.png" alt="1559463477365"></p></li><li><p><code>/etc/shadow</code>：保存用户密码（加密的）</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/Sai8luV2tox51BL.png" alt="1559463591598"></p></li><li><p><code>/etc/group</code> ：保存组信息</p><p><img src="http://photogz.photo.store.qq.com/psc?/V11U3iyo16Rd4R/05RlWl8gsTOH*Z17MtCBzK7cwww8sxM0QgfLdTfuYxUTt2BRZg7mokGvOHWriYGy5NQz2VGzyOk6pLMI8sC8gg!!/m&amp;bo=ugDwAboA8AEWADA!&amp;rf=mood_app" alt=""></p></li></ul></li></ul><p><strong>[组]用来管理用户</strong>，每个组拥有一个<code>GroupID</code>。 </p><blockquote><p>独立完成以下用户创建及相关操作。</p></blockquote><ol><li><p>创建用户</p><p>命令格式：<code>useradd &lt;参数(可选)&gt; &lt;用户名&gt;</code> </p><blockquote><p>执行<code>useradd</code> 命令，会执行以下默认操作：</p><ol><li>在<code>/etc/passwd</code>添加用户信息</li><li>为用户建立一个家目录 <code>/home/&lt;username&gt;</code></li><li>将<code>/etc/shel</code>（用户刚建立的初始文件） 复制到用户家目录</li></ol></blockquote><p>常用参数解释：</p><ul><li><code>-u</code> ：指定userID</li><li><code>-g</code>：指定主组，默认<strong>会建立一个和用户同名的组</strong>，用户默认属于这个组。</li><li><code>-G</code> : 指定附属组</li></ul><blockquote><p>实践：创建一个用户 <code>lxSmile</code> ，并指定<code>userID=555</code>(普通用户id)，所属组为 <code>testGroup</code> 。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root              <span class="comment"># 切换到root权限</span></span><br><span class="line">groupadd testGroup   <span class="comment"># 创建组testGroup</span></span><br><span class="line">useradd -u 555 -g testGroup lxSmile</span><br></pre></td></tr></table></figure><p>查看创建用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> lxSmile</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/lhxVifvkAmWQsNp.png" alt="1580873280514"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n -E /etc/passwd   <span class="comment"># 在/etc/passwd配置文件查看用户信息</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/6AZTatvS4NCqe5P.png" alt="1580873449521"></p></li><li><p>修改用户</p><p>命令格式：<code>usermod &lt;参数(可选)&gt; &lt;用户名&gt;</code></p><p> 常用参数解释：</p><ul><li><code>-l</code> ：修改用户名</li><li><code>-u</code>：新<code>userID</code></li><li><code>-g</code>：用户所属组</li><li><code>-G</code>：用户所属附属组</li></ul><blockquote><p>实践：修改用户 <code>lxSmile</code> ，修改<code>userID=666</code>(普通用户id)，所属组为 <code>testGroup1</code> 。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd testGroup1</span><br><span class="line">usermod -u 666 -G testGroup1 -g testGroup1 lxSmile</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/2uhroiaEYZK1Dns.png" alt="1580874102378"></p></li><li><p>删除用户</p><p>命令格式：<code>userdel &lt;参数(可选)&gt; &lt;用户名&gt;</code></p><p>常用参数解释：</p><ul><li><code>-r</code> ：同时删除用户家目录（默认不删除）</li></ul><blockquote><p>实践：删除刚刚创建的用户 <code>lxSmile</code> ，并同时删除其家目录。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r lxSmile</span><br></pre></td></tr></table></figure><p>查看是否还存在：<br><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/cCEbYyew8DQmKhV.png" alt="1580874374129"></p></li></ol><h3 id="3-5-2-文件权限实操"><a href="#3-5-2-文件权限实操" class="headerlink" title="3.5.2 文件权限实操"></a>3.5.2 文件权限实操</h3><p><strong>[文件权限]用来管理文件读、写、执行</strong> ，每个文件都有特定权限、所属组、所属用户。</p><ul><li><p><strong>权限类型</strong>：权限分为读(<strong>r</strong>)、写(<strong>w</strong>)、执行(<strong>x</strong>)</p></li><li><p><strong>UGO权限控制</strong>：Linux权限基于<strong>UGO</strong>模型进行控制</p><ul><li><p><strong>UGO</strong>：<strong>User、Group、Other</strong>，每一个文件权限都基于UGO设置（即用户、所属组、和其它用户能操作权限）</p></li><li><p><code>ls -l &lt;文件/文件夹名&gt;</code> ：可查看权限</p><p>根据下图我们可以知道 <strong>test</strong> ：</p><p>类型为目录(<strong>d</strong>)，所属用户权限为<u>读写执行</u> (<strong>rwx</strong>)，所属组权限为<u>读写执行</u> (<strong>rwx</strong>)，其它用户权限为<u>读执行</u> (<strong>r-x</strong>)，所属用户为<strong>huihui</strong>，所属组为<strong>huihui</strong>，大小为<strong>4096</strong>B，修改时间为<strong>21:26</strong>。</p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/nezgdBADYJ1oI2m.png" alt="1580872154732"></p></li></ul></li></ul><blockquote><p>独立完成以下文件权限相关操作。</p></blockquote><p>首先我们创建相关测试文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">mkdir</span> test5</span><br><span class="line"><span class="built_in">touch</span> /test5/5.txt</span><br></pre></td></tr></table></figure><ol><li><p>修改文件所属用户</p><p>命令格式: <code>chown &lt;参数(可选)&gt;  &lt;用户名&gt; &lt;文件/文件夹&gt;</code> </p><p>常用参数：</p><ul><li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属用户</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R huihui /test5   <span class="comment"># 修改文件夹test5所属用户为huihui</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/6ZzT83RuULWnDif.png" alt="1580875145288"></p></li><li><p>修改文件所属组</p><p>命令格式: <code>chgrp &lt;参数(可选)&gt;  &lt;组名&gt; &lt;文件/文件夹&gt;</code> </p><p>常用参数：</p><ul><li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属组</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> -R huihui /test5   <span class="comment"># 修改文件夹test5所属组为huihui</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/FmjuR8xk2UHeMKb.png" alt="1580875299501"></p></li><li><p>修改文件权限</p><p>命令格式: <code>chmod &lt;参数(可选)&gt;  &lt;模式&gt; &lt;文件/文件夹&gt;</code> </p><p>常用参数：</p><ul><li><code>-R</code> ：递归的修改文件夹下所有子文件/文件夹的所属用户</li></ul><blockquote><p>修改 <code>/test5/5.txt</code> ，权限从<code>rw-r--r--</code> —-&gt; <code>r--rwxrwx</code> </p><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/RzfMbQe7tqukxlE.png" alt="1580875509098"></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户（U）权限[减去写]权限</span></span><br><span class="line"><span class="built_in">chmod</span> u-w /test5/5.txt</span><br><span class="line"><span class="comment"># 组（G）/其他用户（O）权限[加上写、执行]</span></span><br><span class="line"><span class="built_in">chmod</span> go+wx /test5/5.txt</span><br></pre></td></tr></table></figure><p><img src="https://blog-imgs-1256686095.cos.ap-guangzhou.myqcloud.com/wi8lt2QSJZf7VcB.png" alt="1580875689076"></p></li></ol><h1 id="4-实验小结"><a href="#4-实验小结" class="headerlink" title="4 实验小结"></a>4 实验小结</h1><p>本次实验虽然只是简单地对接下来实验所需的linux操作进行初步熟悉，但是或许第一次接触linux的你还是觉得颇为困难。但是不用担心，后续所有有关linux操作，你在本次实验中已经全部学习过了，相关操作也有详细的实验指导。</p><p>接下来，你将正式开始<code>Spark/Hadoop</code> 的学习，希望你能收获满满 : )。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux学习 </tag>
            
            <tag> 大数据导论 </tag>
            
            <tag> 华为云学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
